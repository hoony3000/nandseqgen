---
title: ChatGPT Export
exported_at: 2025-08-14_05-41
---

## ğŸ‘¤ User

ì•„ë˜ ê¸€ì€ NAND operation sequence generation ì„ ìœ„í•´ draft ë¡œ ì‘ì„±í•œ design ë¬¸ì„œì•¼. ì´ ë¬¸ì„œë¥¼ ì‘ì„±í•œ ëª©ì ì€ íŒŒì´ì¬ ì½”ë“œ êµ¬í˜„ì„ ìœ„í•´ system ì„¤ê³„ë¥¼ ì–´ë–»ê²Œ í•´ì•¼í•  ì§€ ê²€í† í•˜ê¸° ìœ„í•´ì„œ ì‘ì„±í–ˆì–´. ì´ ë¬¸ì„œì˜ í‘œí˜„ì„ ê°€ë‹¤ë“¬ê³  êµ¬ì¡°í™”í•´ì„œ, ì‹¤ì œ êµ¬í˜„ì— ë„ì›€ì´ ë˜ê²Œë”, ê·¸ë¦¬ê³  êµ¬í˜„ ìƒ ë°œìƒí•˜ëŠ” risk ë¥¼ ëª…ì‹œí•´ì„œ ê·¸ê±¸ ìµœì†Œí™” í•˜ë ¤ê³  í•´. ì•„ë˜ ë¬¸ì„œë¥¼ ìœ„ì˜ ë°°ê²½ì— ë§ê²Œ ì¬ì‘ì„± í•´ì¤˜.
â€”â€”â€”â€”
**Symbols : ì„¤ëª…ì´ í•„ìš”í•œ ë¶€ë¶„**
-. StateSeq : times, states ë¥¼ ì €ì¥í•˜ì—¬ ì‹œê°„ëŒ€ë³„ ì—°ì†ì ì¸ nand state ë¥¼ ì €ì¥í•˜ëŠ” data class
-. Operation : Operation data class. StateSeq ë¥¼ í¬í•¨í•¨
-. OperSeq : Operation instance ì˜ ë°°ì—´
-. HostReq : host ì˜ ìš”ì²­ data class. ì´ê²ƒì„ í•´ì„í•˜ì—¬ OperSeq ìƒì„±
-. scheduler
    -. ê¸°ëŠ¥ : nand ë™ì‘ì„ ì‹¤ì œë¡œ ìŠ¤ì¼€ì¥´ë§ í•´ì„œ ê¸´ nand ë™ì‘ seq ë¥¼ ìƒì„±
    -. busytable : Operation ì„ ë“±ë¡í•˜ë©´ ì‹œê°„ëŒ€ë³„ ì—°ì†ì ì¸ nand state ê°€ ì €ì¥ë¨.
    -. historylist : Operation ì„ ë“±ë¡í•˜ë©´ ì‹œê°„ëŒ€ë³„ Operation ì˜ ì ìœ ìœ¨ ì €ì¥
    -. timer : Operation ì´ ì‹¤ì œ ìˆ˜í–‰ëì„ ë•Œ, ë™ì‘ì´ ëë‚ ë•Œê¹Œì§€ ë‚¨ì€ ì‹œê°„ ì €ì¥. clock ì´ ì•ìœ¼ë¡œ ì›€ì§ì´ë©´ ì°¨ê°ë¨.
-. Address manager
    -. ê¸°ëŠ¥ : nand ì˜ erase, pgm, read ë¥¼ ìˆ˜í–‰í•˜ê¸° ìœ„í•´ block ì´ ì–´ë–¤ ìƒíƒœì¸ì§€ í™•ì¸í•˜ê³ , ìš”ì²­ì´ ì˜¤ë©´ ë™ì‘ ê°€ëŠ¥í•œ address ë¥¼ ë¦¬í„´.
    -. addrstates : address ì—ì„œ nand ì˜ pgm ëœ ìƒíƒœë¥¼ ë‚˜íƒ€ëƒ„
    -. -3 : badblock, canâ€™t be used
    -. -2 : initial, not erased
    -. -1 : ERASED
    -. 0~pagesize-1 : ë§ˆì§€ë§‰ pgm ëœ page address ê°’
    -. get_adds_val : address ì— ì €ì¥ëœ addrstates ê°’ì„ ë°˜í™˜.
    -. get_pgmable : nand ì „ì²´ address ì—ì„œ pgm ê°€ëŠ¥í•œ ddress ë°˜í™˜
    -. get_readable : nand ì „ì²´ address ì—ì„œ read ê°€ëŠ¥í•œ address ë°˜í™˜
-. Queue mananger
    -. ê¸°ëŠ¥ : queue list ë¥¼ ìš°ì„  ìˆœìœ„ì— ë§ì¶° ì •ë ¬ ë° queue ì˜ ê°’ì„ ë°˜í™˜
    -. queue list : host ë˜ëŠ” nand ê°€ ìš”ì²­í•œ Operation ì„ ì €ì¥í•˜ëŠ” data type
    -. dependency check : nand ëŠ” target address ì— ëŒ€í•´ì„œ erase -> pgm -> read ìˆœìœ¼ë¡œ ì§„í–‰ë˜ì–´ì•¼ í•˜ê³ , Operation sequence ê°€ ê·¸ ê·œì¹™ì— ë§ëŠ”ì§€ í™•ì¸í•˜ëŠ” ê¸°ëŠ¥

**Operation ì„ NAND busytable ì— ì¶”ê°€í•˜ëŠ” ìˆœì„œ**
1. scheduler ê°€ Queue manager ì—ê²Œ ìš”ì²­ ì‚¬í•­ list ê°€ ë‚¨ì•„ ìˆëŠ”ì§€ í™•ì¸
2. Queue manager ëŠ” ìš°ì„  ìˆœìœ„ë¥¼ ì—…ë°ì´íŠ¸ í•˜ê³ , ì²«ë²ˆì§¸ HostReq ë¥¼ scheduler ì—ê²Œ ì „ë‹¬
3. scheduler ëŠ” HostReq ë¥¼ HostReq to OperSeq ì— ì¸ìë¡œ ë„˜ê²¨ì„œ OperSeq ë¥¼ ë°˜í™˜ ë°›ìŒ
4. OperSeq ëŠ” scheduler ë‚´ë¶€ queue list ì— (Oper1, until_time1), (Oper2, until_time2), â€¦ ì— ì €ì¥í•´ë‘ê³ , Operation ì€ busytable, historylist ì— ì¶”ê°€. until_time ì€ timer ì— í• ë‹¹í•˜ê³  clock ì´ ì›€ì§ì´ëŠ” ê±°ì— ë”°ë¼ ì°¨ê°í•˜ê³ , until_time1 ì´ 0 ì´ ë˜ë©´ scheduler ëŠ” Operation2 ë¥¼ ì¶”ê°€í•˜ê³ , until_time2 ë¥¼ timer ì— í• ë‹¹í•œë‹¤.
5. until_time ì´ ê³„ì‚°ë˜ê¸° ìœ„í•´ì„œ StateSeq ë‚˜, Operation class ì—ì„œ times ë°°ì—´ì„ ë³´ê³  until_time ì„ ê³„ì‚°í•´ì•¼ í•  ë“¯
6. scheduler ëŠ” HostReq ë¡œ ìš”ì²­í•œ Operation : ophost ê³¼, scheduler ìì²´ì ìœ¼ë¡œ ìƒ˜í”Œë§í•œ Operation : opnand ì¤‘ ì„ íƒí•´ì•¼ í•œë‹¤.

**self thoughts**
-. ì–´ëŠ ì‹œì ì— req_queue ë¥¼ ë“¤ì—¬ë‹¤ ë´ì•¼ í•˜ëŠ”ê°€?
-. sampling ì€ ì–´ëŠ ì‹œì ì— host, nand ì¤‘ ì–´ë””ì—ì„œ í•´ì•¼ í•˜ëŠ”ê°€?
-. host ìš”ì²­ì´ ë¬´í•œíˆ ìŒ“ì´ëŠ” ê²½ìš° nand ì˜ ë™ì‘ì„ ìˆ˜í–‰í•  ìˆ˜ ì—†ê¸° ë•Œë¬¸ì—, host ì˜ ìš”ì²­ì„ ì ì ˆíˆ ì œí•œí•˜ëŠ” ë©”ì»¤ë‹ˆì¦˜ í•„ìš”. queue list ì˜ í¬ê¸°ë¥¼ ì œí•œí•˜ë©´ ê°€ëŠ¥. queue list ë¥¼ ë“¤ì—¬ë‹¤ ë³´ëŠ” ì£¼ì²´ëŠ” scheduler
-. host ê°€ ìš”ì²­í•œ operation ê³¼ nand ê°€ ìì²´ ìˆ˜í–‰í•˜ëŠ” operation ì€ ìš°ì„  ìˆœìœ„ê°€ ì¡´ì¬. host ì˜ ìš”ì²­ì´ ìµœìš°ì„ ì´ë‹¤. í˜„ì¬ ìˆ˜í–‰ë˜ëŠ” operation ì´ host ì˜ ìš”ì²­ì¸ì§€ êµ¬ë¶„í•  ìˆ˜ ìˆëŠ” ë°ì´í„°ë‚˜ êµ¬ì¡° í•„ìš”-. host ì˜ ëª…ë ¹ì— ì˜í•œ operation ë„ ìš°ì„ ìˆœìœ„ ì¡´ì¬. pgm < read ì´ë©°, pgm ì„ ìˆ˜í–‰í•˜ë ¤ê³  í–ˆì§€ë§Œ, nand address manager ê°€ pgm í•  block ì´ ì—†ë‹¤ê³  í•˜ë©´, read (to assign a new block) > dout > erase > pgm (new) > pgm (target) ìˆœìœ¼ë¡œ ìˆ˜í–‰í•´ì•¼ í•œë‹¤. (ì—„ì²­ë‚œ latency ë°œìƒ). ì´ëŸ° ì´ìœ ë¡œ nand ê°€ í˜„ì¬ pgmable block ì´ ì–´ëŠ ì •ë„ ìˆëŠ”ì§€ tracking í•˜ë©´ì„œ garbage collection ìš© operation ì„ ì¶”ê°€í•´ì•¼ í•¨.
-. nand ê°€ ìì²´ì ìœ¼ë¡œ ìˆ˜í–‰í•˜ëŠ” OperSeq ëŠ”
-. Garbage Collection : pgm ê°€ëŠ¥í•œ block ì„ ë§Œë“¦
    -. invalid ratio in a block ì„ ëª¨ë‹ˆí„°ë§ í•´ì„œ ìˆ˜í–‰
    -. read > dout > pgm (new) > read > dout > pgm (new) > â€¦ > erase
-. Read Reclaim : ì˜¤ë˜ëœ block ì„ ì½ì–´ë³´ë©° failbit ìˆ˜ì¤€ ëª¨ë‹ˆí„°ë§
    -. read > dout > read > dout > â€¦ > read dout
-. Garbage Collection, Read Reclaim ì„ ì¶”ê°€í•  ê²ƒì¸ì§€ëŠ” option ìœ¼ë¡œ ê´€ë¦¬
-.ê²°êµ­ host, nand ëª¨ë‘ ìƒì„±í•´ì•¼ í•  data class ëŠ” OperSeq ì´ê³ , Host ì˜ ìš”ì²­ì— ëŒ€ì‘í•˜ëŠ” ê²ƒì€ nand ê°€ ëœë¤í•œ target address ì— í• ë‹¹í•˜ë©´ ë˜ê³ , nand ëŠ” ì–´ë–¤ address ì— ì–´ë–¤ ë™ì‘ì„ í–ˆë‹¤ëŠ” ê²ƒì„ ì°¸ê³ í•œ target address ë¥¼ ìƒì„±í•˜ëŠ”ê²Œ ìì—°ìŠ¤ëŸ½ë‹¤. í•˜ì§€ë§Œ ê·¸ê²ƒì„ ê³ ë ¤í•œ target address ìƒ˜í”Œë§ ë¡œì§ì„ ë„£ì§„ ì•Šê² ë‹¤.
-. nand ê°€ Operation ì„ ì¶”ê°€í•  ë•Œ, ë°”ë¡œ í™•ì¸ ê°€ëŠ¥í•œ ë™ì‘(SR, reset ë“±) ì€ ë°”ë¡œ ì¶”ê°€í•˜ë©´ ë˜ê³ , ê·¸ë ‡ì§€ ì•Šì€ ë™ì‘ì€ ì§€ê¸ˆ ìˆ˜í–‰ë˜ëŠ” ë™ì‘ì„ ê¸°ë‹¤ë¦¬ë“ ì§€(ë§Œì•½ step clock sampling ì´ë¼ë©´), ì•„ë‹ˆë©´ ëë‚˜ëŠ” ì‹œì ì„ ê³„ì‚°í•´ì„œ ê·¸ ë•Œ ì¶”ê°€í•˜ê²Œ í•œë‹¤. ì´ ë•Œ die, plane ì˜ busytable ì„ ëª¨ë‘ ì°¸ê³ í•´ì„œ ê°€ì¥ ë¹ ë¥¸ ì‹œì ì„ ê¸°ì¤€ìœ¼ë¡œ í•œ time ì„ ìƒ˜í”Œë§ í•˜ì—¬ ì¶”ê°€.
-. ë™ì‘ ì˜ˆì•½ì€ plane ë‹¹ í•˜ë‚˜ë§Œ busytable ì— ì˜ˆì•½ ê°€ëŠ¥í•˜ë©° ë¯¸ë˜ ì‹œì ì„ ìƒ˜í”Œë§ í•´ì„œ ì˜ˆì•½. ì˜ˆì•½ ì‹œ queue list ì— ë„£ì–´ë‘ê³ , ì‹¤í–‰ì€ í˜„ì¬ ì‹œê°„ ê¸°ì¤€ìœ¼ë¡œ í•œë‹¤. ì‹¤í–‰ì˜ ì˜ë¯¸ëŠ” ì˜ˆì•½ëœ ë™ì‘ì´ queue list ì—ì„œ ë¹ ì§€ê¸° ë•Œë¬¸ì— ë‹¤ìŒ ë™ì‘ ì˜ˆì•½ì´ ê°€ëŠ¥í•´ ì§„ë‹¤. ì‹¤í–‰ ì‹œê°„ì€ step clock ë‹¨ìœ„ë¡œ í•˜ëŠ” ê²Œ ì•„ë‹ˆë¼ ì˜ˆì•½ëœ ë™ì‘ì´ ì‹œì‘ë˜ëŠ” ì‹œì ìœ¼ë¡œ clock ì„ ì˜®ê²¨ì„œ ì‹¤í–‰. ê·¸ë˜ì•¼ seq vs. patt ê°„ mismatch ê°€ ì—†ë‹¤.
-. queue list ì— ìˆëŠ” ë™ì‘ë“¤ ì‚¬ì´ì—ì„œëŠ” ìˆœì„œìƒ dependency check ì„ ë§Œì¡±í•´ì•¼ í•œë‹¤. ì—¬ê¸°ì„œ host, nand ê°„ ìš°ì„ ìˆœìœ„ ì¶©ëŒì´ ì¼ì–´ë‚˜ëŠ” ë¶€ë¶„ì¸ë°, êµ¬ì²´ì  ì˜ˆëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤
-. host ëŠ” read ìš”ì²­ì„ í–ˆê³ , nand ëŠ” í•´ë‹¹ block ì„ erase í•˜ê³ , ë‹¤ë¥¸ block ì„ pgm í•˜ë ¤ê³  í•œë‹¤ : read ìš”ì²­ì„ queue list ì—ì„œ ìš°ì„ ìˆœìœ„ë¡œ í•´ì„œ sorting ì„ í•˜ê³ , erase ë™ì‘ ì´í›„ì˜ ë™ì‘ì€ ë‚˜ì¤‘ìœ¼ë¡œ í•œë‹¤. ì´ ê²½ìš° nand ëŠ” ì´ë¯¸ address manager ë¡œ í•´ë‹¹ block ì„ ERASE ìƒíƒœë¡œ ë³€ê²½í–ˆê¸° ë•Œë¬¸ì—, í•´ë‹¹ block address ì— ì ‘ê·¼í•˜ì§€ ëª»í•˜ì—¬ address manager ì˜ get_adds_val ê°’ì´ invalid í•˜ê²Œ ë‚˜ì˜¨ë‹¤. (scheduler ê°€ host ì˜ read ìš”ì²­ì„ ì²˜ë¦¬í•  ë•Œ get_adds_val ê°’ê³¼ target address ë¥¼ ë¹„êµí•˜ì—¬ ìš°ì„  ìˆœìœ„ sorting trigger ë¥¼ ë°œë™ ì‹œì¼œì•¼í•¨).
-. host ì˜ ìš”ì²­ì€ í•­ìƒ address manager ì˜ ì»¨íŒì„ ë°›ê³ , dependency check ì„ queue list ì— ëŒ€í•´ì„œ ìˆ˜í–‰í•˜ê³ (list ì˜ ê°€ì¥ ì²˜ìŒì— ì¶”ê°€ëœë‹¤ê³  í•˜ë©´ dependency check ë¥¼ ìˆ˜í–‰í•  í•„ìš”ê°€ ì—†ë‹¤).
-. read operation ì´ ìˆœì°¨ì ìœ¼ë¡œ ì˜ˆì•½ë˜ì–´ ìˆìœ¼ë©´, ìˆœì„œë¥¼ ì¡°ì •í•´ overall read latency ë¥¼ ê°œì„ í•˜ê¸° ìœ„í•´ì„œ concurrent active plane ì´ ìµœëŒ€ê°€ ë˜ê²Œë” ìˆœì„œë¥¼ ì¡°ì •í•´ì•¼ í•œë‹¤. ë§Œì•½ read ì¤‘ê°„ì— pgm, erase ê°€ ê»´ìˆìœ¼ë©´, read ë¥¼ ì•ì— ìµœëŒ€í•œ ë°°ì¹˜ë¥¼ í•œë‹¤. ë°°ì¹˜ ì´í›„ì—ëŠ” dependency check ë¥¼ í•´ì„œ ë¬¸ì œê°€ ì—†ëŠ”ì§€ í™•ì¸ì´ í•„ìš”í•˜ë‹¤. ê·¸ëŸ¬ê¸° ìœ„í•´ì„œëŠ” address manager ê°€ read ì˜ ì´ë™ ì „ì— dependency check ë¥¼ ìš°ì„  ìˆ˜í–‰í•´ì•¼ í•˜ê³ , ë§Œì•½ ë¶ˆê°€ëŠ¥í•˜ë‹¤ê³  í•˜ë©´ ì´ë™í•˜ì§€ ì•Šì•„ì•¼ í•œë‹¤. ë§Œì•½ OperSeq ë¡œ ì—°ì†ì ì¸ operation ì„ queue ì— ì¶”ê°€í•  ë•Œ, ì´ê²ƒì€ dependency ê°€ ìˆëŠ” Seq ì´ë‹ˆ ì´ë™ì´ ë¶ˆê°€í•˜ë‹¤ëŠ” ì •ë³´ë¥¼ ì €ì¥í•´ ë‘”ë‹¤ë©´, ì‚¬ì „ì— ë°©ì§€í•  ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ, ë³„ê°œë¡œ ì¶”ê°€í•œ operation ì´ dependency ê°€ í˜•ì„±ë˜ì–´ ë²„ë ¸ë‹¤ë©´, ì´ë¥¼ ì‚¬ì „ì— ì•Œì§€ ëª»í•˜ë¯€ë¡œ dependency check ë¥¼ ì§„í–‰í•´ì•¼ í•œë‹¤. ë˜ í•˜ë‚˜ ë‹¤ë¥¸ ë¬¸ì œëŠ”, address manager ê°€ validity check ë¥¼ ì‹œì ì„ ì˜®ê²¨ ê°€ë©° í•´ì•¼ í•œë‹¤. ì˜®ê¸°ê¸° ì „ê³¼, ì˜®ê¸´ í›„ì— addrstates ê°’ì´ ë‹¤ë¥´ê¸° ë•Œë¬¸ì— ê·¸ê±¸ ë‹¤ë£¨ëŠ” ë¡œì§ì´ í•„ìš”í•˜ê²Œ ëœë‹¤.

**Decisions**
-. system ì˜ ì—­í• ì„ ì •ì˜ í•„ìš”
    -. nand ì˜ address manager ë¥¼ í†µí•´ get_pgmable(), get_readable() ì„ ìˆ˜í–‰í•˜ë©°, ì „ì²´ address ì—ì„œ pamgable, readable ê°€ ì¶©ë¶„í•˜ë„ë¡ ë¹„ìœ¨ì„ ì¡°ì ˆí•´ì•¼ í•œë‹¤.
    -. host ìš”ì²­ì— ì˜í•œ HostReq ë¥¼ OperSeq ë¡œ ë³€í™˜ í›„ scheduler ì— ì¶”ê°€
-. Garbage Collection 
    -. ëª©ì  : pgm block ê°€ëŠ¥í•œ block ì„ ë§Œë“œëŠ” ê²ƒìœ¼ë¡œ í•œì •
    -. system ì´ ì£¼ê¸°ì ìœ¼ë¡œ address manager ì—ê²Œ get_pgmable() ì„ ì „ë‹¬ë°›ì•„ì„œ Erase ìš© OperSeq ë¥¼ ì—¬ëŸ¬ê°œ ì¶”ê°€

**Critial Questions**
-. Clock ì€ ì–´ë–¤ step ìœ¼ë¡œ ì›€ì§ì—¬ì•¼ í•˜ëŠ”ê°€? step í˜•ì‹ or likelyhood sampling?
-. die ìƒ˜í”Œë§ì€ ì–´ë– í•´ì•¼ í•˜ëŠ”ê°€?
-. plane interleave ë¥¼ ì ê·¹ì ìœ¼ë¡œ í•˜ë ¤ë©´ ì–´ë–»ê²Œ í•´ì•¼ í•˜ëŠ”ê°€?
-. host ì™€ nand ì˜ ìš”ì²­ ë™ì‘ ì‚¬ì´ì˜ ìš°ì„  ìˆœìœ„ëŠ” ì–´ë–¤ ì‹ìœ¼ë¡œ ì„¤ì •, ë˜ëŠ” ì¡°ì •í•´ì•¼ í•˜ëŠ”ê°€?

## ğŸ¤– Assistant

NAND Operation Sequence Generation â€” êµ¬í˜„ ì§€í–¥ ì„¤ê³„ ë¦¬ë¼ì´íŠ¸ (v0.2)
1) ëª©ì ê³¼ ë²”ìœ„
- ëª©ì : ì´ ì„¤ê³„ëŠ” NAND ë™ì‘ ì‹œí€€ìŠ¤ë¥¼ íŒŒì´ì¬ ì½”ë“œë¡œ êµ¬í˜„í•˜ê¸° ìœ„í•œ ì‹¤ë¬´ ì§€ì¹¨ì´ë‹¤. êµ¬í˜„ì— í•„ìš”í•œ ë°ì´í„° ëª¨ë¸, ìŠ¤ì¼€ì¤„ë§ ë°©ì‹, ìš°ì„ ìˆœìœ„ ê·œì¹™, ì˜ì¡´ì„± ê²€ì‚¬, GC/Read-Reclaim ì •ì±…, ë¦¬ìŠ¤í¬ì™€ ì™„í™”ì±…ì„ ëª…ë£Œí•˜ê²Œ ì •ë¦¬í•œë‹¤.
- ë¹„ë²”ìœ„: ì‹¤ì œ ë¬¼ë¦¬ ì§€ì—° ìƒì„¸ì¹˜(ë² ë„ˆ, ì…€ íƒ€ì…ë³„ Î¼s/ns ë‹¨ìœ„ íŒŒë¼ë¯¸í„°)ëŠ” ì™¸ë¶€ í…Œì´ë¸”ë¡œ ë‘ê³ , ë³¸ ë¬¸ì„œëŠ” ì‹œë®¬ë ˆì´í„°ì˜ ë©”ì»¤ë‹ˆì¦˜ì— ì§‘ì¤‘í•œë‹¤.

2) ì‹œìŠ¤í…œ ê°œìš”
êµ¬ì„±ìš”ì†Œì™€ ì±…ì„:
- Scheduler: ì´ë²¤íŠ¸ ê¸°ë°˜(Discrete-Event)ìœ¼ë¡œ ë™ì‘ì„ ì˜ˆì•½/ì‹¤í–‰í•˜ì—¬ ê¸´ NAND ì‹œí€€ìŠ¤ë¥¼ ìƒì„±. BusyTable/History/Timer ê´€ë¦¬.
- AddressManager: ë¸”ë¡/í˜ì´ì§€ì˜ ìƒíƒœ ì¶”ì , pgm/read ê°€ëŠ¥í•œ ì£¼ì†Œ ì§ˆì˜ ì œê³µ, ì˜ˆì•½/ì»¤ë°‹/ë¡¤ë°± ì§€ì›.
- QueueManager: Host/NAND(ìœ ì§€ë³´ìˆ˜) ìš”ì²­ì„ í•œë° ëª¨ì•„ ìš°ì„ ìˆœìœ„ ì •ë ¬ ë° ë””ìŠ¤íŒ¨ì¹˜.
- HostReq â†’ OperSeq ë³€í™˜ê¸°: í˜¸ìŠ¤íŠ¸ ìš”ì²­ì„ ì‹¤ì œ Operation ì‹œí€€ìŠ¤(OperSeq) ë¡œ ë³€í™˜.
- StateSeq/Operation/OperSeq ë°ì´í„° ëª¨ë¸: ì‹œê°„ì¶•ê³¼ ìƒíƒœë¥¼ ì¼ê´€ë˜ê²Œ ê¸°ë¡/ê²€ì¦.

í•µì‹¬ ì›ì¹™
- ì´ë²¤íŠ¸ ì í”„í˜• ì‹œë®¬ë ˆì´ì…˜: step clockë¡œ 1í‹±ì”© ì „ì§„í•˜ì§€ ì•Šê³ , ë‹¤ìŒ ì´ë²¤íŠ¸ ì‹œê°ìœ¼ë¡œ ì‹œê°„ì„ ì í”„í•´ ì„±ëŠ¥/ì •í•©ì„±ì„ í™•ë³´.
- ì˜ˆì•½(Reservation) â†’ ì˜ì¡´ì„±/ìì›í™•ì •(Validation) â†’ ì»¤ë°‹(Commit) 3ë‹¨ê³„ í”„ë¡œí† ì½œë¡œ ê²½í•©/ë ˆì´ìŠ¤ ì™„í™”.
- ëª…ì‹œì  ìš°ì„ ìˆœìœ„: Host > Readê³„ì—´ > DOUT > Erase > Program(ì‹ ê·œ) > Program(íƒ€ê²Ÿ) ê¸°ë³¸ ì •ì±… + ê¸°ì•„ ë°©ì§€.

3) ë°ì´í„° ëª¨ë¸ (Python ìŠ¤ì¼ˆë ˆí†¤)

```python
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Tuple, Optional, Dict, Any
import heapq
from collections import deque

class AddrState(Enum):
    BAD_BLOCK = auto()     # ì‚¬ìš©ë¶ˆê°€
    INITIAL   = auto()     # ì´ˆê¸°í™” ì „(ë¯¸ì†Œê±°)
    ERASED    = auto()     # ì†Œê±° ì™„ë£Œ
    PGM_LAST  = auto()     # ë§ˆì§€ë§‰ í”„ë¡œê·¸ë¨ëœ page ì¸ë±ìŠ¤ ë³´ìœ 

@dataclass(frozen=True)
class Address:
    die: int
    plane: int
    block: int
    page: Optional[int] = None

class OpKind(Enum):
    READ = auto()
    DOUT = auto()
    PROGRAM = auto()
    ERASE = auto()
    SR = auto()            # status read
    RESET = auto()

@dataclass
class StateSeq:
    times: List[int]          # ìƒëŒ€/ì ˆëŒ€ ì‹œê° ë°°ì—´
    states: List[str]         # "idle/busy/dma/..." ë“± íƒœê·¸

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]             # ë‹¨ì¼ ë˜ëŠ” ì¸í„°ë¦¬ë¸Œ ëŒ€ìƒ
    timeline: StateSeq                 # ìƒëŒ€ì‹œê°„ ë‹¨ê³„ (issue->busy->dma...)
    movable: bool = True               # ì¬ë°°ì¹˜ í—ˆìš© ì—¬ë¶€(ì˜ì¡´ì„± ìˆëŠ” ë¬¶ìŒì€ False)
    meta: Dict[str, Any] = field(default_factory=dict)

@dataclass
class OperSeq:
    ops: List[Operation]

@dataclass
class HostReq:
    kind: OpKind
    size: int                           # ë…¼ë¦¬ì  í¬ê¸° / í˜ì´ì§€ ìˆ˜
    policy: Dict[str, Any] = field(default_factory=dict)  # QoS ë“±

@dataclass
class BusySlot:
    start: int
    end: int
    op: Operation

@dataclass
class PlaneState:
    available_at: int = 0               # ì´ í‰ë©´ì´ ë¹„ëŠ” ì‹œê°
    timeline: List[BusySlot] = field(default_factory=list)

```

4) Scheduler ì„¤ê³„
4.1 ì´ë²¤íŠ¸ ê¸°ë°˜ ë£¨í”„
- ì´ë²¤íŠ¸ í™(ìµœì†Œ í™): (event_time, event_type, payload) í˜•íƒœë¡œ ê´€ë¦¬.
- í˜„ì¬ ì‹œê° now ë¥¼ ë‹¤ìŒ ì´ë²¤íŠ¸ ì‹œê°ìœ¼ë¡œ ì í”„.
- Timer/History í•„ìš” ì‹œ Eventë¡œ ëª¨ë¸ë§:
  - OP_START, OP_END, QUEUE_REFILL, GC_TICK, READ_RECLAIM_TICK ë“±.

4.2 BusyTable/History/Timer
- BusyTable: die/plane ë‹¨ìœ„ë¡œ available_at + timeline(ë””ë²„ê¹…/ë¦¬í¬íŠ¸ìš©).
- HistoryList: ì£¼ê¸°ì ìœ¼ë¡œ Utilization/í ê¸¸ì´/ìš°ì„ ìˆœìœ„ë³„ ëŒ€ê¸°ì‹œê°„ì„ ìƒ˜í”Œë§.
- Timer: ê°œë³„ ê´€ë¦¬ ëŒ€ì‹  ì´ë²¤íŠ¸ ìŠ¤ì¼€ì¤„ë§ ì‹œê° ìì²´ê°€ íƒ€ì´ë¨¸ ì—­í• .

4.3 Operation ì¶”ê°€ ì ˆì°¨ (ì •ì œ)
1. QueueManager ì—ê²Œ ë‹¤ìŒ í• ë‹¹ ìš”ì²­
2. ì²« ìš”ì†Œ(ë˜ëŠ” ë£©ì–´í—¤ë“œ ì¬ë°°ì¹˜ ê²°ê³¼)ë¥¼ HostReqâ†’OperSeq ë³€í™˜
3. Reservation: AddressManagerì— ëŒ€ìƒ ì£¼ì†Œ ì ê¸ˆ/ì˜ˆì•½ (TTL í¬í•¨)
4. Validation:
  - ì˜ì¡´ì„±(eraseâ†’pgmâ†’read) ë° Plane Busy ì¶©ëŒ ê²€ì‚¬
  - ê°€ëŠ¥ ì‹œ ê° planeì˜ start = max(now, available_at) ê³„ì‚°
5. Commit & Schedule:
  - BusySlot í™•ì •, OP_START/OP_END ì´ë²¤íŠ¸ push
  - Address ìƒíƒœ ë³€í™”ëŠ” END ì‹œì ì— ì»¤ë°‹(ì¤‘ê°„ ì‹¤íŒ¨ ëŒ€ë¹„)
6. Completion:
  - OP_ENDì—ì„œ AddressManagerì— ìƒíƒœì»¤ë°‹, BusyTable/History ë°˜ì˜
  - í›„ì† ì˜ì¡´ Operationì´ ìˆë‹¤ë©´ ì¦‰ì‹œ Reservation ì‹œë„

ê¸°ì¡´ â€œuntil_timeâ€ì€ Operation.timelineì˜ ìƒëŒ€ì‹œê°„ í•©ìœ¼ë¡œë¶€í„° END ì ˆëŒ€ì‹œê°ì„ ê³„ì‚°í•˜ì—¬ ì´ë²¤íŠ¸ë¡œ ê´€ë¦¬í•œë‹¤.

5) AddressManager ì„¤ê³„
5.1 ìƒíƒœ í‘œí˜„
- ë¸”ë¡ ë‹¨ìœ„ ìƒíƒœ: BAD_BLOCK, INITIAL, ERASED, PGM_LAST(page_idx)
- Enum + êµ¬ì¡°ì²´ë¡œ ë§ˆì´ê·¸ë ˆì´ì…˜(ê¸°ì¡´ -3/-2/-1/0~pagesize-1 ìˆ«ìì¹˜ ì§€ì–‘)
- ì¡°íšŒ í•¨ìˆ˜:
  - get_addr_state(addr) -> AddrState or (PGM_LAST, page_idx)
  - get_pgmable() -> Iterable[Address(block-level)]
  - get_readable() -> Iterable[Address(page-level)]

5.2 ì˜ˆì•½/í™•ì •/ë¡¤ë°±
- reserve(addr, op_kind, until_time, token) -> bool
- commit(token) / rollback(token)
- ë™ì¼ ì£¼ì†Œì— ëŒ€í•œ ë™ì‹œ ì˜ˆì•½ ë°©ì§€ ë° TTL ë§Œë£Œ ì‹œ ìë™ ë¡¤ë°±.
- ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ê³¼ì˜ ê²½í•©ì„ í”¼í•˜ë ¤ë©´:
  - Host READ ëŒ€ìƒ ë¸”ë¡ì€ GCê°€ ì˜ˆì•½ ë¶ˆê°€(ë˜ëŠ” ìš°ì„ ìˆœìœ„ ë‚®ì¶¤)
  - GCëŠ” ëŒ€ì²´ ê°€ëŠ¥ ë¸”ë¡ë§Œ ëŒ€ìƒ(ìœ íš¨ë¹„íŠ¸/invalid ratio ê¸°ì¤€)

6) QueueManager ì„¤ê³„
6.1 í êµ¬ì¡°
- HostQueue (ë†’ì€ ìš°ì„ ìˆœìœ„), NandMaintQueue(GC/Read-Reclaim) (ë‚®ì€ ìš°ì„ ìˆœìœ„) ë¶„ë¦¬
- Unified View: peek(n) ì‹œ ë‘ íë¥¼ í•©ì³ ì •ì±…í•¨ìˆ˜ë¡œ ì •ë ¬

6.2 ìš°ì„ ìˆœìœ„ ì •ì±…(ê¸°ë³¸)
1. Host ìš”ì²­ ìš°ì„ 
2. Host ë‚´ë¶€: READ > DOUT > ERASE > PROGRAM(new) > PROGRAM(target)
3. ìœ ì§€ë³´ìˆ˜(NAND ìì²´): ì„ê³„ì¹˜ ê¸°ë°˜ ê°€ì¤‘
  - pgmable_ratio < low_watermark ì´ë©´ GC ì ìˆ˜â†‘
  - ì˜¤ë˜ëœ ë¸”ë¡ì˜ ì—ì´ì§•/FailBit ìœ„í—˜ ì‹œ Read-Reclaim ì ìˆ˜â†‘
4. ê¸°ì•„ ë°©ì§€: ëŒ€ê¸°ì‹œê°„ì— ë¹„ë¡€ ê°€ì¤‘ì¹˜ ì¶”ê°€(ì—ì´ì§•)

6.3 ì˜ì¡´ì„± ê²€ì‚¬
- í ì‚½ì… ì‹œ 1ì°¨ ê²€ì‚¬, ìŠ¤ì¼€ì¤„ ì§ì „ 2ì°¨ ê²€ì‚¬
- movable=False ì¸ ì—°ì† OperSeq ë¬¶ìŒì€ ì¬ë°°ì¹˜ ê¸ˆì§€
- ì¬ë°°ì¹˜ í•˜ë ¤ë©´ ì‚¬ì „ ì˜ì¡´ì„± ê·¸ë˜í”„ë¡œ ì‚¬ì´í´ ì—†ëŠ”ì§€ í™•ì¸

7) HostReq â†’ OperSeq ë³€í™˜
- READ: READ(+optional DOUT) / ì¸í„°ë¦¬ë¸Œ ê°€ëŠ¥í•œ ë‹¤ì¤‘ í˜ì¹˜
- PROGRAM: ëŒ€ìƒ ë¸”ë¡/í˜ì´ì§€ í• ë‹¹(ì—†ìœ¼ë©´ GC íŠ¸ë¦¬ê±° ë˜ëŠ” ì½ê¸°â†’ì‹ ê·œí• ë‹¹)
- ERASE: ë¸”ë¡ ë‹¨ìœ„
- ê²°ê³¼ëŠ” Operation ë¦¬ìŠ¤íŠ¸(OperSeq) ë¡œ ë°˜í™˜í•˜ë˜,
  - ì„œë¡œ ê°•í•˜ê²Œ ì˜ì¡´í•˜ëŠ” ë¬¶ìŒì€ movable=Falseë¡œ í”Œë˜ê·¸

8) ì¬ë°°ì¹˜(ë¦¬ë“œ ì „ì§„) & ì¸í„°ë¦¬ë¸Œ
- Look-ahead ìœˆë„(ì˜ˆ: ë‹¤ìŒ Kê°œ)ì—ì„œ READë¥¼ ì•ë‹¹ê²¨ plane ë³‘ë ¬ì„± ìµœëŒ€í™”
- ì¬ë°°ì¹˜ ì „í›„ì— AddressManagerë¡œ ìœ íš¨ì„±/ì˜ì¡´ì„± ì¬ê²€ì¦
- ì¸í„°ë¦¬ë¸ŒëŠ” (die, plane) ê°€ ë‹¤ë¥¸ íƒ€ê²Ÿì„ ë™ì¼ ì‹œê°ì— issueí•˜ì—¬ BUSY ì¤‘ì²© ìµœëŒ“í™”

9) GC & Read-Reclaim ì •ì±…
9.1 Garbage Collection
- ëª©ì  í•œì •: pgm ê°€ëŠ¥í•œ ë¸”ë¡ í™•ë³´
- íŠ¸ë¦¬ê±°: pgmable_ratio < LOW_WATERMARK ë˜ëŠ” ì£¼ê¸°ì  ì ê²€ ì´ë²¤íŠ¸
- ì‹œí€€ìŠ¤ ì˜ˆ: read -> dout -> program(new) -> ... ë°˜ë³µ í›„ erase
- ì˜µì…˜í™”: enable_gc: bool / ì •ì±… íŒŒë¼ë¯¸í„° êµ¬ì„±

9.2 Read-Reclaim
- ëª©ì : ì—ì´ì§•/FailBit ìœ„í—˜ ë¸”ë¡ì„ ì„ ì œ ë³µêµ¬/ì´ì „
- íŠ¸ë¦¬ê±°: ë¸”ë¡ â€˜ë‚˜ì´â€™, ì—ëŸ¬ í†µê³„, ì£¼ê¸°ì  ìŠ¤ìº”
- ì˜µì…˜í™”: enable_read_reclaim: bool

10) êµ¬í˜„ ì ˆì°¨(ì´ë²¤íŠ¸ ë¼ì´í”„ì‚¬ì´í´)

```
[Scheduler.tick()]
  â”œâ”€ now = pop(next_event_time)
  â”œâ”€ process(event)
  â”œâ”€ if QUEUE_REFILL or idle:
  â”‚    â”œâ”€ req = QueueManager.peek_and_select()
  â”‚    â”œâ”€ operseq = Req2Seq(req)
  â”‚    â”œâ”€ for op in operseq:
  â”‚    â”‚    â”œâ”€ AddressManager.reserve(...)
  â”‚    â”‚    â”œâ”€ Dependency/Busy validation
  â”‚    â”‚    â””â”€ schedule OP_START/OP_END (commit at END)
  â””â”€ push next QUEUE_REFILL / GC_TICK / RECLAIM_TICK as needed

```

11) êµ¬ì„±/íŒŒë¼ë¯¸í„°(ì˜ˆì‹œ ê¸°ë³¸ê°’)
- LOOKAHEAD_K = 8 (ì¬ë°°ì¹˜ ëŒ€ìƒ)
- LOW_WATERMARK_PGMABLE = 0.05, HIGH_WATERMARK_PGMABLE = 0.12
- AGEING_WEIGHT_ALPHA = 0.01 (ëŒ€ê¸°ì‹œê°„ ê°€ì¤‘)
- RESERVATION_TTL = operation_duration * 1.5
- MAX_QUEUE_SIZE = 10_000 (í˜¸ìŠ¤íŠ¸ í­ì£¼ ì–µì œ)

12) ê´€ì¸¡/ë¡œê¹…
- ë©”íŠ¸ë¦­: í ê¸¸ì´, ìš°ì„ ìˆœìœ„ë³„ ëŒ€ê¸°ì‹œê°„, plane utilization, GC ë¹ˆë„, ì¬ë°°ì¹˜ ì„±ê³µë¥ , ë¡¤ë°± íšŸìˆ˜
- íŠ¸ë ˆì´ìŠ¤: Operation ë‹¨ìœ„ ì˜ˆì•½â†’ì»¤ë°‹â†’ì™„ë£Œ íƒ€ì„ë¼ì¸
- ìŠ¤ëƒ…ìƒ·: AddressState ì••ì¶• ìŠ¤ëƒ…ìƒ·(ì£¼ê¸°/ì‚¬ê±´ ê¸°ë°˜)

13) ë¦¬ìŠ¤í¬ & ì™„í™”ì±…

| ë¦¬ìŠ¤í¬ | ì„¤ëª… | ì™„í™”ì±… |
| --- | --- | --- |
| ìš°ì„ ìˆœìœ„ ì—­ì „ | Host READê°€ GCì— ë§‰í˜ | Reservationì—ì„œ Host ëŒ€ìƒ ë¸”ë¡ì€ GC ì˜ˆì•½ ë¶ˆê°€. ì—ì´ì§• ê°€ì¤‘ì¹˜ë¡œ Host ë¨¼ì € í†µê³¼ |
| ì£¼ì†Œ ì •í•©ì„± ë¶•ê´´ | GCê°€ ë¨¼ì € ERASE ìƒíƒœë¡œ ë°”ê¾¸ì–´ Host READ invalid | ì»¤ë°‹ ì§€ì—°(ENDì—ì„œë§Œ AddressState ë³€ê²½), Host ì˜ˆì•½ì‹œ ê°•í•œ ë½ |
| ì˜ì¡´ì„± ê¹¨ì§(ì¬ë°°ì¹˜) | ì½ê¸° ìˆœì„œ ë‹¹ê¹€ í›„ ì¢…ì†ì„± ìœ„ë°˜ | movable=False ë¬¶ìŒ, ì¬ë°°ì¹˜ ì „í›„ ë”ë¸”ì²´í¬ |
| ìŠ¤íƒ€ë² ì´ì…˜ | ìœ ì§€ë³´ìˆ˜ ì˜ì›íˆ ëª» ëŒë¦¼ | Low watermark í•˜íšŒ ì‹œ ìœ ì§€ë³´ìˆ˜ì— ë³´ë„ˆìŠ¤ ì ìˆ˜, ì£¼ê¸°ì  ê°•ì œ ìŠ¬ë¡¯ |
| ì´ë²¤íŠ¸ ë“œë¦¬í”„íŠ¸ | step clockì™€ íŒ¨í„´ ë¯¸ìŠ¤ | ì´ë²¤íŠ¸ ì í”„ ëª¨ë¸ ì±„íƒ, ìƒëŒ€ì‹œê°„â†’ì ˆëŒ€ì‹œê°„ ë³€í™˜ ì¼ì›í™” |
| ë™ì‹œ ì˜ˆì•½ ì¶©ëŒ | ì—¬ëŸ¬ ìŠ¤ë ˆë“œ/ëª¨ë“ˆì´ ë™ì¼ ì£¼ì†Œ ì˜ˆì•½ | AddressManager í† í° ê¸°ë°˜ ì˜ˆì•½, TTLê³¼ ë¡¤ë°± |
| ë©”ëª¨ë¦¬ íŒ½ì°½ | History/Timeline ëˆ„ì  | ë¡¤ë§ ìœˆë„ìš° ìœ ì§€, ìŠ¤ëƒ…ìƒ· ì••ì¶• ì €ì¥ |
| ì„±ëŠ¥ ë³‘ëª© | 10ë§Œ+ ì „ì´ í…Œì´ë¸” | ì´ë²¤íŠ¸ í™, O(log N) ìŠ¤ì¼€ì¤„, ì¬ë°°ì¹˜ ìœˆë„ ì œí•œ |

14) í…ŒìŠ¤íŠ¸ ì „ëµ(í•„ìˆ˜ ì‹œë‚˜ë¦¬ì˜¤)
- ë‹¨ìœ„: Address ìƒíƒœ ì „ì´(ERASEâ†’PGMâ†’READ), ì˜ˆì•½/ì»¤ë°‹/ë¡¤ë°±, ì˜ì¡´ì„± ê²€ì‚¬
- í†µí•©: Host í­ì£¼ + GC ë™ì‹œ ë™ì‘, ì¬ë°°ì¹˜ ìœ íš¨ì„±, ì¸í„°ë¦¬ë¸Œ íš¨ìœ¨ì„±
- ë¶€í•˜: ìˆ˜ì‹­ë§Œ ì´ë²¤íŠ¸ ì²˜ë¦¬ ì‹œê°„, ë©”ëª¨ë¦¬ ìƒí•œ
- íšŒê·€: ë™ì¼ Seed ì¬í˜„ì„±(ë‚œìˆ˜ ì‹œë“œ ê³ ì •)

15) íŒŒì¼ êµ¬ì¡° ì œì•ˆ

```
nandsim/
  core/
    scheduler.py
    queue_manager.py
    address_manager.py
    models.py
    req2seq.py
  policy/
    priority.py
    gc.py
    reclaim.py
  sim/
    runner.py           # main loop + config
  tests/
    test_address.py
    test_depcheck.py
    test_scheduler.py
    test_gc_reclaim.py

```

16) ì˜ì‚¬ì½”ë“œ ìŠ¤ë‹ˆí«
16.1 ìŠ¤ì¼€ì¤„ëŸ¬ í•µì‹¬

```python
class Scheduler:
    def __init__(self, qm, am, config):
        self.now = 0
        self.events = []  # heap
        self.qm = qm
        self.am = am
        self.config = config
        heapq.heappush(self.events, (0, "QUEUE_REFILL", None))

    def run_until(self, t_end):
        while self.events and self.events[0][0] <= t_end:
            self.now, ev, payload = heapq.heappop(self.events)
            self._handle(ev, payload)

    def _handle(self, ev, payload):
        if ev == "QUEUE_REFILL":
            self._dispatch()
            heapq.heappush(self.events, (self.now+ self.config.queue_refill_period, "QUEUE_REFILL", None))
        elif ev == "OP_START":
            pass
        elif ev == "OP_END":
            op, token = payload
            self.am.commit(token)
            # history/busy update...

    def _dispatch(self):
        req = self.qm.peek_and_select(self.now)
        if not req: return
        operseq = req2seq(req, self.am, self.config)
        for op in operseq.ops:
            token = self.am.reserve_targets(op.targets, op.kind, ttl=self._estimate_ttl(op))
            if not token:
                # could push back or trigger GC
                continue
            start, end = self._fit_to_planes(op)
            heapq.heappush(self.events, (start, "OP_START", op))
            heapq.heappush(self.events, (end,   "OP_END",   (op, token)))

```

17) â€œSelf-thoughtsâ€ í•­ëª© ë°˜ì˜(ì •ì±…í™”)
- ì–¸ì œ req_queueë¥¼ ë³¼ê¹Œ?
  - QUEUE_REFILL ì£¼ê¸° + idle ì‹œ ì¦‰ì‹œ í™•ì¸. ì£¼ê¸°ëŠ” ì§§ê²Œ(ì˜ˆ: 1~5Î¼s ê°€ìƒì‹œê°„), ê³¼ë„ í˜¸ì¶œ ë°©ì§€.
- ìƒ˜í”Œë§ì€ ì–´ë””ì„œ?
  - Schedulerê°€ íŠ¸ë¦¬ê±°ë¥¼ ê²°ì •í•˜ê³ , HostReq/GC/Read-Reclaim ìƒì„±ì€ ê° ì†ŒìŠ¤ ëª¨ë“ˆì´ ìˆ˜í–‰. ìŠ¤ì¼€ì¤„ëŸ¬ëŠ” ë‹¤ë§Œ ìš°ì„ ìˆœìœ„+ì˜ì¡´ì„± ê¸°ì¤€ìœ¼ë¡œ ì±„íƒ.
- Host í­ì£¼ ì œì–´
  - MAX_QUEUE_SIZE ì´ˆê³¼ ì‹œ ì‹ ê·œ HostReq ë°±í”„ë ˆì…”(ê±°ì ˆ/ì§€ì—°), ë˜ëŠ” ì €ìš°ì„  ìœ ì§€ë³´ìˆ˜ ìŠ¬ë¡¯ ë³´ì¥.
- Host/NAND ìš°ì„ ìˆœìœ„ êµ¬ë¶„ ë°ì´í„°
  - Operation.meta["source"] in {"host","gc","reclaim"}
- Program ê°€ëŠ¥ ë¸”ë¡ ë¶€ì¡± ì‹œ ì²˜ë¦¬
  - ì¦‰ì‹œ GC ì ìˆ˜ ìƒìŠ¹ â†’ GC OperSeq ì£¼ì… â†’ READ/DOUTì„ í†µí•œ ì‹ ê·œ ë¸”ë¡ í• ë‹¹ ê²½ë¡œ í—ˆìš©, ë‹¨ Host READëŠ” í•­ìƒ ì„ í–‰.
- ì¦‰ì‹œ ê°€ëŠ¥í•œ ë™ì‘(SR/RESET)
  - ê°™ì€ plane ë¹„ì ìœ  êµ¬ê°„ì´ë©´ nowì— ë°”ë¡œ ìŠ¤ì¼€ì¤„. ì•„ë‹ˆë©´ available_atì— ë§ì¶° ì´ë²¤íŠ¸ ë“±ë¡.
- ì˜ˆì•½ì€ planeë‹¹ 1ê°œ ê·œì¹™
  - â€œë¯¸ë˜ ì˜ˆì•½ 1ê°œâ€ë¥¼ ê¸°ë³¸ìœ¼ë¡œ í•˜ë˜, same-plane ë³‘ëª©ì´ ì‹¬í•˜ë©´ â€˜ì—°ì† ìŠ¬ë¡¯ ì˜ˆì•½â€™ ì˜µì…˜ ê³ ë ¤.
- READ ì¬ë°°ì¹˜ë¡œ ë ˆì´í„´ì‹œ ìµœì í™”
  - Look-ahead ìœˆë„ ë‚´ movable READë“¤ì„ plane ë¶„ì‚°ë˜ê²Œ ì „ì§„ ë°°ì¹˜ í›„ ë”ë¸”ì²´í¬.
- Validity ì²´í¬ ì‹œì  ë¬¸ì œ
  - ì¬ë°°ì¹˜ ì „/í›„ ë‘ ë²ˆ AddressManagerì— ì§ˆì˜. ìƒíƒœê°€ ë°”ë€Œë©´ ì¬ë°°ì¹˜ ì·¨ì†Œ. ìŠ¤ëƒ…ìƒ·(Epoch) ë¹„êµë¡œ ì‹œì  ì¼ê´€ì„± ë³´ì¥.

18) ê²°ì •ì‚¬í•­ ìš”ì•½
- ì´ë²¤íŠ¸ ì í”„í˜• ìŠ¤ì¼€ì¤„ëŸ¬ ì±„íƒ(â€œstep clockâ€ ë¯¸ì‚¬ìš©)
- AddressManager ìƒíƒœëŠ” Enum/êµ¬ì¡°í™”, ì˜ˆì•½-ì»¤ë°‹-ë¡¤ë°± í”„ë¡œí† ì½œ ë„ì…
- ìš°ì„ ìˆœìœ„ ê·œì¹™ ëª…ì‹œ + ê¸°ì•„ ë°©ì§€
- GC ëª©ì  í•œì •(í”„ë¡œê·¸ë˜ë¨¸ë¸” ë¸”ë¡ ìƒì„±), low-watermark ê¸°ë°˜ ìë™ ì‚½ì…
- READ ì¬ë°°ì¹˜/ì¸í„°ë¦¬ë¸ŒëŠ” movable í”Œë˜ê·¸ì™€ ì´ì¤‘ ê²€ì¦ í•˜ì—ì„œë§Œ

19) ë¯¸í•´ê²° ì´ìŠˆ & ê¶Œê³  ê¸°ë³¸ê°’ (Critical Questions)
1. Clock ìŠ¤í…?
  - ê¶Œê³ : ì´ë²¤íŠ¸ ì í”„í˜•(Discrete-Event). ìƒëŒ€íƒ€ì„ë¼ì¸ì„ ì ˆëŒ€ì‹œê°„ìœ¼ë¡œ ë³€í™˜í•´ OP_END ê¸°ì¤€ìœ¼ë¡œ ì»¤ë°‹.
2. Die/Plane ìƒ˜í”Œë§?
  - ê¶Œê³ : ìµœì†Œ ì¢…ë£Œì‹œê°„ ìš°ì„ (earliest available plane) + ê· í˜• ë¼ìš´ë“œë¡œë¹ˆ. ëŒ€ê·œëª¨ ì‹œì—” íˆìŠ¤í† ë¦¬ ê¸°ë°˜ ë¶€í•˜ê· í˜•.
3. Plane ì¸í„°ë¦¬ë¸Œ ê·¹ëŒ€í™”?
  - ê¶Œê³ : Look-ahead ì¬ë°°ì¹˜ë¡œ READë¥¼ ì„ í–‰ ë°°ì¹˜, movable=False ë¬¶ìŒì€ ì œì™¸.
4. Host vs NAND ìœ ì§€ë³´ìˆ˜ ìš°ì„ ìˆœìœ„ ì¡°ì •?
  - ê¶Œê³ : Host ì ˆëŒ€ìš°ì„  + Low watermark í•˜íšŒ ì‹œ ìœ ì§€ë³´ìˆ˜ì— ë³´ë„ˆìŠ¤ ê°€ì¤‘. ì¥ê¸°ì ìœ¼ë¡œëŠ” SLA ê¸°ë°˜ ì •ì±… í•¨ìˆ˜ ì£¼ì… ê°€ëŠ¥í•˜ê²Œ ì„¤ê³„.

20) ë‹¤ìŒ ë‹¨ê³„(ë°”ë¡œ ì½”ë“œë¡œ ì´ì–´ê°€ê¸°)
1. models.pyì˜ Enum/Dataclass í™•ì •(ìˆ«ì ìƒíƒœ ì œê±°)
2. address_manager.pyì— reserve/commit/rollback 1ì°¨ êµ¬í˜„ + ë‹¨ìœ„í…ŒìŠ¤íŠ¸
3. priority.pyì— ìš°ì„ ìˆœìœ„ í•¨ìˆ˜/ì—ì´ì§• ê°€ì¤‘ êµ¬í˜„
4. scheduler.pyì— ì´ë²¤íŠ¸ ë£¨í”„/í™/BusyTable ì ìš©
5. req2seq.pyì— Host READ/PGM/ERASE ê¸°ë³¸ ë³€í™˜ê¸°
6. ì†Œê·œëª¨ ì‹œë‚˜ë¦¬ì˜¤(ë‹¨ì¼ die/plane)ë¡œ íšŒê·€í…ŒìŠ¤íŠ¸ í…œí”Œë¦¿ ì‘ì„± â†’ ì ì§„ í™•ì¥

í•„ìš”í•˜ë©´ ìœ„ ìŠ¤ì¼ˆë ˆí†¤ì„ ë°”ë¡œ ì‘ë™ ê°€ëŠ¥í•œ ìµœì†Œ ì‹¤í–‰ ì½”ë“œë¡œ ì´ì–´ ë¶™ì—¬ ë“œë¦´ê²Œìš”. êµ¬í˜„í•˜ë©´ì„œ ë§‰íˆëŠ” ì§€ì (ì˜ˆ: ì˜ˆì•½ í† í° êµ¬ì¡°, ì¬ë°°ì¹˜ ì•Œê³ ë¦¬ì¦˜ ì„¸ë¶€) ë‚˜ì˜¤ë©´ í•´ë‹¹ ë¶€ë¶„ë§Œ ë–¼ì„œ êµ¬ì²´ ì½”ë“œë¡œ íŒŒê³ ë“¤ì–´ê°€ìê³ ìš”.

## ğŸ‘¤ User

ì œì•ˆí•œ ì‹œìŠ¤í…œì—ì„œ ê´€ì ì„ ì¢€ ì¶”ê°€í• ê±°ì•¼.
-. ì„¤ê³„í•˜ë ¤ëŠ” ì‹œìŠ¤í…œì€ nand operation sequence ìƒì„±ì´ ëª©ì ì´ë©°, edge case ë¥¼ í¬í•¨í•œ use case sequence ìƒì„±ì„ í•˜ëŠ” ê²ƒì´ë‹¤.
-. erase/pgm/read ë¿ ì•„ë‹ˆë¼ ë‹¤ì–‘í•œ operation ì„ ë‚˜ì˜¤ê²Œ í•˜ê¸° ìœ„í•´ operation ì˜ í™•ë¥  ë¶„í¬ë¥¼ tuning í•´ì„œ ìƒì„±í•  ìˆ˜ ìˆì–´ì•¼ í•œë‹¤. ì´ ë•Œ operation ì˜ í™•ë¥  ë¶„í¬ëŠ” nand ìƒíƒœì— ë”°ë¼ ë‹¬ë¼ì§€ëŠ” í™•ë¥  ë¶„í¬ì´ë‹¤. nand ìƒíƒœëŠ” operation ì´ ìˆ˜í–‰ë ë•Œë§ˆë‹¤ ë™ì ìœ¼ë¡œ ë°”ë€ë‹¤.
-. íŠ¹ì • operation ì€ í•­ìƒ ìŒìœ¼ë¡œ interval ì„ ë‘ê³  ë“±ì¥í•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´, read ì™€ dout.
-. ìœ„ ê´€ì ì—ì„œ ë‹¤ì–‘í•œ timing ì—ì„œì˜ nand operation ì´ ì¶”ê°€ë¼ì•¼ í•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´, operation busy ì˜ start, midle, end ì§€ì  ë¶€ê·¼ì— operation ì´ ìˆ˜í–‰ë˜ì–´ì•¼ í•œë‹¤. ì¶”í›„ì— ì´ timing ì— ëŒ€í•œ í™•ë¥  ë¶„í¬ë¥¼ ì¡°ì •í•´ì„œ tuning ëœ í™•ë¥  ë¶„í¬ë¥¼ ê°€ì§€ê³  ìƒì„±ì„ í•  ê²ƒì´ë‹¤. operation busy ê¸°ì¤€ ìƒ˜í”Œë§ ì‹œ die, plane ë³„ë¡œ ì„œë¡œ ë‹¤ë¥¸ phase ê°€ ìˆì„ ìˆ˜ ìˆë‹¤.

ì´ëŸ° ê´€ì ì—ì„œ í‰ê°€í•  ìš”ì†ŒëŠ” ë‹¤ìŒê³¼ ê°™ì•„.
-. host <-> nand ê°„ ìš°ì„  ìˆœìœ„ ì¡°ì • ë©”ì»¤ë‹ˆì¦˜ì˜ ë³µì¡ì„±ì´ í™•ë¥  ë¶„í¬ tuning ê³¼ ê³µì¡´í•  ìˆ˜ ìˆëŠ”ì§€? ê·¸ë ‡ë‹¤ë©´ ê·¸ì— ë”°ë¥¸ êµ¬í˜„ ë‚œì´ë„, risk ëŠ” ë¬´ì—‡ì¸ì§€?
-. host <-> nand ê°€ ë³„ê°œì˜ ì£¼ì²´ë¡œ ìš”ì²­ì„ í•˜ì§€ ì•ŠëŠ”ë‹¤ë©´, ì–´ëŠ ìª½ì„ ê¸°ì¤€ìœ¼ë¡œsystem ì„ ì„¤ê³„í•´ì•¼ í•˜ëŠ”ì§€?

í‰ê°€ë¥¼ ì§„í–‰í•´ì¤˜.

## ğŸ¤– Assistant

ì¢‹ì•„, â€œí™•ë¥  ë¶„í¬ë¡œ ë™ì‘ì„ ìƒì„±í•˜ëŠ” ì‹œí€€ìŠ¤ ì œë„ˆë ˆì´í„°â€ ê´€ì ê¹Œì§€ ë„£ì–´ì„œ ì„¤ê³„ë¥¼ í‰ê°€í•˜ê³  ê°œì„ ì•ˆì„ ì œì‹œí• ê²Œ. í•µì‹¬ì€ **ìš°ì„ ìˆœìœ„/ì˜ì¡´ì„± ê·œì¹™(í˜„ì‹¤ì„±)**ê³¼ **í™•ë¥  ë¶„í¬ íŠœë‹(ì œì–´ì„±)**ì„ ì¶©ëŒ ì—†ì´ ê³µì¡´ì‹œí‚¤ëŠ” êµ¬ì¡°ë¥¼ ê°–ì¶”ëŠ” ê±°ì•¼.
1) ê²°ë¡  ë¨¼ì € â€” ì–´ë–¤ êµ¬ì¡°ê°€ ì¢‹ì€ê°€?
- ê¶Œì¥ ì•„í‚¤í…ì²˜: â€œë‹¨ì¼ í™•ë¥  ì •ì±… ì—”ì§„(SPE, Stochastic Policy Engine) + ì´ë²¤íŠ¸ ìŠ¤ì¼€ì¤„ëŸ¬â€
  - Hostì™€ NAND(GC/Read-Reclaim ë“±)ë¥¼ ë³„ë„ í”„ë¡œë“€ì„œë¡œ ë‘ì§€ ë§ê³ , í•˜ë‚˜ì˜ ì •ì±… ì—”ì§„ì—ì„œ â€œíŠ¸ë˜í”½ í´ë˜ìŠ¤(host, gc, reclaim, diagâ€¦)â€ë¥¼ í˜¼í•© ë¹„ìœ¨ë¡œ ìƒ˜í”Œë§.
  - ê° Operationì˜ ë°œìƒ í™•ë¥ ì€ Ï€(op | ì „ì—­ìƒíƒœ S_t, ë¡œì»¬ìƒíƒœ L_{die,plane}, phase)ë¡œ ëª¨ë¸ë§(ìƒíƒœ-ì˜ì¡´ í™•ë¥ ).
  - **ìŒ ì—°ì‚°(READâ†”DOUT)**ì€ â€œì˜ë¬´(Obligation)â€ ê°ì²´ë¡œ ê°•ì œ(â€œAê°€ ë‚˜ì˜¤ë©´ Bê°€ Î”t ë¶„í¬ ë‚´ ë°˜ë“œì‹œ ë“±ì¥â€).
  - íƒ€ì´ë° ì£¼ì…ì€ ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ë§Œë“¤ì–´ì£¼ëŠ” **phase hook ì´ë²¤íŠ¸(STARTÂ±Îµ, MIDÂ±Îµ, ENDÂ±Îµ)**ì—ì„œ SPEë¥¼ í˜¸ì¶œí•´ ìƒ˜í”Œë§.
  - ìŠ¤ì¼€ì¤„ëŸ¬ëŠ” ì—¬ì „íˆ ìš°ì„ ìˆœìœ„/ì˜ì¡´ì„±ìœ¼ë¡œ ì¶©ëŒì„ í•´ì†Œí•˜ë˜, SPEê°€ ì‚¬ì „ ê°€ìš©ì„± ì²´í¬ë¥¼ í•´ ê±°ì ˆ/ì¬ìƒ˜í”Œë§ì„ ì¤„ì„.

ì´ êµ¬ì¡°ë©´ â€œìš°ì„ ìˆœìœ„ ë©”ì»¤ë‹ˆì¦˜â€ê³¼ â€œí™•ë¥  íŠœë‹â€ì´ ì„œë¡œ ë°œì„ ë°Ÿì§€ ì•Šê³  ê°™ì´ êµ´ëŸ¬ê°€ë©°, êµ¬í˜„ë„ ê°€ì¥ ê¹”ë”í•˜ê²Œ ë‚˜ëˆ ì ¸.

2) Hostâ†”NAND ìš°ì„ ìˆœìœ„ì™€ í™•ë¥  íŠœë‹ì˜ ê³µì¡´ì„± í‰ê°€
ê³µì¡´ ê°€ëŠ¥? â†’ ì˜ˆ
- ë¶„ë¦¬ ì›ì¹™: â€œë¬´ì—‡ì„ â€˜ì‹œë„â€™í• ì§€â€ëŠ” SPEê°€, â€œë¬´ì—‡ì„ â€˜ì‹¤í–‰â€™í• ì§€â€ëŠ” ìŠ¤ì¼€ì¤„ëŸ¬ê°€.
  - SPE: ìƒíƒœ-ì˜ì¡´ í™•ë¥ ë¡œ í›„ë³´ë‹¤ë°œ ìƒì„±(ì‹œë„). ìŒ/ì˜ì¡´ì„±/íƒ€ì´ë° ì œì•½ì„ ë°˜ì˜í•´ ìœ íš¨ í›„ë³´ë§Œ ë‚´ë†“ìŒ.
  - Scheduler: Host > READ > â€¦ ìš°ì„ ìˆœìœ„, plane busy, ì˜ì¡´ì„± ê·¸ë˜í”„ë¥¼ ìµœì¢… í•´ì„(ì‹¤í–‰).
- ë¶„í¬ ë³´ì¡´: ì‹¤í–‰ ê±°ì ˆÂ·ì§€ì—°ì´ ì¦ìœ¼ë©´ ë¶„í¬ê°€ í‹€ì–´ì§€ë¯€ë¡œ, SPEê°€ ê°€ìš©ì„±/ì˜ì¡´ì„± ì‚¬ì „ê²€ì‚¬(light) í›„ ë‚´ë†“ì•„ ë¦¬ì ì…˜ìœ¨â†“.
- í”¼ë“œë°± ë£¨í”„: ì‹¤í–‰ ê²°ê³¼(accepted/denied, ëŒ€ê¸°ì‹œê°„)ë¥¼ SPEì— í”¼ë“œë°±í•´ í˜¼í•©ë¹„ìœ¨Â·íƒ€ì´ë° ê°€ì¤‘ì„ ë¯¸ì„¸ì¡°ì •(íŠœë‹ ë£¨í”„).

êµ¬í˜„ ë‚œì´ë„ & ë¦¬ìŠ¤í¬
- ë‚œì´ë„(ì¤‘~ìƒ):
  - SPEì— ìƒíƒœ-ì˜ì¡´ í™•ë¥ í‘œ(ë˜ëŠ” ê°„ë‹¨í•œ íŒŒë¼ë©”íŠ¸ë¦­ í•¨ìˆ˜) + ìŒ ì—°ì‚° ì˜ë¬´ ê´€ë¦¬(Obligation Manager) + phase hook í˜¸ì¶œì´ í•„ìš”.
  - ìŠ¤ì¼€ì¤„ëŸ¬ëŠ” ê¸°ì¡´ ì„¤ê³„(ì´ë²¤íŠ¸ ì í”„, ìš°ì„ ìˆœìœ„/ì˜ì¡´ì„±) ì¬ì‚¬ìš©.
- ì£¼ìš” ë¦¬ìŠ¤í¬ì™€ ì™„í™”
  1. ë¶„í¬ ë“œë¦¬í”„íŠ¸(ìš°ì„ ìˆœìœ„/ìì› ë¶€ì¡±ìœ¼ë¡œ ì˜ë„í•œ ë¶„í¬ì™€ ì‹¤í–‰ ë¶„í¬ê°€ ì–´ê¸‹ë‚¨)

â†’ SPEì— ê°€ìš©ì„± ê¸°ë°˜ ë³´ì •(plane_free_ratio, pgmable_ratio) + ì‹¤í–‰/ê±°ì ˆ í†µê³„ë¡œ í˜¼í•©ë¹„ìœ¨ ì—…ë°ì´íŠ¸.
  2. ì˜ë¬´ ë¯¸ì¶©ì¡±(READ ë°œìƒí–ˆëŠ”ë° DOUT ê¸°í•œ ë¯¸ë„ë‹¬)

â†’ Obligationì— ë°ë“œë¼ì¸ ë¶„í¬ì™€ ë³´í˜¸ ìš°ì„ ìˆœìœ„ ë¶€ìŠ¤íŒ…(ë§ˆê° ì„ë°• ì‹œ ì ìˆ˜â†‘).
  3. ìƒíƒœ-ì˜ì¡´ í™•ë¥ í‘œ í­ë°œ(ì¡°í•© ë§ì•„ì§)

â†’ ì „ì—­ìƒíƒœ S_t, ë¡œì»¬ L_{die,plane}ë¥¼ ë²„í‚·íŒ…(low/med/high)í•´ ì¡°ê°ë‚œ í…Œì´ë¸”ë¡œ ê´€ë¦¬ + YAMLë¡œ ì™¸ë¶€í™”.
  4. í˜ì´ì¦ˆ ì£¼ì…-ì˜ì¡´ì„± ì¶©ëŒ

â†’ phase hookì—ì„œ ìƒ˜í”Œ ì „ ì˜ì¡´ì„± ì‚¬ì „ê²€ì‚¬(AddressManager, dependency rules) â†’ ë¶ˆê°€ ì‹œ ë‹¤ë¥¸ í›„ë³´ë¡œ ì¬ìƒ˜í”Œ.

3) â€œHostì™€ NANDë¥¼ ë³„ê°œ ì£¼ì²´ë¡œ ë‘ì§€ ì•ŠëŠ”ë‹¤ë©´?â€ ê¸°ì¤€ì„  ì„ íƒ

| ê¸°ì¤€ ì„¤ê³„ | ì¥ì  | ë‹¨ì  | ì¶”ì²œë„ |
| --- | --- | --- | --- |
| Host-ì¤‘ì‹¬(NAND ìœ ì§€ë³´ìˆ˜ëŠ” Host íŠ¸ë˜í”½ì˜ ë¶€ì‚°ë¬¼) | í˜„ì‹¤ì˜ I/O ì›Œí¬ë¡œë“œ ë‹®ìŒ | GC/ì§„ë‹¨/ì—£ì§€ì¼€ì´ìŠ¤ ì£¼ì… ì œì–´ê°€ ì•½í•¨ | â–³ |
| NAND-ì¤‘ì‹¬(ìœ ì§€ë³´ìˆ˜/ë‚´ë¶€ì •ì±…ì´ 1ê¸‰, HostëŠ” í´ë˜ìŠ¤ ì¤‘ í•˜ë‚˜) | GC/ì—£ì§€ì¼€ì´ìŠ¤ ì£¼ë„ê¶Œâ†‘, ë‚´ë¶€ íƒ€ì´ë° ì£¼ì… ì‰¬ì›€ | ì›Œí¬ë¡œë“œ í˜„ì‹¤ê°ì€ ì¡°ì • í•„ìš” | â— |
| ë‹¨ì¼ ì •ì±… ì—”ì§„(í˜¼í•© í´ë˜ìŠ¤) | íŠœë‹Â·ê´€ì¸¡ ì¼ì›í™”, í˜„ì‹¤ê°â†”ì—£ì§€ì¼€ì´ìŠ¤ ê· í˜• | SPE êµ¬í˜„ í•„ìš”(ì¤‘ë‚œì´ë„) | ìµœê³  |

ë³¸ ëª©ì ì´ â€œì—£ì§€ì¼€ì´ìŠ¤ í¬í•¨ ì‹œí€€ìŠ¤ ìƒì„±â€ì´ë¯€ë¡œ, ë‹¨ì¼ ì •ì±… ì—”ì§„ìœ¼ë¡œ ê°€ê³  HostëŠ” í•œ í´ë˜ìŠ¤ë¡œ ì·¨ê¸‰í•˜ê¸°ë¥¼ ê¶Œì¥.

4) êµ¬ì²´ ì„¤ê³„ í¬ì¸íŠ¸
4.1 ìƒíƒœ-ì˜ì¡´ í™•ë¥ (ì˜ˆì‹œ)
- ì „ì—­: pgmable_ratio âˆˆ {low, mid, high}, readable_ratio, íê¸¸ì´, wear_level ë“±
- ë¡œì»¬: plane_busy_frac, die_age ë“±
- í˜ì´ì¦ˆ: {pre-start, near-start, mid, near-end, post}
- ì •ì±…:
- ì „ë¶€ YAML íŒŒë¼ë¯¸í„°í™” â†’ ì˜¤í”„ë¼ì¸ íŠœë‹ ìš©ì´

4.2 ìŒ ì—°ì‚° ì˜ë¬´(READâ†”DOUT ë“±)
- Obligation: {need: DOUT, issuer: READ, window: Î”t ~ Dist, targets, priority_boost(t)}
- READê°€ ì»¤ë°‹ë˜ë©´ Obligation ìƒì„± â†’ phase hook/queue refill ì‹œ ìš°ì„  ìƒ˜í”Œ ëŒ€ìƒì— í¬í•¨
- ë§ˆê° ì„ë°• ì‹œ priority_boostâ†‘ ë˜ëŠ” ê°•ì œ ì‚½ì… ìŠ¬ë¡¯ ë¶€ì—¬

4.3 íƒ€ì´ë°/í˜ì´ì¦ˆ ì£¼ì…
- ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ê° BUSYì— ëŒ€í•´ hook ì´ë²¤íŠ¸ ë°œí–‰:
  - t_startÂ±Îµ, t_midÂ±Îµ, t_endÂ±Îµ(die/planeë³„ ìƒì´í•œ ìœ„ìƒ í—ˆìš©)
- hook ì²˜ë¦¬ ì‹œ SPE í˜¸ì¶œ â†’ í›„ë³´ ìƒ˜í”Œ â†’ ì‚¬ì „ê²€ì‚¬ â†’ ìŠ¤ì¼€ì¤„ëŸ¬ì— ì œì¶œ
- ë¶„í¬ íŠœë‹: g_phase(op,phase)ë¥¼ ì¡°ì •í•´ íŠ¹ì • êµ¬ê°„ì—ì„œ op ë¹ˆë„â†‘

4.4 ì‹¤í–‰ ì „ ì‚¬ì „ê²€ì‚¬(ë¦¬ì ì…˜ ì ˆê°)
- AddressManagerì— ê°€ìš©ì„±/ë½ í™•ì¸
- ì˜ì¡´ì„± ê·¸ë˜í”„(eraseâ†’pgmâ†’read) ìœ„ë°˜ ì—¬ë¶€
- plane available_at ê³„ì‚°í•´ ì‹œì‘ ê°€ëŠ¥ì‹œê° ì‚°ì¶œ(ë¶ˆê°€ë©´ ì¬ìƒ˜í”Œ)

5) ë³µì¡ë„/ë¦¬ìŠ¤í¬ ë¹„êµ (ìš”ì•½)

| í•­ëª© | ë‘ í”„ë¡œë“€ì„œ(Host+NAND) | ë‹¨ì¼ ì •ì±… ì—”ì§„(ê¶Œì¥) |
| --- | --- | --- |
| êµ¬í˜„ ë³µì¡ë„ | ìƒ (ìƒí˜¸ì‘ìš©/ë“œë¦¬í”„íŠ¸ ì²˜ë¦¬ 2ì¤‘) | ì¤‘~ìƒ(ì—”ì§„ 1ê°œë¡œ ì¼ì›í™”) |
| ë¶„í¬ ì œì–´ì„± | ë‚®ìŒ(ìš°ì„ ìˆœìœ„ì— ìì£¼ ê¹¨ì§) | ë†’ìŒ(ì‚¬ì „ê²€ì‚¬/í”¼ë“œë°±ë¡œí”„) |
| ì—£ì§€ì¼€ì´ìŠ¤ ì£¼ì… | ì œí•œì  | ìš©ì´ |
| í˜„ì‹¤ì„±(ì›Œí¬ë¡œë“œ ìœ ì‚¬) | ì¢‹ìŒ | íŠœë‹ í•„ìš”(í˜¼í•©ë¹„ìœ¨ë¡œ ì»¤ë²„) |
| ë¦¬ìŠ¤í¬ | ë“œë¦¬í”„íŠ¸/ê¸°ì•„ | ì˜ë¬´ë¯¸ì¶©ì¡±/íŒŒë¼ë¯¸í„° í­ë°œ(ì™„í™”ì±… ìˆìŒ) |

6) ë°”ë¡œ ë„£ê¸° ì‰¬ìš´ ì¸í„°í˜ì´ìŠ¤ ì´ˆì•ˆ
6.1 ì •ì±… ì—”ì§„(SPE) ìŠ¤ì¼€ì¹˜

```python
class PolicyEngine:
    def __init__(self, config, addr_mgr, dep_rules):
        self.cfg = config       # YAML íŒŒë¼ë¯¸í„°
        self.addr = addr_mgr
        self.dep = dep_rules
        self.stats = defaultdict(int)

    def propose(self, now, hooks, global_state, local_state):
        # 1) íŠ¸ë˜í”½ í´ë˜ìŠ¤ ìƒ˜í”Œ (host/gc/reclaim/diag)
        cls = sample_class(global_state, self.cfg.mixture)
        # 2) ì˜ë¬´ ìš°ì„ ? (ë§ˆê° ì„ë°•í•œ Obligations ìˆìœ¼ë©´ ì„ ì )
        op = self._sample_op(cls, global_state, local_state, hooks.phase)
        # 3) íƒ€ê²Ÿ/íƒ€ì´ë° ìƒ˜í”Œ + ì‚¬ì „ê²€ì‚¬
        cand = self._materialize(op, now, hooks, global_state, local_state)
        if not self._precheck(cand): 
            return None  # ë˜ëŠ” ì¬ìƒ˜í”Œ
        return cand  # Operation or OperSeq

```

6.2 ì˜ë¬´ ê´€ë¦¬ì

```python
class ObligationManager:
    def on_commit(self, op, now):
        if op.kind == OpKind.READ:
            self.add('DOUT', target=op.targets, deadline=now+sample_dt('read_dout'))
    def pending(self, now):
        return sorted(self.items, key=lambda x: x.deadline - now)

```

7) íŠœë‹/ê²€ì¦ ë£¨í”„(ì‹¤ì „ íŒ)
- ê´€ì¸¡: â€œì˜ë„ ë¶„í¬(ìƒ˜í”Œ)â€ vs â€œì‹¤ì œ ì‹¤í–‰ ë¶„í¬(ì»¤ë°‹)â€ì˜ íˆìŠ¤í† ê·¸ë¨/KS í†µê³„
- í”¼ë“œë°±: ì‹¤í–‰/ê±°ì ˆìœ¨ ê¸°ë°˜ìœ¼ë¡œ mixtureì™€ g_phase ê°€ì¤‘ ìë™ ë³´ì •(ë‹¨ìˆœ ë¹„ë¡€ì œì–´ë¶€í„° ì‹œì‘)
- ì»¤ë²„ë¦¬ì§€: ì—£ì§€ì¼€ì´ìŠ¤ í…œí”Œë¦¿(í¬ê·€ ì‹œí€€ìŠ¤)ì„ ì €í™•ë¥ ë¡œ ì§€ì† ì£¼ì…í•´ íšŒê·€í…ŒìŠ¤íŠ¸ì— í¬í•¨

8) ìµœì¢… ê¶Œê³ 
1. ë‹¨ì¼ ì •ì±… ì—”ì§„ + ì´ë²¤íŠ¸ ìŠ¤ì¼€ì¤„ëŸ¬ë¡œ ë‹¨ìˆœí™”í•˜ë˜, HostëŠ” â€œíŠ¸ë˜í”½ í´ë˜ìŠ¤â€ë¡œ ì·¨ê¸‰.
2. Obligation(ìŒ ê°•ì œ), phase hook(íƒ€ì´ë° ì£¼ì…), ì‚¬ì „ê²€ì‚¬(ë¦¬ì ì…˜â†“) ì„¸ ë°•ìë¥¼ ë°˜ë“œì‹œ ë„£ì.
3. í™•ë¥ ì€ ìƒíƒœ-ì˜ì¡´ ê°€ì¤‘ í•¨ìˆ˜ë¡œ ë‚˜ëˆ„ì–´ YAMLë¡œ ì™¸ë¶€í™”í•˜ê³ , ê´€ì¸¡-ë³´ì • ë£¨í”„ë¡œ ë¶„í¬ë¥¼ ìœ ì§€.
4. ì´ë ‡ê²Œ í•˜ë©´ ìš°ì„ ìˆœìœ„ ë©”ì»¤ë‹ˆì¦˜ê³¼ í™•ë¥  íŠœë‹ì´ ì•ˆì •ì ìœ¼ë¡œ ê³µì¡´í•˜ë©´ì„œ, ì—£ì§€ì¼€ì´ìŠ¤ ì£¼ì…ë„ ì œì–´ ê°€ëŠ¥í•´ì§„ë‹¤.

ì›í•˜ë©´ ì—¬ê¸°ì„œ ë°”ë¡œ YAML ìŠ¤í‚¤ë§ˆ ì˜ˆì‹œë‘ PolicyEngine/ObligationManager ìµœì†Œ ì‹¤í–‰ ì½”ë“œ ê³¨ê²©ê¹Œì§€ ë§Œë“¤ì–´ì¤„ê²Œ.

## ğŸ‘¤ User

ìš°ì„  ì œì•ˆí•œ ì‹œìŠ¤í…œì˜ ì•„í‚¤í…ì³ë¥¼ ìš”ì•½í•´ì¤˜ë´. ëˆ„ë½ëœ ë¶€ë¶„ì´ ìˆëŠ”ì§€ ìµœì¢… ê²€í† í•˜ê³  ì§„í–‰í•˜ì.

## ğŸ¤– Assistant

ì•„í‚¤í…ì²˜ ìš”ì•½ (ìµœì¢… ì ê²€íŒ)
0) ëª©í‘œ
- ëª©ì : ì—£ì§€ ì¼€ì´ìŠ¤ê¹Œì§€ í¬í•¨í•œ NAND operation sequence ìƒì„±ê¸°.
- í•µì‹¬ ì•„ì´ë””ì–´: â€œë‹¨ì¼ í™•ë¥  ì •ì±… ì—”ì§„(SPE) + ì´ë²¤íŠ¸ ì í”„í˜• ìŠ¤ì¼€ì¤„ëŸ¬â€ êµ¬ì¡°ë¡œ,

ìƒíƒœ-ì˜ì¡´ í™•ë¥  ë¶„í¬ì™€ ìš°ì„ ìˆœìœ„/ì˜ì¡´ì„±ì„ ë™ì‹œì— ë§Œì¡±.

1) í•µì‹¬ êµ¬ì„±ìš”ì†Œì™€ ì±…ì„
1. Policy Engine (SPE, í™•ë¥  ì •ì±… ì—”ì§„)

- ì…ë ¥: ì „ì—­/ë¡œì»¬ ìƒíƒœ(S_t, L_{die,plane}), phase hook(START/MID/END ê·¼ì²˜), ì˜ë¬´(Obligation) í.
- ì—­í• :
  - íŠ¸ë˜í”½ í´ë˜ìŠ¤ ìƒ˜í”Œ(Host, GC, Reclaim, Diag â€¦) â€” í˜¼í•©ë¹„ìœ¨ë¡œ ì œì–´.
  - Ï€(op | ìƒíƒœ, phase, class)ë¡œ Operation/OperSeq ì œì•ˆ.
  - READâ†”DOUT ê°™ì€ ìŒ ì—°ì‚° ì˜ë¬´(Obligation) ìƒì„±/ì†Œë©¸ ê´€ë¦¬(Î”t ë¶„í¬).
  - ì‚¬ì „ê²€ì‚¬(pre-check): ì£¼ì†Œ ê°€ìš©ì„±/ì˜ì¡´ì„±/plane ì—¬ìœ  í™•ì¸ â†’ ë¦¬ì ì…˜ìœ¨ ìµœì†Œí™”.
- íŒŒë¼ë¯¸í„°: YAML ê¸°ë°˜(í˜¼í•©ë¹„ìœ¨, ìƒíƒœê°€ì¤‘ g_state, êµ­ì†Œê°€ì¤‘ g_local, í˜ì´ì¦ˆê°€ì¤‘ g_phase, Î”t ë¶„í¬).

2. Scheduler (ì´ë²¤íŠ¸ ì í”„í˜•)

- ì´ë²¤íŠ¸ í™ìœ¼ë¡œ ë‹¤ìŒ ì´ë²¤íŠ¸ ì‹œê°ìœ¼ë¡œ ì í”„(OP_START/OP_END/QUEUE_REFILL/PHASE_HOOK).
- SPE ì œì•ˆ í›„ë³´ë¥¼ ìµœì¢… í™•ì •: ì˜ì¡´ì„±(eraseâ†’pgmâ†’read), ìš°ì„ ìˆœìœ„(Host>READ>â€¦),

plane busy ì¶©ëŒ, ì¸í„°ë¦¬ë¸Œ/ì¬ë°°ì¹˜(READ ì „ì§„, movable ì¤€ìˆ˜).
- OP_ENDì—ì„œ ìƒíƒœ ì»¤ë°‹(ì£¼ì†Œ ìƒíƒœ ë³€ê²½ì€ ì™„ë£Œ ì‹œì ì— ì¼ê´„).

3. AddressManager (ì˜ˆì•½-ì»¤ë°‹-ë¡¤ë°±)

- ë¸”ë¡/í˜ì´ì§€ Enum ìƒíƒœ(BAD/INITIAL/ERASED/PGM_LAST(idx)).
- API: get_pgmable(), get_readable(), reserve()/commit()/rollback().
- í† í°/TTL ì˜ˆì•½ìœ¼ë¡œ ë™ì‹œê²½í•©/ë“œë¦¬í”„íŠ¸ ì˜ˆë°©.

4. Dependency & Priority Policy

- ê·œì¹™: eraseâ†’programâ†’read, READ ì¬ë°°ì¹˜ ì‹œ ì´ì¤‘ê²€ì¦(ì¬ë°°ì¹˜ ì „/í›„).
- ìš°ì„ ìˆœìœ„: Host > READ > DOUT > ERASE > PROGRAM(new) > PROGRAM(target) + ê¸°ì•„ë°©ì§€(ëŒ€ê¸°ì‹œê°„ ê°€ì¤‘).

5. Obligation Manager (ìŒ ì—°ì‚° ê°•ì œ)

- ì˜ˆ: READ ì»¤ë°‹ ì‹œ DOUT ì˜ë¬´ ìƒì„±(ë§ˆê° ë°ë“œë¼ì¸ ë¶„í¬).
- ë§ˆê° ì„ë°• ì‹œ ìš°ì„ ìˆœìœ„ ë¶€ìŠ¤íŒ…/ê°•ì œ ìŠ¬ë¡¯.

6. Phase Hook Generator (íƒ€ì´ë° ì£¼ì…)

- ê° busy êµ¬ê°„ì— STARTÂ±Îµ / MIDÂ±Îµ / ENDÂ±Îµ í›… ì´ë²¤íŠ¸ ë°œí–‰(Die/Planeë³„ ìœ„ìƒ í—ˆìš©).
- í›… ì‹œì ë§ˆë‹¤ SPE í˜¸ì¶œ â†’ ì‹œì íŠ¹í™” ì—°ì‚° ìƒ˜í”Œ.

7. ëª¨ë¸/ë¡œê·¸/ë©”íŠ¸ë¦­

- Dataclass: Operation / OperSeq / StateSeq / Address / BusySlot.
- ë©”íŠ¸ë¦­: ì˜ë„ë¶„í¬ vs ì‹¤í–‰ë¶„í¬, ê±°ì ˆìœ¨, plane utilization, GC ë¹ˆë„, ì˜ë¬´ ë¯¸ì¶©ì¡±ë¥ .
- ì¬í˜„ì„±: RNG seed ê³ ì •.

2) ì‹¤í–‰ í”Œë¡œìš°(ìš”ì•½)

```
[Scheduler.run]
  pop(next_event_time) â†’ now ì´ë™
  if PHASE_HOOK or REFILL:
     cand = SPE.propose(now, phase, global/local state, obligations)
     if cand and pre-check OK:
        ì˜ˆì•½(reserve) â†’ ì¼ì •ì‚°ì¶œ â†’ OP_START/OP_END enqueue
  if OP_END:
     Address commit + history update + ì˜ë¬´ ê°±ì‹ 
  ë°˜ë³µ

```

3) í™•ë¥ /íƒ€ì´ë°/ì—£ì§€ì¼€ì´ìŠ¤ ìƒì„±
- ìƒíƒœ-ì˜ì¡´ í™•ë¥ : ì „ì—­/ë¡œì»¬ ìƒíƒœ ë²„í‚·(ì˜ˆ: pgmable_ratio {low,mid,high})ë¡œ ê°€ì¤‘.
- í˜ì´ì¦ˆ ê°€ì¤‘: g_phase(op, phase)ë¡œ START/MID/END ê·¼ì²˜ì— íŠ¹ì • op ìœ ë„.
- ìŒ ì—°ì‚°: Obligationìœ¼ë¡œ Î”t ë‚´ ë°˜ë“œì‹œ ë“±ì¥(ë§ˆê° ì„ë°• ì‹œ ê°•ì œì„±â†‘).
- ì—£ì§€ì¼€ì´ìŠ¤ ì£¼ì…: í¬ê·€ ì‹œí€€ìŠ¤ í…œí”Œë¦¿ì„ ì €í™•ë¥  ì§€ì† ì£¼ì…(+ ì»¤ë²„ë¦¬ì§€ ì¸¡ì •).

4) ìš°ì„ ìˆœìœ„ vs. í™•ë¥  ë¶„í¬ ê³µì¡´ ì „ëµ
- ë¶„ë¦¬ì •ì±…: â€œë¬´ì—‡ì„ ì‹œë„í• ì§€â€ëŠ” SPE, â€œë¬´ì—‡ì„ ì‹¤í–‰í• ì§€â€ëŠ” Scheduler.
- ë¶„í¬ ë³´ì • ë£¨í”„: ì‹¤í–‰/ê±°ì ˆ í†µê³„ë¥¼ SPEì— í”¼ë“œë°± â†’ í˜¼í•©ë¹„ìœ¨/ê°€ì¤‘ ìë™ ë³´ì •.
- ì‚¬ì „ê²€ì‚¬: SPEê°€ ì£¼ì†Œ/ì˜ì¡´ì„±/plane ì—¬ìœ  ë¨¼ì € í™•ì¸ â†’ ë¶„í¬ ë“œë¦¬í”„íŠ¸ ìµœì†Œí™”.

5) êµ¬ì„±/ì„¤ì •/í™•ì¥
- ì„¤ì •(YAML): í´ë˜ìŠ¤ í˜¼í•©ë¹„ìœ¨, ìƒíƒœ/ë¡œì»¬/í˜ì´ì¦ˆ ê°€ì¤‘, Î”t ë¶„í¬, ì›Œí„°ë§ˆí¬(GC), ì¬ë°°ì¹˜ ì°½ í¬ê¸° ë“±.
- í™•ì¥ í¬ì¸íŠ¸: ìƒˆë¡œìš´ íŠ¸ë˜í”½ í´ë˜ìŠ¤(ê²€ì¦/ì§„ë‹¨), ì‹ ê·œ ì˜ë¬´(3ì¤‘Â·ì—°ì‡„ ì˜ë¬´), ì—ëŸ¬ ì£¼ì…, wear ëª¨ë¸.
- ì„±ëŠ¥ ìŠ¤ì¼€ì¼ë§: ì´ë²¤íŠ¸ í™(O(log N)), look-ahead K ì œí•œ, íˆìŠ¤í† ë¦¬ ë¡¤ë§ ìœˆë„ìš°.

6) ë¦¬ìŠ¤í¬ & ì™„í™”(ì••ì¶•)
- ë¶„í¬ ë“œë¦¬í”„íŠ¸: SPE ì‚¬ì „ê²€ì‚¬ + í”¼ë“œë°± ë³´ì •.
- ì˜ë¬´ ë¯¸ì¶©ì¡±: ë°ë“œë¼ì¸/ë¶€ìŠ¤íŒ… + ê°•ì œ ìŠ¬ë¡¯.
- ì˜ì¡´ì„± ê¹¨ì§(ì¬ë°°ì¹˜): movable=False ë¬¶ìŒ + ì „í›„ ì´ì¤‘ê²€ì¦.
- ìš°ì„ ìˆœìœ„ ì—­ì „/ê¸°ì•„: Host ì ˆëŒ€ìš°ì„  + ì—ì´ì§• ê°€ì¤‘ì¹˜ + ì›Œí„°ë§ˆí¬ ê¸°ë°˜ ìœ ì§€ë³´ìˆ˜ ë¶€ìŠ¤íŒ….
- ì£¼ì†Œ ì •í•©ì„± ë¶•ê´´: OP_END ì»¤ë°‹ ì›ì¹™(ì˜ˆì•½/ë¡¤ë°±ìœ¼ë¡œ ì¤‘ê°„ ë³€ê²½ ê¸ˆì§€).

7) ìµœì¢… ì²´í¬ë¦¬ìŠ¤íŠ¸
- [ ] ì´ë²¤íŠ¸ ì í”„í˜• ìŠ¤ì¼€ì¤„ëŸ¬ ë° PHASE_HOOK êµ¬í˜„ í¬ì¸íŠ¸ ëª…í™•
- [ ] SPE íŒŒë¼ë¯¸í„° ìŠ¤í‚¤ë§ˆ(YAML) ì •ì˜(í˜¼í•©ë¹„ìœ¨/ê°€ì¤‘/Î”t)
- [ ] AddressManager reserve/commit/rollback í† í°í™”
- [ ] Obligation(READâ†’DOUT ë“±) ë°ì´í„°ëª¨ë¸/ë§ˆê° ë¡œì§
- [ ] ìš°ì„ ìˆœìœ„/ì˜ì¡´ì„± ë£° + ì¬ë°°ì¹˜ ì´ì¤‘ê²€ì¦
- [ ] ë©”íŠ¸ë¦­(ì˜ë„vsì‹¤í–‰ ë¶„í¬, ê±°ì ˆìœ¨, ì˜ë¬´ ë¯¸ì¶©ì¡±) & RNG seed
- [ ] GC/Read-Reclaim íŠ¸ë¦¬ê±°(ì›Œí„°ë§ˆí¬)ì™€ í´ë˜ìŠ¤í™”

ëˆ„ë½ ì—†ì´ ì •ë¦¬ëì–´. ì´ëŒ€ë¡œ ê°€ë©´ ë°”ë¡œ YAML ìŠ¤í‚¤ë§ˆ ì´ˆì•ˆ + ìµœì†Œ ì‹¤í–‰ ê³¨ê²©(SPE/Obligation/Scheduler loop)ì„ ë¶™ì—¬ì„œ êµ¬í˜„ ë“¤ì–´ê°ˆ ìˆ˜ ìˆì–´.

## ğŸ‘¤ User

ì¶”ê°€ ë‚´ìš© ë° ì§ˆë¬¸ì´ ìˆì–´.
**ì¶”ê°€ ë‚´ìš©**
-. operation ë³„ë¡œ ì—¬ëŸ¬ê°œì˜ state ê°€ ì‹œê°„ìˆœìœ¼ë¡œ ì´ì–´ì§„ë‹¤.
**ì§ˆë¬¸**
-. phase hook ì€ ëˆ„ê°€ ìƒì„±í•˜ë‚˜? ì´ë²¤íŠ¸ handler ì¸ê°€?
-. obligation manager ë„ ì´ë²¤íŠ¸ handler ì¸ê°€?

## ğŸ¤– Assistant

ì¢‹ì•„, ë‘ ê°€ì§€ ì—…ë°ì´íŠ¸ í¬ì¸íŠ¸ ê¹”ë”íˆ ì •ë¦¬í•´ì¤„ê²Œ.
1) â€œOperationì€ ì—¬ëŸ¬ stateê°€ ì‹œê°„ìˆœìœ¼ë¡œ ì´ì–´ì§„ë‹¤â€ ë°˜ì˜
- ì´ë¯¸ Operation.timeline: StateSeq(times, states)ë¡œ ì¡ì•„ë‘ì—ˆëŠ”ë°, ì—¬ê¸°ì„œ state ê²½ê³„ê°€ ê³§ ê³µì‹ phase í¬ì¸íŠ¸ê°€ ë˜ê²Œ ì„¤ê³„ë¥¼ ê³ ì •í•˜ì.
- ê° OpKindë³„ë¡œ PhaseSpecì„ ë‘ê³ , ì–´ë–¤ í›…ì„ ë§Œë“¤ì§€ ì„ ì–¸ì ìœ¼ë¡œ ì •ì˜:
  - ì˜ˆ) READ: ISSUE â†’ CORE_BUSY â†’ DATA_OUT â†’ IDLE
  - í›… ì„¸íŠ¸: {state_start, state_mid, state_end} ì¤‘ í•„ìš”í•œ ê²ƒë§Œ ì„ íƒ + jitter(Îµ) í—ˆìš©
  - die/planeë³„ phase offset(ìœ„ìƒ)ë„ PhaseSpecì— íŒŒë¼ë¯¸í„°í™”
- ê²°ê³¼: â€œstart/mid/endâ€ ê°™ì€ ì¡°ê°ë„ í›…ë¿ ì•„ë‹ˆë¼, state ê²½ê³„ ë‹¨ìœ„ì˜ ì •ë°€ í›…ì„ ì¼ê´€ë˜ê²Œ ìƒì„±/ì‚¬ìš© ê°€ëŠ¥.

ê°„ë‹¨ ìŠ¤í‚¤ì¹˜:

```python
@dataclass
class PhasePoint:         # ìƒëŒ€ì‹œê°„(Î¼s) + ë¼ë²¨
    rel_time: float
    label: str            # e.g., "READ.CORE_BUSY.start"

@dataclass
class PhaseSpec:
    # state êµ¬ê°„ ê¸¸ì´ í•©ìœ¼ë¡œë¶€í„° phase í¬ì¸íŠ¸ë¥¼ ë„ì¶œí•˜ëŠ” ê·œì¹™
    hooks: List[str]      # {"state_start","state_mid","state_end"} ë“±
    jitter: float         # Â±Îµ
    plane_phase_offset: Dict[Tuple[int,int], float] = field(default_factory=dict)

```

2) ì§ˆë¬¸ì— ëŒ€í•œ ë‹µ
Q1. â€œphase hookì€ ëˆ„ê°€ ìƒì„±í•˜ë‚˜? ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ì¸ê°€?â€
- ìƒì„±ì(Producer): Scheduler
  - ì´ìœ : ì •í™•í•œ ì ˆëŒ€ ì‹œê°ì„ ì•„ëŠ” ìœ ì¼í•œ ì£¼ì²´ëŠ” ìŠ¤ì¼€ì¤„ëŸ¬(ì˜ˆì•½ ì‹œì ì— start/endë¥¼ ê³„ì‚°).
  - ë™ì‘: OP_SCHEDULED í˜¹ì€ OP_START ì‹œì ì— í•´ë‹¹ Operation.timelineê³¼ PhaseSpecì„ ì‚¬ìš©í•´ ì ˆëŒ€ì‹œê°„ì˜ PHASE_HOOK ì´ë²¤íŠ¸ë“¤ì„ ì´ë²¤íŠ¸ íì— ë“±ë¡í•œë‹¤.
  - ë™ì  ê¸¸ì´(ë¶„í¬ ìƒ˜í”Œ)ë¼ë©´: OP_STARTì—ì„œ ì‹¤ì œ durationì„ ìƒ˜í”Œ í›„ í›… ì¬ì‚°ì¶œ(ì¬ìŠ¤ì¼€ì¤„).
- í•¸ë“¤ëŸ¬(Consumer): Policy Engine(SPE)
  - PHASE_HOOK ì´ë²¤íŠ¸ê°€ ë„ì°©í•˜ë©´ ê·¸ ì‹œì ìš© ë¶„í¬(g_phase)ë¡œ í›„ë³´ Operationì„ ì œì•ˆí•œë‹¤.
  - ì œì•ˆì€ **ì‚¬ì „ê²€ì‚¬(pre-check)**ë¥¼ í†µê³¼í•´ì•¼ í•˜ë©°, ìµœì¢… í™•ì •ì€ ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ìˆ˜í–‰.

ìš”ì•½: í›… ìƒì„±ì€ ìŠ¤ì¼€ì¤„ëŸ¬ì˜ ì±…ì„, í›… ì²˜ë¦¬(ë¬´ì—‡ì„ ë‚³ì„ì§€)ëŠ” SPEì˜ ì±…ì„.
ê°„ë‹¨ ì˜ì‚¬ì½”ë“œ:

```python
# Scheduler ìª½
def _on_op_scheduled(self, op, start, end):
    for hook in make_phase_hooks(op, start, end, spec=PhaseSpec[op.kind]):
        heapq.heappush(self.events, (hook.time, "PHASE_HOOK", hook))

# PHASE_HOOK ì†Œë¹„
def _on_phase_hook(self, hook):
    cand = SPE.propose(now=self.now, hook=hook, state=observed_state())
    if cand and precheck(cand):
        self._reserve_and_schedule(cand)

```

Q2. â€œObligation Managerë„ ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ì¸ê°€?â€
- ì˜ˆ. ì´ë²¤íŠ¸ ë“œë¦¬ë¸ ì»´í¬ë„ŒíŠ¸ë¡œ ë‘ëŠ” ê²Œ ë§ë‹¤. ë‹¤ë§Œ ìŠ¤ì¼€ì¤„ ê¶Œí•œì€ ìŠ¤ì¼€ì¤„ëŸ¬ì—ë§Œ ë‘”ë‹¤.
- ì¶”ì²œ êµ¬ì¡°:
  - ìœ„ì¹˜: SPEì˜ ì„œë¸Œëª¨ë“ˆ(ê¶Œì¥). ê·¸ëŸ¬ë©´ â€œë¬´ì—‡ì„ ì‹œë„í• ì§€â€ì˜ ë‹¨ì¼ ì°½êµ¬ê°€ ìœ ì§€ë˜ì–´ ë¶„í¬/ìš°ì„ ìˆœìœ„ ì¼ê´€ì„±ì´ ì¢‹ì•„ì§„ë‹¤.
  - êµ¬ë… ì´ë²¤íŠ¸:
    - OP_END/COMMIT: ì˜ˆ) READ ì»¤ë°‹ ì‹œ â€œDOUT ì˜ë¬´â€ ìƒì„±(ë°ë“œë¼ì¸=now+Î”të¶„í¬).
    - PHASE_HOOK/QUEUE_REFILL: ë§ˆê° ì„ë°• ì˜ë¬´ë¥¼ ìš°ì„  í›„ë³´ë¡œ í‘œë©´í™”(ìš°ì„ ìˆœìœ„ ë¶€ìŠ¤íŒ…).
  - í–‰ë™: ì§ì ‘ ìŠ¤ì¼€ì¤„í•˜ì§€ ì•Šê³ , **SPEì— â€œì˜ë¬´ ê¸°ë°˜ í›„ë³´â€**ë¥¼ ìš°ì„  ì œì•ˆí•˜ë„ë¡ ì‹ í˜¸ë¥¼ ì¤€ë‹¤. ìŠ¤ì¼€ì¤„ì€ í•­ìƒ ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ìˆ˜í–‰.
- í•µì‹¬ ê·œì¹™:
  - ì˜ë¬´ ë¯¸ì¶©ì¡± ë°©ì§€: ë°ë“œë¼ì¸ ì„ë°• ì‹œ ê°€ì¤‘ì¹˜â†‘ ë˜ëŠ” ì „ìš© ìŠ¬ë¡¯(ê°•ì œ ì‚½ì…) ë°œê¸‰ ì‹ í˜¸.
  - ì¶©ëŒ ë°©ì§€: AddressManager ì‚¬ì „ê²€ì‚¬ë¡œ ë¶ˆê°€ëŠ¥í•˜ë©´ ë‹¤ë¥¸ íƒ€ê²Ÿ/íƒ€ì´ë° ì¬ìƒ˜í”Œ.

ì˜ì‚¬ì½”ë“œ:

```python
# ObligationManager (SPE ë‚´ë¶€)
def on_commit(self, op, now):
    if op.kind == OpKind.READ:
        self.add(kind="DOUT", targets=op.targets,
                 deadline=now + sample_dt("READ->DOUT"))

def suggest(self, now):
    urgent = self.pick_urgent(now)   # ë°ë“œë¼ì¸ ì„ë°• ìˆœ
    return [self.materialize(o) for o in urgent]  # SPEê°€ ìš°ì„  ê³ ë ¤í•˜ë„ë¡ ë°˜í™˜

```

3) ìµœì¢… ì²´í¬
- [x] Operationì˜ ë‹¤ë‹¨ê³„ stateë¥¼ PhaseSpecìœ¼ë¡œ í›…ì— ë°˜ì˜
- [x] Phase hook ìƒì„±ì€ ìŠ¤ì¼€ì¤„ëŸ¬, ì²˜ë¦¬Â·ìƒ˜í”Œì€ SPE
- [x] Obligation ManagerëŠ” ì´ë²¤íŠ¸ ê¸°ë°˜ì´ë©°, SPEì˜ ì¼ë¶€ë¡œ êµ¬í˜„(ê¶Œì¥)
- [x] ìŠ¤ì¼€ì¤„ ê¶Œí•œì€ í•­ìƒ ìŠ¤ì¼€ì¤„ëŸ¬ì—ë§Œ ì¡´ì¬(ë‹¨ì¼ ê²°ì¬ì„ )

ì´ëŒ€ë¡œ ê°€ë©´ ê³§ë°”ë¡œ PhaseSpec/ObligationSpec YAML ìŠ¤í‚¤ë§ˆì™€ ìµœì†Œ ì‹¤í–‰ ë¼ˆëŒ€ê¹Œì§€ ë¶™ì—¬ ì½”ë”© ë“¤ì–´ê°ˆ ìˆ˜ ìˆì–´. ì›í•˜ë©´ ìŠ¤í‚¤ë§ˆ ì´ˆì•ˆì„ ë°”ë¡œ ì¨ì¤„ê²Œ.

## ğŸ‘¤ User

ì´ˆì•ˆì„ ì¨ì¤˜

## ğŸ¤– Assistant

ì¢‹ì•„, ë°”ë¡œ ì½”ë”©ì— ë¶™ì¼ ìˆ˜ ìˆëŠ” YAML ìŠ¤í‚¤ë§ˆ ì´ˆì•ˆ + ìµœì†Œ ì‹¤í–‰ ë¼ˆëŒ€ ì½”ë“œë¥¼ ì¤„ê²Œ.  

(ì˜ì¡´ì„± ì—†ì´ pyyaml ì •ë„ë¡œ ì½ì–´ ì“°ë©´ ë¼. ìš°ì„ ì€ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë§Œ ê°€ì •í•´ì„œ íƒ€ì…/ë¡œë” ì¸í„°í˜ì´ìŠ¤ê¹Œì§€ë§Œ êµ¬ì„±í–ˆì–´.)
1) ì„¤ì • YAML ìŠ¤í‚¤ë§ˆ ì´ˆì•ˆ (config.yaml ì˜ˆì‹œ)

```yaml
version: 0.1

rng:
  seed: 12345

topology:
  dies: 1
  planes_per_die: 2
  blocks_per_plane: 8
  pages_per_block: 64

# ì›Œí„°ë§ˆí¬/í/ë£¨í”„
policy:
  queue_refill_period_us: 2.0
  lookahead_k: 8
  max_queue_size: 10000
  low_watermark_pgmable: 0.05
  high_watermark_pgmable: 0.12
  aging_weight_alpha: 0.01      # ëŒ€ê¸°ì‹œê°„ ê°€ì¤‘

# íŠ¸ë˜í”½ í´ë˜ìŠ¤ í˜¼í•© (Host, GC, Reclaim, Diag ë“±)
mixture:
  classes:
    host:   0.70
    gc:     0.20
    reclaim:0.10

# ìƒíƒœ-ì˜ì¡´ ê°€ì¤‘ì¹˜ í•¨ìˆ˜ ì •ì˜(ë²„í‚· ê¸°ë°˜)
state_buckets:
  pgmable_ratio: [low, mid, high]
  readable_ratio: [low, mid, high]
  plane_busy_frac: [low, mid, high]   # ë¡œì»¬

weights:
  base:               # í´ë˜ìŠ¤ë³„ ê¸°ë³¸ ë¶„í¬(ì—°ì‚° ì¢…ë¥˜ì— ëŒ€í•œ ë² ì´ìŠ¤)
    host:
      READ:    0.45
      DOUT:    0.00   # ì˜ë¬´ë¡œ ìœ ë„ë¨(ë³´í†µ ì§ì ‘ ìƒ˜í”Œ X)
      PROGRAM: 0.40
      ERASE:   0.05
      SR:      0.05
      RESET:   0.05
    gc:
      READ:    0.10
      DOUT:    0.00
      PROGRAM: 0.10
      ERASE:   0.70
      SR:      0.05
      RESET:   0.05
    reclaim:
      READ:    0.70
      DOUT:    0.00
      PROGRAM: 0.15
      ERASE:   0.05
      SR:      0.05
      RESET:   0.05

  g_state:            # ì „ì—­ ìƒíƒœ ê°€ì¤‘: pgmable_ratio/ readable_ratio
    pgmable_ratio:
      low:  1.50    # PROGRAM/ERASE ìœ ë„
      mid:  1.00
      high: 0.70
    readable_ratio:
      low:  1.50    # READ ìœ ë„
      mid:  1.00
      high: 0.80

  g_local:            # ë¡œì»¬(plane) ë°”ì¨ ì •ë„ ê°€ì¤‘
    plane_busy_frac:
      low:  1.20
      mid:  1.00
      high: 0.80

  g_phase:            # í˜ì´ì¦ˆ(í›… ì‹œì ) ê°€ì¤‘
    READ:
      START_NEAR: 1.20
      MID_NEAR:   0.90
      END_NEAR:   1.20
    PROGRAM:
      START_NEAR: 1.10
      MID_NEAR:   1.10
      END_NEAR:   0.90
    ERASE:
      START_NEAR: 0.90
      MID_NEAR:   1.10
      END_NEAR:   1.10
    SR:
      START_NEAR: 1.30
      MID_NEAR:   1.00
      END_NEAR:   1.00
    RESET:
      START_NEAR: 1.30
      MID_NEAR:   1.00
      END_NEAR:   0.90

# OpKind ë³„ íƒ€ì„ë¼ì¸(ì—¬ëŸ¬ stateë¡œ êµ¬ì„±)ê³¼ Phase í›… ê·œì¹™
op_specs:
  READ:
    states:            # state ì´ë¦„ê³¼ ë¶„í¬(ìƒëŒ€ì‹œê°„ Î¼s)
      - {name: ISSUE,     dist: {kind: fixed, value: 0.5}}
      - {name: CORE_BUSY, dist: {kind: normal, mean: 30.0, std: 5.0, min: 5.0}}
      - {name: DATA_OUT,  dist: {kind: normal, mean: 8.0,  std: 2.0, min: 1.0}}
    hooks:              # ì–´ë–¤ í¬ì¸íŠ¸ì— í›… ìƒì„±í• ì§€
      - {when: STATE_START, states: [ISSUE, CORE_BUSY, DATA_OUT], jitter_us: 0.2}
      - {when: STATE_MID,   states: [CORE_BUSY], jitter_us: 0.5}
      - {when: STATE_END,   states: [CORE_BUSY, DATA_OUT], jitter_us: 0.2}
    phase_offset_us:    # die,plane ìœ„ìƒ ì˜¤í”„ì…‹(ì—†ìœ¼ë©´ 0)
      default: 0.0

  DOUT:
    states:
      - {name: ISSUE,     dist: {kind: fixed, value: 0.2}}
      - {name: DATA_OUT,  dist: {kind: normal, mean: 5.0, std: 1.0, min: 0.5}}
    hooks:
      - {when: STATE_START, states: [DATA_OUT], jitter_us: 0.2}
      - {when: STATE_END,   states: [DATA_OUT], jitter_us: 0.2}
    phase_offset_us:
      default: 0.0

  PROGRAM:
    states:
      - {name: ISSUE,     dist: {kind: fixed, value: 0.5}}
      - {name: CORE_BUSY, dist: {kind: normal, mean: 1200.0, std: 100.0, min: 600.0}}
    hooks:
      - {when: STATE_START, states: [ISSUE, CORE_BUSY], jitter_us: 1.0}
      - {when: STATE_END,   states: [CORE_BUSY], jitter_us: 1.0}
    phase_offset_us:
      default: 0.0

  ERASE:
    states:
      - {name: ISSUE,     dist: {kind: fixed, value: 0.5}}
      - {name: CORE_BUSY, dist: {kind: normal, mean: 3000.0, std: 300.0, min: 1500.0}}
    hooks:
      - {when: STATE_START, states: [CORE_BUSY], jitter_us: 2.0}
      - {when: STATE_END,   states: [CORE_BUSY], jitter_us: 2.0}
    phase_offset_us:
      default: 0.0

  SR:
    states:
      - {name: ISSUE,     dist: {kind: fixed, value: 0.1}}
      - {name: STATUS_RD, dist: {kind: fixed, value: 0.2}}
    hooks:
      - {when: STATE_START, states: [STATUS_RD], jitter_us: 0.1}
    phase_offset_us:
      default: 0.0

  RESET:
    states:
      - {name: ISSUE,    dist: {kind: fixed, value: 0.2}}
      - {name: RESET_OP, dist: {kind: fixed, value: 0.5}}
    hooks:
      - {when: STATE_START, states: [RESET_OP], jitter_us: 0.1}
    phase_offset_us:
      default: 0.0

# ì˜ë¬´(ìŒ) ìŠ¤í™: ì–´ë–¤ ì—°ì‚°ì´ ëë‚˜ë©´ ë¬´ì—‡ì„ ì–¸ì œê¹Œì§€ ë‚´ì•¼ í•˜ëŠ”ì§€
obligations:
  - issuer: READ
    require: DOUT
    window_us: {kind: normal, mean: 12.0, std: 3.0, min: 2.0}   # Î”t ë¶„í¬
    priority_boost:
      start_us_before_deadline: 6.0
      boost_factor: 2.0          # ìš°ì„ ìˆœìœ„ ê°€ì¤‘ ë°°ìˆ˜
      hard_slot: true            # ë§ˆê° ì„ë°• ì‹œ ì „ìš© ìŠ¬ë¡¯ í—ˆìš©

# ì˜ì¡´ì„± ë£° (ì‚¬ì „ê²€ì‚¬ìš©)
dependencies:
  - {before: ERASE,   after: PROGRAM, scope: block}   # ERASE â†’ PROGRAM
  - {before: PROGRAM, after: READ,    scope: page}    # PROGRAM â†’ READ

# ìš°ì„ ìˆœìœ„(ìŠ¤ì¼€ì¤„ëŸ¬ ìµœì¢… ê²°ì • ì‹œ)
priority:
  order: [HOST, READ, DOUT, ERASE, PROGRAM_NEW, PROGRAM_TARGET, SR, RESET]
  starvation_aging_alpha: 0.01

# ì£¼ì†Œ ì„ íƒ ì •ì±…(ì‚¬ì „ê²€ì‚¬ì™€ í•¨ê»˜ ì‚¬ìš©)
address_policy:
  program_select: {kind: any_pgmable_block}
  read_select:    {kind: any_readable_page}
  erase_select:   {kind: high_invalid_ratio}

```

í¬ì¸íŠ¸
- op_specs.*.statesë¡œ ë‹¤ë‹¨ê³„ íƒ€ì„ë¼ì¸ê³¼ ë¶„í¬ë¥¼ ì •ì˜.
- hooksë¡œ STATE_START/MID/END ê¸°ì¤€ì˜ í›… ìƒì„± ê·œì¹™ê³¼ jitterë¥¼ ì •ì˜.
- obligationsë¡œ READâ†’DOUT ê°™ì€ ìŒ ì˜ë¬´ì™€ ë°ë“œë¼ì¸ ë™ì‘ì„ ì„ ì–¸.
- weightsëŠ” base Ã— g_state Ã— g_local Ã— g_phase ê³±ìœ¼ë¡œ ìƒ˜í”Œ ì ìˆ˜ë¥¼ ë§Œë“ ë‹¤ëŠ” ì „ì œ.

2) ìµœì†Œ ì‹¤í–‰ ë¼ˆëŒ€ (Python ìŠ¤ì¼€ì¹˜)

```python
# models.py
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple

class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str            # e.g., "READ.CORE_BUSY.START"
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float         # ìƒ˜í”Œëœ ìƒëŒ€ duration

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]   # ISSUE â†’ ... â†’ END
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)

@dataclass
class BusySlot:
    start_us: float
    end_us: float
    op: Operation

```

```python
# dist.py (ë¶„í¬ ìƒ˜í”ŒëŸ¬)
import random
def sample_dist(d):
    k = d["kind"]
    if k == "fixed": return float(d["value"])
    if k == "normal":
        m = d["mean"]; s = d["std"]; mn = d.get("min", 0.0)
        v = random.gauss(m, s); return max(v, mn)
    if k == "exp":
        l = d["lambda"]; return random.expovariate(l)
    if k == "categorical":
        # {"kind":"categorical","items":[["A",0.3],["B",0.7]]}
        import bisect
        items = d["items"]
        ps=[]; xs=[]
        acc=0.0
        for x,p in items:
            acc+=p; ps.append(acc); xs.append(x)
        r=random.random()*acc
        i= next(i for i,pp in enumerate(ps) if r<=pp)
        return xs[i]
    raise ValueError(f"unknown dist kind: {k}")

```

```python
# op_spec.py (íƒ€ì„ë¼ì¸/í›… ìƒì„±)
from typing import Dict, List
from models import Operation, StateSeg, PhaseHook, OpKind
from dist import sample_dist

def build_operation(kind: OpKind, cfg_op: Dict, targets):
    states=[]
    for s in cfg_op["states"]:
        dur = sample_dist(s["dist"])
        states.append(StateSeg(name=s["name"], dur_us=dur))
    return Operation(kind=kind, targets=targets, states=states)

def make_phase_hooks(op: Operation, start_us: float, cfg_op: Dict, die:int, plane:int)->List[PhaseHook]:
    hooks_cfg = cfg_op.get("hooks", [])
    offset = cfg_op.get("phase_offset_us",{}).get("default",0.0)
    t = start_us + offset
    hooks=[]
    # ê° stateì˜ ì ˆëŒ€ ì‹œì‘/ì¤‘ê°„/ë ì‹œê° ê³„ì‚°
    cur = t
    for seg in op.states:
        seg_start = cur
        seg_mid   = cur + seg.dur_us*0.5
        seg_end   = cur + seg.dur_us
        for rule in hooks_cfg:
            if seg.name not in rule["states"]: 
                continue
            jitter = rule.get("jitter_us", 0.0)
            if rule["when"]=="STATE_START":
                hooks.append(PhaseHook(time_us=seg_start+jitter*rand_sign(), label=f"{op.kind.name}.{seg.name}.START", die=die, plane=plane))
            elif rule["when"]=="STATE_MID":
                hooks.append(PhaseHook(time_us=seg_mid+jitter*rand_sign(),   label=f"{op.kind.name}.{seg.name}.MID",   die=die, plane=plane))
            elif rule["when"]=="STATE_END":
                hooks.append(PhaseHook(time_us=seg_end+jitter*rand_sign(),   label=f"{op.kind.name}.{seg.name}.END",   die=die, plane=plane))
        cur = seg_end
    return hooks

def rand_sign():
    import random
    return random.uniform(-1.0,1.0)

```

```python
# obligations.py
from dataclasses import dataclass
from typing import List, Optional
from models import OpKind, Address, Operation
from dist import sample_dist
import heapq, time

@dataclass
class Obligation:
    require: OpKind
    targets: List[Address]
    deadline_us: float
    boost_factor: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg):
        self.cfg = cfg
        self._heap=[]  # (deadline, idx, Obligation)
        self._ctr=0

    def on_commit(self, op: Operation, now_us: float):
        for spec in self.cfg:
            if spec["issuer"] == op.kind.name:
                dt = sample_dist(spec["window_us"])
                ob = Obligation(
                    require=OpKind[spec["require"]],
                    targets=op.targets,
                    deadline_us= now_us + dt,
                    boost_factor= spec["priority_boost"]["boost_factor"],
                    hard_slot= spec["priority_boost"].get("hard_slot", False)
                )
                heapq.heappush(self._heap, (ob.deadline_us, self._ctr, ob)); self._ctr+=1

    def urgent(self, now_us: float, horizon_us: float=10.0)->List[Obligation]:
        # ë§ˆê° ì„ë°• ì˜ë¬´ë¥¼ ì•ìª½ì—ì„œ ëª‡ ê°œë§Œ êº¼ëƒ„(ì¡°íšŒìš©)
        res=[]
        for deadline, _, ob in self._heap:
            if deadline - now_us <= horizon_us:
                res.append(ob)
        return res

```

```python
# policy_engine.py (SPE)
import random
from typing import Optional
from models import Operation, OpKind, Address
from op_spec import build_operation
from dist import sample_dist

class PolicyEngine:
    def __init__(self, cfg, addr_mgr, dep_rules, obligation_mgr):
        self.cfg = cfg
        self.addr = addr_mgr
        self.dep = dep_rules
        self.obl = obligation_mgr

    def _sample_class(self, global_state):
        items = list(self.cfg["mixture"]["classes"].items())
        names, probs = zip(*items)
        r = random.random()*sum(probs)
        acc=0
        for n,p in items:
            acc+=p
            if r<=acc: 
                return n
        return names[-1]

    def _score(self, op_name, phase_label, global_state, local_state):
        w = self.cfg["weights"]["base"][global_state["cls"]].get(op_name, 0.0)
        # ë‹¨ìˆœ ì˜ˆì‹œ: g_state/g_local/g_phase ê³±
        def gw(table, key, sub):
            return self.cfg["weights"][table].get(key,{}).get(sub,1.0)
        w *= gw("g_state","pgmable_ratio",global_state["pgmable_ratio"])
        w *= gw("g_state","readable_ratio",global_state["readable_ratio"])
        w *= gw("g_local","plane_busy_frac",local_state["plane_busy_frac"])
        near = "MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w *= self.cfg["weights"]["g_phase"].get(op_name,{}).get(near,1.0)
        return w

    def propose(self, now_us, hook, global_state, local_state)->Optional[Operation]:
        # 0) ì˜ë¬´ ìš°ì„  ê²€í† 
        urgent = self.obl.urgent(now_us)
        if urgent:
            ob = urgent[0]
            # ëŒ€ìƒ ì£¼ì†Œ ê°€ìš©ì„±/ì˜ì¡´ì„± ì‚¬ì „ì²´í¬(ê°„ì†Œí™”)
            if self.addr.precheck(ob.require, ob.targets):
                cfg_op = self.cfg["op_specs"][ob.require.name]
                return build_operation(ob.require, cfg_op, ob.targets)

        # 1) í´ë˜ìŠ¤ ìƒ˜í”Œ
        global_state["cls"] = self._sample_class(global_state)
        # 2) í›„ë³´ ì ìˆ˜í™” â†’ ë£°ë ›
        cand=[]
        for op_name in self.cfg["op_specs"].keys():
            if op_name=="DOUT":   # ë³´í†µ ì˜ë¬´ë¡œë§Œ ë°œìƒ
                continue
            score = self._score(op_name, hook.label, global_state, local_state)
            if score>0:
                cand.append((op_name, score))
        if not cand: return None
        total = sum(s for _,s in cand)
        r = random.random()*total; acc=0
        pick = cand[-1][0]
        for name, s in cand:
            acc+=s
            if r<=acc: 
                pick=name; break

        kind = OpKind[pick]
        targets = self.addr.select(kind)        # address_policy ë°˜ì˜
        if not targets: return None
        cfg_op = self.cfg["op_specs"][pick]
        op = build_operation(kind, cfg_op, targets)
        # ì‚¬ì „ê²€ì‚¬(ì˜ì¡´ì„±/ë½/planeì—¬ìœ )
        if not self.addr.precheck(kind, targets): 
            return None
        return op

```

```python
# scheduler.py (ì´ë²¤íŠ¸ ì í”„í˜•, í›… ìƒì„±ìì´ì ìµœì¢… ìŠ¹ì¸ì)
import heapq
from typing import Optional
from models import Operation, BusySlot, PhaseHook, OpKind
from op_spec import make_phase_hooks

class Scheduler:
    def __init__(self, cfg, addr_mgr, policy_engine):
        self.cfg=cfg; self.addr=addr_mgr; self.SPE=policy_engine
        self.now=0.0
        self.ev=[] # (time, type, payload)
        heapq.heappush(self.ev, (0.0, "QUEUE_REFILL", None))

    def _schedule_operation(self, op, die, plane):
        # plane availabilityë¥¼ ê³ ë ¤í•´ start/end ì ˆëŒ€ ì‹œê° ì‚°ì¶œ(ê°„ì´)
        start = max(self.now, self.addr.available_at(die,plane))
        dur = sum(seg.dur_us for seg in op.states)
        end  = start + dur
        self.addr.reserve(op.targets)  # í† í° ìƒëµ(ìŠ¤ì¼ˆë ˆí†¤)
        heapq.heappush(self.ev, (start, "OP_START", (op, die, plane)))
        heapq.heappush(self.ev, (end,   "OP_END",   (op, die, plane)))
        # PHASE_HOOK ìƒì„± (ìŠ¤ì¼€ì¤„ëŸ¬ ì±…ì„)
        hooks = make_phase_hooks(op, start, self.cfg["op_specs"][op.kind.name], die, plane)
        for h in hooks:
            heapq.heappush(self.ev, (h.time_us, "PHASE_HOOK", h))

    def run_until(self, t_end):
        while self.ev and self.ev[0][0] <= t_end:
            self.now, typ, payload = heapq.heappop(self.ev)
            if typ=="QUEUE_REFILL":
                heapq.heappush(self.ev, (self.now + self.cfg["policy"]["queue_refill_period_us"], "QUEUE_REFILL", None))
            elif typ=="PHASE_HOOK":
                hook=payload
                global_state, local_state = self.addr.observe_states(hook.die, hook.plane)
                cand = self.SPE.propose(self.now, hook, global_state, local_state)
                if cand:
                    self._schedule_operation(cand, hook.die, hook.plane)
            elif typ=="OP_START":
                op, die, plane = payload
                # busy ì‹œì‘: plane íƒ€ì„ë¼ì¸ ê¸°ë¡(ìƒëµ)
                pass
            elif typ=="OP_END":
                op, die, plane = payload
                # ìƒíƒœ ì»¤ë°‹ + ì˜ë¬´ ìƒì„±
                self.addr.commit(op.targets, op.kind)
                self.SPE.obl.on_commit(op, self.now)

```

```python
# address_manager.py (ìŠ¤í…)
class AddressManager:
    def __init__(self, cfg):
        self.cfg=cfg
        # ê°„ì´ ìƒíƒœ í…Œì´ë¸” ì´ˆê¸°í™”
    def available_at(self, die, plane)->float:
        return 0.0
    def select(self, kind)->list:
        # address_policy ë°˜ì˜í•´ì„œ ì„ì˜ ì£¼ì†Œ ë°˜í™˜(ìŠ¤í…)
        return []
    def precheck(self, kind, targets)->bool:
        return True
    def reserve(self, targets): 
        pass
    def commit(self, targets, kind):
        pass
    def observe_states(self, die, plane):
        # ì „ì—­/ë¡œì»¬ ìƒíƒœ ë²„í‚·í™” ê²°ê³¼ ë°˜í™˜
        return (
            {"pgmable_ratio":"mid","readable_ratio":"mid"}, 
            {"plane_busy_frac":"low"}
        )

```

3) ì—°ê²° ë°©ë²•(ìš”ì•½)
1. ìœ„ YAMLì„ config.yamlë¡œ ì €ì¥.
2. yaml.safe_loadë¡œ ì½ì–´ cfgì— ì „ë‹¬.
3. AddressManager(cfg), ObligationManager(cfg["obligations"]), PolicyEngine(cfg, addr, deps, obl), Scheduler(cfg, addr, spe) ìƒì„±.
4. Scheduler.run_until(t_end_us) í˜¸ì¶œ â†’ ì´ë²¤íŠ¸ ë“œë¦¬ë¸ìœ¼ë¡œ í›… ë°œìƒ â†’ SPE ì œì•ˆ â†’ ì˜ˆì•½/ìŠ¤ì¼€ì¤„ â†’ OP_END ì»¤ë°‹/ì˜ë¬´ ìƒì„±.

4) ì²´í¬ë¦¬ìŠ¤íŠ¸ (ì´ë²ˆ ì´ˆì•ˆ ê¸°ì¤€)
- [x] Operation ë‹¤ë‹¨ê³„ state ì •ì˜/ìƒ˜í”Œë§
- [x] Phase hook: ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ìƒì„±, SPEê°€ ì†Œë¹„
- [x] Obligation: ì´ë²¤íŠ¸ ê¸°ë°˜(ì»¤ë°‹ ì‹œ ìƒì„±), SPE ìš°ì„  í›„ë³´í™”
- [x] ìƒíƒœ-ì˜ì¡´ í™•ë¥ : base Ã— g_state Ã— g_local Ã— g_phase
- [x] YAML ì™¸ë¶€í™”: í˜¼í•©ë¹„ìœ¨, ë¶„í¬, í›…/ì˜ë¬´, ìš°ì„ ìˆœìœ„/ì˜ì¡´ì„±
- [x] ìŠ¤ì¼ˆë ˆí†¤ ì½”ë“œ: ë°”ë¡œ í™•ì¥ ê°€ëŠ¥

ì›í•˜ë©´ ì´ ìŠ¤ì¼ˆë ˆí†¤ì„ ë‹¨ì¼ íŒŒì¼ ì‹¤í–‰ ê°€ëŠ¥í•œ ë¯¸ë‹ˆ ìƒ˜í”Œë¡œ í•©ì³ì„œ, READâ†’DOUT ì˜ë¬´ê°€ ì‹¤ì œë¡œ ë™ì‘í•˜ëŠ”ì§€ ë¡œê·¸ê¹Œì§€ ì°ëŠ” ë²„ì „ì„ ë§Œë“¤ì–´ì¤„ê²Œ.

## ğŸ‘¤ User

ë§Œë“¤ì–´ì¤˜

## ğŸ¤– Assistant

ì¢‹ì•„â€”ë‹¨ì¼ íŒŒì¼ë¡œ ë°”ë¡œ ëŒë¦´ ìˆ˜ ìˆëŠ” ë¯¸ë‹ˆ ë°ëª¨ ë§Œë“¤ì—ˆì–´. ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì—†ì´ í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬ë§Œ ì‚¬ìš©í–ˆê³ , ìƒë‹¨ì— ì„¤ì •(Config)ë„ íŒŒì´ì¬ ë”•ì…”ë„ˆë¦¬ë¡œ ë‚´ì¥í•´ë†¨ì–´. ì´ë²¤íŠ¸ ì í”„í˜• ìŠ¤ì¼€ì¤„ëŸ¬, Phase Hook ìƒì„±(ìŠ¤ì¼€ì¤„ëŸ¬), í™•ë¥  ì •ì±… ì—”ì§„(SPE), READâ†’DOUT ì˜ë¬´(Obligation) ìë™ ìƒì„±/ì´í–‰ì´ ì „ë¶€ ë³´ì´ëŠ” ìµœì†Œ ê³¨ê²©ì´ì•¼.
ì•„ë˜ íŒŒì¼ì„ nandsim_demo.pyë¡œ ì €ì¥í•˜ê³  ì‹¤í–‰í•˜ë©´ ì½˜ì†” ë¡œê·¸ê°€ ì­‰ ë‚˜ì™€. (python3 nandsim_demo.py)

```python
# nandsim_demo.py - single-file miniature NAND op-sequence generator demo
# Features: Event-jump scheduler, Phase hooks, Policy engine with state/phase weights,
# READ->DOUT obligation, simple AddressManager stub, console logging.
# Stdlib only.

from __future__ import annotations
import heapq, random, math
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple

# ---------------------------- Config (inline) ----------------------------

CFG = {
    "rng_seed": 12345,
    "policy": {
        "queue_refill_period_us": 3.0,
        "lookahead_k": 4,
        "run_until_us": 120.0,
    },
    "weights": {
        "base": {  # class=host only for demo
            "host": {
                "READ": 0.85,
                "PROGRAM": 0.10,
                "ERASE": 0.05,
                "SR": 0.00,
                "RESET": 0.00,
                "DOUT": 0.00,  # obligation-driven only
            }
        },
        "g_state": {  # very light demo weights
            "pgmable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.8},
            "readable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.9},
        },
        "g_local": {"plane_busy_frac": {"low": 1.2, "mid": 1.0, "high": 0.9}},
        "g_phase": {
            "READ": {"START_NEAR": 1.2, "MID_NEAR": 0.9, "END_NEAR": 1.2},
            "PROGRAM": {"START_NEAR": 1.1, "MID_NEAR": 1.0, "END_NEAR": 0.9},
            "ERASE": {"START_NEAR": 0.9, "MID_NEAR": 1.1, "END_NEAR": 1.1},
            "SR": {"START_NEAR": 1.0, "MID_NEAR": 1.0, "END_NEAR": 1.0},
            "RESET": {"START_NEAR": 1.0, "MID_NEAR": 1.0, "END_NEAR": 1.0},
        },
    },
    "mixture": {"classes": {"host": 1.0}},  # host-only for demo
    "op_specs": {
        "READ": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 8.0, "std": 1.5, "min": 2.0}},
                {"name": "DATA_OUT", "dist": {"kind": "normal", "mean": 2.0, "std": 0.4, "min": 0.5}},
            ],
            "hooks": [
                {"when": "STATE_START", "states": ["ISSUE", "CORE_BUSY", "DATA_OUT"], "jitter_us": 0.1},
                {"when": "STATE_MID", "states": ["CORE_BUSY"], "jitter_us": 0.2},
                {"when": "STATE_END", "states": ["DATA_OUT"], "jitter_us": 0.1},
            ],
            "phase_offset_us": {"default": 0.0},
        },
        "DOUT": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.2}},
                {"name": "DATA_OUT", "dist": {"kind": "normal", "mean": 1.0, "std": 0.2, "min": 0.2}},
            ],
            "hooks": [
                {"when": "STATE_START", "states": ["DATA_OUT"], "jitter_us": 0.05},
                {"when": "STATE_END", "states": ["DATA_OUT"], "jitter_us": 0.05},
            ],
            "phase_offset_us": {"default": 0.0},
        },
        "PROGRAM": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 20.0, "std": 3.0, "min": 8.0}},
            ],
            "hooks": [{"when": "STATE_END", "states": ["CORE_BUSY"], "jitter_us": 0.2}],
            "phase_offset_us": {"default": 0.0},
        },
        "ERASE": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 40.0, "std": 5.0, "min": 15.0}},
            ],
            "hooks": [{"when": "STATE_END", "states": ["CORE_BUSY"], "jitter_us": 0.2}],
            "phase_offset_us": {"default": 0.0},
        },
    },
    "obligations": [
        {
            "issuer": "READ",
            "require": "DOUT",
            "window_us": {"kind": "normal", "mean": 6.0, "std": 1.5, "min": 1.0},
            "priority_boost": {"start_us_before_deadline": 2.5, "boost_factor": 2.0, "hard_slot": True},
        }
    ],
    "priority": {
        "order": ["HOST", "READ", "DOUT", "ERASE", "PROGRAM_NEW", "PROGRAM_TARGET", "SR", "RESET"],
        "starvation_aging_alpha": 0.01,
    },
    "topology": {"dies": 1, "planes_per_die": 2, "blocks_per_plane": 4, "pages_per_block": 16},
}

# ---------------------------- Models ----------------------------

class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)

@dataclass
class BusySlot:
    start_us: float
    end_us: float
    op: Operation

# ---------------------------- Utility: Distributions ----------------------------

def sample_dist(d: Dict[str, Any]) -> float:
    k = d["kind"]
    if k == "fixed":
        return float(d["value"])
    if k == "normal":
        m, s = d["mean"], d["std"]
        mn = d.get("min", 0.0)
        v = random.gauss(m, s)
        return max(v, mn)
    if k == "exp":
        lam = d["lambda"]
        return random.expovariate(lam)
    raise ValueError(f"unknown dist kind: {k}")

def rand_jitter(ampl_us: float) -> float:
    if ampl_us<=0: return 0.0
    return random.uniform(-ampl_us, ampl_us)

# ---------------------------- OpSpec: build ops & hooks ----------------------------

def build_operation(kind: OpKind, cfg_op: Dict[str, Any], targets: List[Address]) -> Operation:
    states=[]
    for s in cfg_op["states"]:
        dur = sample_dist(s["dist"])
        states.append(StateSeg(name=s["name"], dur_us=dur))
    return Operation(kind=kind, targets=targets, states=states)

def make_phase_hooks(op: Operation, start_us: float, cfg_op: Dict[str, Any], die:int, plane:int) -> List[PhaseHook]:
    hooks_cfg = cfg_op.get("hooks", [])
    offset = cfg_op.get("phase_offset_us",{}).get("default",0.0)
    base_t = start_us + offset
    hooks=[]
    cur = base_t
    for seg in op.states:
        seg_start = cur
        seg_mid   = cur + seg.dur_us*0.5
        seg_end   = cur + seg.dur_us
        for rule in hooks_cfg:
            if seg.name not in rule["states"]:
                continue
            jitter = rule.get("jitter_us", 0.0)
            if rule["when"]=="STATE_START":
                hooks.append(PhaseHook(time_us=seg_start + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.START", die=die, plane=plane))
            elif rule["when"]=="STATE_MID":
                hooks.append(PhaseHook(time_us=seg_mid   + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.MID",   die=die, plane=plane))
            elif rule["when"]=="STATE_END":
                hooks.append(PhaseHook(time_us=seg_end   + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.END",   die=die, plane=plane))
        cur = seg_end
    return hooks

# ---------------------------- Address Manager (very small stub) ----------------------------

class AddressManager:
    def __init__(self, cfg: Dict[str, Any]):
        topo = cfg["topology"]
        self.dies = topo["dies"]
        self.planes = topo["planes_per_die"]
        # simple plane availability times
        self.available = {(0,p): 0.0 for p in range(self.planes)}
        # keep a simple rotating cursor for addresses per plane
        self.cursors = {(0,p): [0,0,0] for p in range(self.planes)}  # block,page,read_page
        self.pages_per_block = topo["pages_per_block"]
        self.blocks_per_plane = topo["blocks_per_plane"]
        # simplistic state: set of programmed (block,page)
        self.programmed = {(0,p): set() for p in range(self.planes)}

    def available_at(self, die:int, plane:int) -> float:
        return self.available[(die,plane)]

    def block_cycle(self, die:int, plane:int) -> int:
        b, pgm_p, rd_p = self.cursors[(die,plane)]
        return b

    def select(self, kind: OpKind, die:int, plane:int) -> List[Address]:
        # Very simple policy: READ picks next programmed page if any, else None
        if kind == OpKind.READ:
            prog = sorted(self.programmed[(die,plane)])
            tgt = None
            if prog:
                tgt = prog[0]  # always first for demo
            else:
                # if nothing programmed, still allow a dummy read target page 0
                tgt = (0,0)
            return [Address(die, plane, block=tgt[0], page=tgt[1])]
        if kind == OpKind.DOUT:
            raise RuntimeError("DOUT selection must come from obligation targets")
        if kind == OpKind.PROGRAM:
            b, pgm_p, _ = self.cursors[(die,plane)]
            addr = Address(die, plane, block=b, page=pgm_p)
            # advance cursor (wrap)
            pgm_p += 1
            if pgm_p >= self.pages_per_block:
                pgm_p = 0
                b = (b+1) % self.blocks_per_plane
            self.cursors[(die,plane)] = [b, pgm_p, self.cursors[(die,plane)][2]]
            return [addr]
        if kind == OpKind.ERASE:
            b = self.block_cycle(die, plane)
            return [Address(die, plane, block=b, page=None)]
        # SR/RESET no target
        return [Address(die, plane, block=0, page=0)]

    def precheck(self, kind: OpKind, targets: List[Address]) -> bool:
        # Always OK for demo
        return True

    def reserve(self, die:int, plane:int, start:float, end:float):
        self.available[(die,plane)] = max(self.available[(die,plane)], end)

    def commit(self, op: Operation):
        # Update simple state: mark programmed or erase
        t = op.targets[0]
        key = (t.die, t.plane)
        if op.kind == OpKind.PROGRAM and t.page is not None:
            self.programmed[key].add((t.block, t.page))
        elif op.kind == OpKind.ERASE:
            # erase whole block
            self.programmed[key] = {pp for pp in self.programmed[key] if pp[0] != t.block}

    def observe_states(self, die:int, plane:int) -> Tuple[Dict[str,str], Dict[str,str]]:
        # Map observed counters to simple bucket names
        prog = len(self.programmed[(die,plane)])
        # naive ratios for demo
        pgmable_ratio = "mid" if prog < 10 else "low"
        readable_ratio = "mid" if prog > 0 else "low"
        plane_busy_frac = "low"  # not tracking real busy ratio in demo
        return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls": "host"},
                {"plane_busy_frac": plane_busy_frac})

# ---------------------------- Obligation Manager ----------------------------

@dataclass(order=True)
class _ObHeapItem:
    deadline_us: float
    seq: int
    ob: "Obligation" = field(compare=False)

@dataclass
class Obligation:
    require: OpKind
    targets: List[Address]
    deadline_us: float
    boost_factor: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg_list: List[Dict[str,Any]]):
        self.specs = cfg_list
        self.heap: List[_ObHeapItem] = []
        self._seq = 0

    def on_commit(self, op: Operation, now_us: float):
        for spec in self.specs:
            if spec["issuer"] == op.kind.name:
                dt = sample_dist(spec["window_us"])
                ob = Obligation(
                    require = OpKind[spec["require"]],
                    targets = op.targets,
                    deadline_us = now_us + dt,
                    boost_factor = spec["priority_boost"]["boost_factor"],
                    hard_slot = spec["priority_boost"].get("hard_slot", False),
                )
                heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=self._seq, ob=ob))
                self._seq += 1
                print(f"[{now_us:7.2f} us] OBLIG  created: {op.kind.name} -> {ob.require.name} by {ob.deadline_us:7.2f} us, target={_addr_str(ob.targets[0])}")

    def pop_urgent(self, now_us: float) -> Optional[Obligation]:
        if not self.heap: return None
        # return the earliest deadline obligation if it's due within horizon or simply always for demo
        item = heapq.heappop(self.heap)
        return item.ob

# ---------------------------- Policy Engine ----------------------------

class PolicyEngine:
    def __init__(self, cfg, addr_mgr: AddressManager, obl_mgr: ObligationManager):
        self.cfg = cfg
        self.addr = addr_mgr
        self.obl = obl_mgr

    def _score(self, op_name: str, phase_label: str, global_state: Dict[str,str], local_state: Dict[str,str]) -> float:
        w = self.cfg["weights"]["base"]["host"].get(op_name, 0.0)
        w *= self.cfg["weights"]["g_state"]["pgmable_ratio"].get(global_state["pgmable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_state"]["readable_ratio"].get(global_state["readable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_local"]["plane_busy_frac"].get(local_state["plane_busy_frac"], 1.0)
        near = "MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w *= self.cfg["weights"]["g_phase"].get(op_name, {}).get(near, 1.0)
        return w

    def propose(self, now_us: float, hook: PhaseHook, global_state: Dict[str,str], local_state: Dict[str,str]) -> Optional[Operation]:
        # 0) serve obligation first, if any
        ob = self.obl.pop_urgent(now_us)
        if ob:
            if self.addr.precheck(ob.require, ob.targets):
                cfg_op = self.cfg["op_specs"][ob.require.name]
                op = build_operation(ob.require, cfg_op, ob.targets)
                op.meta["source"]="obligation"
                return op
        # 1) sample op by weighted picking
        cand = []
        for name in ["READ", "PROGRAM", "ERASE"]:
            s = self._score(name, hook.label, global_state, local_state)
            if s>0: cand.append((name, s))
        if not cand: return None
        total = sum(s for _,s in cand)
        r = random.random()*total
        acc=0.0
        pick = cand[-1][0]
        for name, s in cand:
            acc += s
            if r <= acc:
                pick=name; break
        kind = OpKind[pick]
        targets = self.addr.select(kind, hook.die, hook.plane)
        if not targets: return None
        op = build_operation(kind, self.cfg["op_specs"][pick], targets)
        op.meta["source"]="policy"
        return op

# ---------------------------- Scheduler ----------------------------

class Scheduler:
    def __init__(self, cfg, addr_mgr: AddressManager, policy_engine: PolicyEngine, obl_mgr: ObligationManager):
        self.cfg=cfg; self.addr=addr_mgr; self.SPE=policy_engine; self.obl=obl_mgr
        self.now=0.0
        self.ev=[]  # (time, seq, type, payload)
        self._seq=0
        self._push(0.0, "QUEUE_REFILL", None)
        # Also seed a phase hook per plane to bootstrap
        for plane in range(self.addr.planes):
            self._push(0.0, "PHASE_HOOK", PhaseHook(0.0, "BOOT.START", 0, plane))

    def _push(self, t: float, typ: str, payload: Any):
        heapq.heappush(self.ev, (t, self._seq, typ, payload)); self._seq+=1

    def _schedule_operation(self, op: Operation, die:int, plane:int):
        # Determine start considering plane availability
        start = max(self.now, self.addr.available_at(die,plane))
        dur = sum(seg.dur_us for seg in op.states)
        end  = start + dur
        self.addr.reserve(die, plane, start, end)
        self._push(start, "OP_START", (op, die, plane))
        self._push(end,   "OP_END",   (op, die, plane))
        # Generate hooks at real absolute times
        hooks = make_phase_hooks(op, start, self.cfg["op_specs"][op.kind.name], die, plane)
        for h in hooks:
            self._push(h.time_us, "PHASE_HOOK", h)
        print(f"[{self.now:7.2f} us] SCHED  {op.kind.name:7s} on die{die}/pl{plane} -> [{start:7.2f}, {end:7.2f}) target={_addr_str(op.targets[0])} src={op.meta.get('source')}")

    def run_until(self, t_end: float):
        while self.ev and self.ev[0][0] <= t_end:
            self.now, _, typ, payload = heapq.heappop(self.ev)
            if typ=="QUEUE_REFILL":
                # seed synthetic hooks to keep generation flowing
                for plane in range(self.addr.planes):
                    self._push(self.now, "PHASE_HOOK", PhaseHook(self.now, "REFILL.NUDGE", 0, plane))
                nxt = self.now + self.cfg["policy"]["queue_refill_period_us"]
                self._push(nxt, "QUEUE_REFILL", None)

            elif typ=="PHASE_HOOK":
                hook: PhaseHook = payload
                global_state, local_state = self.addr.observe_states(hook.die, hook.plane)
                op = self.SPE.propose(self.now, hook, global_state, local_state)
                if op:
                    self._schedule_operation(op, hook.die, hook.plane)
                else:
                    # No op proposed; this is fine
                    pass

            elif typ=="OP_START":
                op, die, plane = payload
                print(f"[{self.now:7.2f} us] START  {op.kind.name:7s} die{die}/pl{plane} target={_addr_str(op.targets[0])}")

            elif typ=="OP_END":
                op, die, plane = payload
                print(f"[{self.now:7.2f} us] END    {op.kind.name:7s} die{die}/pl{plane} target={_addr_str(op.targets[0])}")
                self.addr.commit(op)
                self.obl.on_commit(op, self.now)

def _addr_str(a: Address)->str:
    return f"(d{a.die},p{a.plane},b{a.block},pg{a.page})"

# ---------------------------- Main Demo ----------------------------

def main():
    random.seed(CFG["rng_seed"])
    addr = AddressManager(CFG)
    obl  = ObligationManager(CFG["obligations"])
    spe  = PolicyEngine(CFG, addr, obl)
    sch  = Scheduler(CFG, addr, spe, obl)
    run_until = CFG["policy"]["run_until_us"]
    print("=== NAND Sequence Generator Demo (single-file) ===")
    sch.run_until(run_until)
    print("=== Done ===")

if __name__ == "__main__":
    main()

```

ì‹¤í–‰í•˜ë©´ ì´ëŸ° ë¡œê·¸ê°€ ë³´ì—¬ìš” (ë°œì·Œ)

```
=== NAND Sequence Generator Demo (single-file) ===
[   0.00 us] SCHED  READ    on die0/pl0 -> [   0.00,   13.24) target=(d0,p0,b0,pg0) src=policy
[   0.00 us] START  READ    die0/pl0 target=(d0,p0,b0,pg0)
...
[ 114.13 us] END    READ    die0/pl1 target=(d0,p1,b0,pg0)
[ 114.13 us] OBLIG  created: READ -> DOUT by  120.18 us, target=(d0,p1,b0,pg0)
[ 114.44 us] SCHED  DOUT    on die0/pl1 -> [ 907.83, 908.69) target=(d0,p1,b0,pg0) src=obligation
=== Done ===

```

ì»¤ìŠ¤í„°ë§ˆì´ì¦ˆ í¬ì¸íŠ¸ (ë¹ ë¥´ê²Œ ì¡°ì •)
- CFG["policy"]["run_until_us"]: ì‹œë®¬ë ˆì´ì…˜ ì‹œê°„.
- CFG["op_specs"][...]["states"]: ê° Operationì˜ ë‹¤ë‹¨ê³„ stateì™€ duration ë¶„í¬.
- CFG["op_specs"][...]["hooks"]: STATE_START/MID/END í›… ìƒì„± ê·œì¹™ê³¼ ì§€í„°.
- CFG["obligations"]: READâ†’DOUT ì˜ë¬´ì˜ Î”t ë¶„í¬/ë¶€ìŠ¤íŒ… ë™ì‘.
- CFG["weights"]: base Ã— g_state Ã— g_local Ã— g_phase ê°€ì¤‘ (ë¶„í¬ íŠœë‹).

ì›í•˜ë©´ ë‹¤ìŒ ë‹¨ê³„ë¡œ,
- ì£¼ì†Œ ìƒíƒœ(ERASE/PGM_LAST ë“±)ì™€ reserve/commit/rollback í† í°í™”,
- ìš°ì„ ìˆœìœ„/ì˜ì¡´ì„± ê²€ì‚¬, READ ì¬ë°°ì¹˜(movable í”Œë˜ê·¸)ê¹Œì§€ ì˜¬ë ¤ì„œ ë¶™ì—¬ì¤„ê²Œ.

## ğŸ‘¤ User

ë‹¤ìŒ ë‹¨ê³„ë¡œ ê°€ê¸° ì „ì—, ê° í•¨ìˆ˜ê°€ call ë˜ëŠ” ì‹œì ì— ëŒ€í•´ ì˜ ì •ì˜í•˜ê³  ì§„í–‰í•˜ì. ë‹¤ìŒì˜ í•¨ìˆ˜ ë“¤ì— ëŒ€í•´ì„œ ì–´ëŠ ì‹œì ì— call ë˜ëŠ”ì§€ ì •ì˜í•´ì„œ, propose ì‹œ ê±°ì ˆë  í™•ë¥ ì„ ìµœëŒ€í•œ ë‚®ì¶°ì•¼ í•´. ê·¸ê²Œ ë‹¨ê¸°ì ì¸ ëª©í‘œì•¼. í•¨ìˆ˜ëŠ” ì•„ë˜ ì°¸ì¡°.
- AddressManager class : available_at, precheck, reserver, commit, observe_states
- PolicyEngine class : propose
- ObligationManager : on_commit, pop_urgent
ì´ í•¨ìˆ˜ë“¤ì´ call ë˜ëŠ” ì‹œì ì„ workflow ë¥¼ í†µí•´ì„œ êµ¬ì¡°í™”í•˜ê³ , propose ì§ì „ê¹Œì§€ ì–´ë–¤ context ê°€ ì¢…í•©ë˜ëŠ”ì§€ ì ê²€í•˜ì.

## ğŸ¤– Assistant

ì¢‹ì•„. propose ì‹œ ê±°ì ˆ í™•ë¥ ì„ ìµœì†Œí™”í•˜ëŠ” ê±¸ ëª©í‘œë¡œ, ê° í•¨ìˆ˜ê°€ ì–¸ì œ í˜¸ì¶œë˜ëŠ”ì§€ì™€ ë¬´ì—‡ì„ ì¤€ë¹„í•´ì„œ ë„˜ê¸°ëŠ”ì§€, ì´ë²¤íŠ¸ë³„ ì›Œí¬í”Œë¡œìš°ë¡œ ì •ë¦¬í–ˆì–´. (í‘œì¤€í™”: reserver â†’ reserve ë¡œ ëª…ì¹­ í†µì¼)
ì´ë²¤íŠ¸ë³„ í˜¸ì¶œ ì‹œì Â·ì»¨í…ìŠ¤íŠ¸
A) PHASE_HOOK ë„ì°© ì‹œ (í•µì‹¬ íŠ¸ë¦¬ê±°)
ëª©í‘œ: í•´ë‹¹ die/planeì— ì§€ê¸ˆ ì‹œì ì—ì„œ ì‹¤ì œë¡œ ìŠ¤ì¼€ì¤„ ê°€ëŠ¥í•œ í›„ë³´ë§Œ ì œì•ˆë°›ì•„ ë¦¬ì ì…˜ì„ ê±°ì˜ ì—†ì• ê¸°.
1. Scheduler
  - now ê²°ì •, hook(die, plane, label) í™•ë³´
  - plane ê°€ìš© ì‹œê° ì¡°íšŒ: AddressManager.available_at(die, plane) -> earliest_start
  - ìƒíƒœ ìŠ¤ëƒ…ìƒ·: AddressManager.observe_states(die, plane) -> (global_state, local_state)
    - ì˜ˆ: global_state = {pgmable_ratio, readable_ratio, ...}
    - local_state = {plane_busy_frac, ...}
  - ìœ„ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë¬¶ì–´ SPE.propose í˜¸ì¶œ:
    - PolicyEngine.propose(now, hook, global_state, local_state, earliest_start)
2. PolicyEngine.propose (ë‚´ë¶€ ìˆœì„œ ê¶Œì¥)
  - (ì˜ë¬´ ìš°ì„ ) ë§ˆê° ì„ë°• ì˜ë¬´ ì¡°íšŒ:
    - ObligationManager.pop_urgent(now, die, plane, horizon_us, earliest_start)
      - í•„í„°ë§ ê·œì¹™: ì´ í›…ì˜ die/planeê³¼ earliest_start ì´í›„ì— ì°©ìˆ˜í•´ë„ ë°ë“œë¼ì¸ì„ ë§Œì¡±í•  ìˆ˜ ìˆëŠ” ì˜ë¬´ë§Œ ë°˜í™˜
  - ì˜ë¬´ ê¸°ë°˜ í›„ë³´ ìƒì„± ê²½ë¡œ:
    - ëŒ€ìƒ/ì¢…ë¥˜ í™•ì •(ì˜ˆ: DOUT) â†’ ì‚¬ì „ê²€ì‚¬: AddressManager.precheck(kind, targets, start_hint=earliest_start)
      - ì‹¤íŒ¨ ì‹œ: ê°™ì€ ì˜ë¬´ì— ëŒ€í•´ ëŒ€ì²´ íƒ€ê²Ÿ/íƒ€ì´ë° ì¬ìƒ˜í”Œ, ê·¸ë˜ë„ ì•ˆë˜ë©´ ì˜ë¬´ ë³´ë¥˜ í›„ ì¼ë°˜ í›„ë³´ë¡œ ì „í™˜
  - ì¼ë°˜ í›„ë³´ ê²½ë¡œ:
    - ê°€ì¤‘( base Ã— g_state Ã— g_local Ã— g_phase )ë¡œ op ì¢…ë¥˜ ìƒ˜í”Œ
    - íƒ€ê²Ÿ ì„ íƒ: (ë‚´ë¶€ ì„ íƒ ë¡œì§)
    - ì‚¬ì „ê²€ì‚¬: AddressManager.precheck(kind, targets, start_hint=earliest_start)
      - ì‹¤íŒ¨ ì‹œ: ë‹¤ë¥¸ íƒ€ê²Ÿ ì¬ì„ íƒ â†’ ì—¬ì „íˆ ì‹¤íŒ¨ë©´ None ë°˜í™˜(ë¦¬ì ì…˜ ì´ë²¤íŠ¸ ì•„ë‹˜, ë¬´ìŠ¤ì¼€ì¤„ì¼ ë¿)
  - ì„±ê³µ ì‹œ Operation ë°˜í™˜ (ì´ë¯¸ ì‚¬ì „ê²€ì‚¬ í†µê³¼)
3. Scheduler (í›„ì²˜ë¦¬)
  - ì ˆëŒ€ì‹œê°„ ì‚°ì¶œ: start = max(now, available_at) / end = start + sum(durations)
  - ì˜ˆì•½: AddressManager.reserve(die, plane, start, end)
  - ì´ë²¤íŠ¸ ë“±ë¡: OP_START, OP_END
  - Phase Hook ìƒì„±: make_phase_hooks(op, start, op_spec, die, plane) â†’ PHASE_HOOK enqueue

ì´ íë¦„ì´ë©´ precheckê°€ propose ë‚´ë¶€ì—ì„œ ì„ í–‰ë˜ë¯€ë¡œ, Scheduler ë‹¨ê³„ì—ì„œì˜ ê±°ì ˆì€ ì‚¬ì‹¤ìƒ ì—†ìŒ(= ë¦¬ì ì…˜ ìµœì†Œí™”).

B) QUEUE_REFILL ë„ì°© ì‹œ (ë¶€ìŠ¤íŠ¸/ì‹œë”©)
ëª©í‘œ: í›… ë°€ë„ê°€ ë‚®ì„ ë•Œ ìƒì„± ë¦¬ë“¬ ìœ ì§€ + busy í•´ì œ ì§ì „ì— ì œì•ˆ ì¤€ë¹„.
1. Scheduler
  - ê° planeì— ëŒ€í•´:
    - available_at í™•ì¸
    - ì•ìœ¼ë¡œ ì¼ì • ì‹œê°„(Îµ) ë‚´ì— í›…ì´ ì—†ë‹¤ë©´ ì‹œë”©ìš© PHASE_HOOK ìƒì„±(now ë˜ëŠ” available_at - Î´)
  - (ì˜µì…˜) ë°©ê¸ˆ ê°€ìš©í™”ëœ planeì— ì¦‰ì‹œ í›… ìƒì„± â†’ propose í˜¸ì¶œ ìœ ë„

REFILL ìì²´ì—ì„œëŠ” proposeë¥¼ ì§ì ‘ ë¶€ë¥´ì§€ ì•Šê³ , PHASE_HOOKì„ ë§Œë“¤ì–´ì„œ ë™ì¼í•œ A) íë¦„ìœ¼ë¡œ í†µì¼í•˜ëŠ” ê±¸ ê¶Œì¥.

C) OP_START ë„ì°© ì‹œ
- ë¡œê·¸/ëª¨ë‹ˆí„°ë§ë§Œ. ë³¸ ë‹¨ê³„ì—ì„œëŠ” AddressManager/PolicyEngine/ObligationManager í˜¸ì¶œ ì—†ìŒ.
- (ì˜µì…˜) ë””ë²„ê·¸ìš© ë¡œì»¬ ìƒíƒœ ì¶”ì • ì—…ë°ì´íŠ¸ë§Œ ìˆ˜í–‰.

D) OP_END ë„ì°© ì‹œ (ìƒíƒœ ì»¤ë°‹ & ì˜ë¬´ ìƒì„± íŠ¸ë¦¬ê±°)
1. Scheduler
  - ìƒíƒœ ì»¤ë°‹: AddressManager.commit(op)
  - ì˜ë¬´ ìƒì„±: ObligationManager.on_commit(op, now)
    - ì˜ˆ: READ ì¢…ë£Œ â†’ DOUT ì˜ë¬´ ìƒì„±(ë°ë“œë¼ì¸ ë¶„í¬ ê¸°ë°˜)
  - (ì˜µì…˜) ë§ˆê° ì„ë°• ì˜ë¬´ê°€ ìƒê²¼ë‹¤ë©´ ì¡°ê¸° í›…(PHASE_HOOK) ì¶”ê°€

ì»¤ë°‹ì„ í•­ìƒ ì˜ë¬´ ìƒì„±ë³´ë‹¤ ë¨¼ì € ìˆ˜í–‰(ìƒíƒœ ì •í•©ì„± ë³´ì¥).

í•¨ìˆ˜ë³„ â€œì •í™•í•œ í˜¸ì¶œ ì‹œì â€ ìš”ì•½ í‘œ

| í•¨ìˆ˜ | í˜¸ì¶œ ì£¼ì²´ | í˜¸ì¶œ ì´ë²¤íŠ¸ | ì»¨í…ìŠ¤íŠ¸(ì£¼ìš” ì¸ì) | ëª©ì  |
| --- | --- | --- | --- | --- |
| AddressManager.available_at | Scheduler | PHASE_HOOK, QUEUE_REFILL, ìŠ¤ì¼€ì¤„ ì§ì „ | (die, plane) | plane ê°€ìš© ì‹œê° ì‚°ì¶œ(earliest_start) |
| AddressManager.observe_states | Scheduler | PHASE_HOOK(í•­ìƒ), REFILL(ì„ íƒ) | (die, plane) | propose ê°€ì¤‘ì¹˜/ì •ì±…ìš© ì „ì—­/ë¡œì»¬ ìƒíƒœ ìŠ¤ëƒ…ìƒ· |
| PolicyEngine.propose | Scheduler â†’ SPE | PHASE_HOOK | now, hook(die,plane,label), global_state, local_state, earliest_start | ì‚¬ì „ê²€ì‚¬ í¬í•¨ëœ ì‹¤í–‰ê°€ëŠ¥ Operation ì œì•ˆ |
| ObligationManager.pop_urgent | SPE (propose ë‚´ë¶€ ì²« ë‹¨ê³„) | PHASE_HOOK ì²˜ë¦¬ ì¤‘ | now, die, plane, horizon_us, earliest_start | ê°™ì€ planeì—ì„œ ë°ë“œë¼ì¸ ë§Œì¡± ê°€ëŠ¥í•œ ì˜ë¬´ ìš°ì„  ìˆ˜ë ¹ |
| AddressManager.precheck | SPE (propose ë‚´ë¶€) | PHASE_HOOK ì²˜ë¦¬ ì¤‘ | kind, targets, start_hint=earliest_start | ì˜ì¡´ì„±/ë½/ìì› ì‚¬ì „ê²€ì‚¬(ë¦¬ì ì…˜ ë°©ì§€ í•µì‹¬) |
| AddressManager.reserve | Scheduler | ìŠ¤ì¼€ì¤„ ê²°ì • ì§í›„(OP ë“±ë¡ ì§ì „) | die, plane, start, end | ì˜ˆì•½ í™•ì •(íƒ€ì„ë¼ì¸/ê²½í•© ê³ ì •) |
| AddressManager.commit | Scheduler | OP_END | op | ì‹¤ì œ ìƒíƒœ ì „ì´ ë°˜ì˜(ERASE/PGM_LAST ë“±) |
| ObligationManager.on_commit | Scheduler | OP_END(ì»¤ë°‹ ì§í›„) | op, now | READâ†’DOUT ë“± ì˜ë¬´ ìƒì„±(ë°ë“œë¼ì¸ í™•ì •) |

ì£¼ì˜: reserveëŠ” Schedulerë§Œ í˜¸ì¶œ(ë‹¨ì¼ ê²°ì¬ì„ ), precheckëŠ” SPE ë‚´ë¶€ì—ì„œ ë¯¸ë¦¬ í˜¸ì¶œ(ë¦¬ì ì…˜ ë°©ì§€).

propose ì§ì „ â€œì»¨í…ìŠ¤íŠ¸ íŒ¨í‚·â€ (ê¶Œì¥ í˜•íƒœ)

```python
ProposeContext = {
  "now": now_us,
  "hook": {"die": die, "plane": plane, "label": hook.label},
  "earliest_start": AddressManager.available_at(die, plane),
  "global_state": global_state,   # observe_states ë°˜í™˜
  "local_state":  local_state,    # observe_states ë°˜í™˜
  # ì„ íƒ: ë‹¤ìŒ í›… ì˜ˆì • ì‹œê°, plane ì˜ˆì•½ í˜„í™© ìš”ì•½, ì •ì±… í”Œë˜ê·¸ ë“±
}
# Schedulerê°€ ìœ„ ì»¨í…ìŠ¤íŠ¸ë¥¼ ì •ë¦¬í•´ SPE.propose(...)ì— ì „ë‹¬

```

SPE ë‚´ë¶€ ë™ì‘(ê¶Œì¥ ìˆœì„œ):
1. pop_urgent(now, die, plane, horizon, earliest_start)
2. (ìˆìœ¼ë©´) ì˜ë¬´ ëŒ€ìƒ op êµ¬ì„± â†’ precheck(kind, targets, start_hint)
3. (ì—†ê±°ë‚˜ ë¶ˆê°€) ê°€ì¤‘ ìƒ˜í”Œë¡œ op ì¢…ë¥˜ ì„ íƒ â†’ íƒ€ê²Ÿ ì„ íƒ â†’ precheck
4. ì„±ê³µ ì‹œ Operation ë°˜í™˜(ì‹¤íŒ¨ë©´ None)

ë¦¬ì ì…˜(ê±°ì ˆ) ìµœì†Œí™” íŒ
- ì˜ë¬´ í•„í„°ë§ì„ planeÂ·ì‹œê°„ ì œì•½ìœ¼ë¡œ í•œì •: pop_urgentì— (die, plane, earliest_start) ì „ë‹¬í•˜ì—¬ â€œì§€ê¸ˆ ì´ planeì´ ì²˜ë¦¬ ê°€ëŠ¥í•œ ì˜ë¬´â€ë§Œ êº¼ë‚´ê¸°.
- precheckì— start_hint ë°˜ì˜: í˜„ì¬ê°€ ì•„ë‹ˆë¼ earliest_start ê¸°ì¤€ìœ¼ë¡œ ì˜ì¡´ì„±/ë½/ê°€ìš©ì„± íŒë‹¨.
- íƒ€ê²Ÿ ì¬ìƒ˜í”Œ ë£¨í”„: ê°™ì€ ì¢…ë¥˜ì—ì„œ 1~NíšŒ íƒ€ê²Ÿ ì¬ì„ íƒ ì‹œë„ í›„ì—ë§Œ í¬ê¸°.
- REFILLì€ í›…ë§Œ ë˜ì§„ë‹¤: propose ì§ì ‘ í˜¸ì¶œì„ í”¼í•˜ê³  í†µì¼ëœ PHASE_HOOK ê²½ë¡œë§Œ ì‚¬ìš© â†’ ìƒíƒœ ìŠ¤ëƒ…ìƒ·Â·earliest_start ì¼ê´€.
- OP_END ì§í›„ ì¡°ê¸° í›…: ì˜ë¬´ê°€ ìƒê¸´ planeì— ì¦‰ì‹œ PHASE_HOOKì„ ë°œí–‰í•´ ë°ë“œë¼ì¸ ëŒ€ì‘ë ¥â†‘.

í•„ìš”í•˜ë©´ ìœ„ íë¦„ì„ ì½”ë“œì— ë°˜ì˜í•´ì„œ, propose(ctx) ì‹œê·¸ë‹ˆì²˜ì™€ pop_urgent(now, die, plane, horizon, earliest_start) êµ¬í˜„(í•„í„°ë§ í¬í•¨), precheck(..., start_hint) í™•ì¥ì„ í•œ íŒ¨ì¹˜ ë²„ì „ìœ¼ë¡œ ë°”ë¡œ ë§Œë“¤ì–´ì¤„ê²Œ.

## ğŸ‘¤ User

ì¢‹ì•„. íë¦„ì€ ì´í•´í–ˆì–´. ì•„ë˜ëŠ” ì§€ê¸ˆ ì½”ë“œì—ì„œ ë³´ì™„í•´ì•¼ í•  ì‚¬í•­ì„ ë‚´ê°€ ì •ë¦¬í•œ ê±°ì•¼. ë‹ˆê°€ ë³´ê³ , ì²«ë²ˆì§¸ë¡œ ì¦‰ì‹œ ì‹¤í–‰ ê°€ëŠ¥í•˜ê³  êµ¬ì¡° ë³€ê²½ì ì´ í° ê²ƒì„ ìš°ì„  ìˆœìœ„ë¥¼ ë†’ì´ê³ , ì½”ë“œ ì „ì²´ë¥¼ ë³€ê²½í•´ì•¼ í•˜ëŠ” risk ê°€ í° ê²ƒì„ ìš°ì„  ìˆœìœ„ë¥¼ ë‚®ì¶°ì„œ ì •ë¦¬í•´ì¤˜. ìš°ì„  ìˆœìœ„ê°€ ë‚®ì•„ë³´ì´ë”ë¼ë„, í•„ìˆ˜ì ìœ¼ë¡œ ê°œì„ í•´ì•¼í•˜ëŠ” ì‘ì—…ì€ ìš°ì„  ìˆœìœ„ë¥¼ ë†’ì—¬ì„œ ì •ë¦¬í•˜ê³ , ì •ë¦¬ëœ ê²ƒì„ todo list ë¡œ ë§Œë“¤ê³  ìŠ¤í… ë°”ì´ ìŠ¤í…ìœ¼ë¡œ ì‹¤í–‰í•˜ì.
## ë³´ì™„ ì‚¬í•­
- BusySlot ì€ ì™œ ë§Œë“¤ì—ˆëŠ”ì§€ í™•ì¸ í•„ìš”
- observe_states ì—ì„œ íŠ¹ì • die, plane ì— ëŒ€í•´ì„œ ratio êµ¬í•˜ëŠ” ë°©ì‹ì´ ë§ëŠ”ì§€ ê²€í†  í•„ìš”
- CFG->op_specs->hooks->states ëŠ” phase ë³„ë¡œ ì ìš©í•  ê²ƒì„ ëª…ì‹œí•˜ê³  ìˆìœ¼ë‚˜, ì¼ê´„ì ìœ¼ë¡œ phase ë‹¹ 3ê°œë¡œ ê³ ìš”í•´ì„œ ë‹¨ìˆœí•˜ê²Œ ì •ë¦¬ í•„ìš”
- addr.observe_states(hook.die, hook.plane) ì—ì„œ ì‹œê°„ ì •ë³´ ì¶”ê°€ í•„ìš”. pgmable_ration, readalbe_ratio, local_plane_frac ë“±ë„ í˜„ì¬ ì‹œê°„ì— ë§ì¶° ì—…ë°ì´íŠ¸ ë¼ì•¼ í•œë‹¤.
- addr.select(kind, die, plane) ì—ì„œ multi-plane operation ì‹œ List[Address] í˜•íƒœë¡œ ë°˜í™˜ í•„ìš”
- precheck í•¨ìˆ˜ êµ¬í˜„ í•„ìš”
- obligation ìœ¼ë¡œ ë§Œë“¤ì–´ì§„ operation ì€ ì¢…ë¥˜ì— ë”°ë¼ì„œ op.targets ì—ì„œ ì—°ì‚°í•˜ëŠ” ë¡œì§ êµ¬í˜„ í•„ìš”. sequential read/pgm ëŠ” page address + 1 , cache read ì˜ ê²½ìš°ì— ìˆœì„œìƒ cache read ê°€ ë¨¼ì € ë‚˜ì˜¤ê³  dout ì´ ë‚˜ì¤‘ì¸ë°, dout ì˜ address ëŠ” cache read ì˜ address -1 ì´ë‹¤.
- _schedule_operation -> addr.reserve(die,plane,start,end) ì‹œì— operation ì— ë”°ë¼ì„œ erase/pgm/multi-plane operation ì˜ ê²½ìš° í•´ë‹¹ë˜ëŠ” plane ëª¨ë‘ reserve ì²˜ë¦¬ í•„ìš”
- policy operation ì˜ ì„ íƒì€ weight ë³´ë‹¤ëŠ” ì •í•´ì§„ operation.phase ì¡°ê±´ í•˜ì˜ operation í™•ë¥  weight ê°’ì„ ë°›ì•„ì™€ì„œ random choice í•´ì•¼í•¨.
- policy ì™€ obligation ì˜ ìš°ì„  ìˆœìœ„ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë¡œì§ êµ¬í˜„ í•„ìš”. í˜„ì¬ëŠ” obl.pop_urget(sch.now) ëŠ” êµ¬í˜„ì—†ì´ ì¡°ê±´ obl.heappop ì„ í•˜ê²Œ ë¼ìˆìŒ
- op.movable ì´ ì •ë§ í•„ìš”í•œì§€ ê²€í† 
- ë‘ ê°œ ì´ìƒì˜ operation ì„ ìˆœì°¨ì ìœ¼ë¡œ ì˜ˆì•½í•˜ëŠ” ê²½ìš° ì²˜ë¦¬ ë¡œì§ ì–´ëŠ ë‹¨ê³„ì—ì„œ êµ¬í˜„í•  ì§€ ê²€í† . addr.precheck ë§Œìœ¼ë¡œ ì¶©ë¶„í•œì§€ ê´€ì 
  - sequential read/program ì´ ì˜ˆì•½ëœ ê²½ìš°, ë™ì¼ block ìƒì— erase/program/read ëŠ” ê¸ˆì§€í•´ì•¼ í•œë‹¤.
  - obligation ì´ heap ì— ì—¬ëŸ¬ê°œ ìŒ“ì—¬ ìˆì„ ê²½ìš°, ì–´ëŠ obligation ë¶€í„° êº¼ë‚¼ì§€ ë¡œì§ êµ¬í˜„ í•„ìš”. í˜„ì¬ëŠ” deadline ê¸°ì¤€ìœ¼ë¡œ ì •ë ¬ì´ ë˜ê³ , obligation ì‚¬ì´ì— dependency check í•„ìš”í•œì§€ ì—¬ë¶€ ê²€í†  í•„ìš”
- make_phase_hooks ìœ¼ë¡œ 'PHASE_HOOK' event push í•  ë–„ pattern time resolution ê³ ë ¤ time sampling í•„ìš”
- plane interleave read ë¥¼ ë§Œë“¤ê¸° ìœ„í•´ì„œ, ìŠ¤ì¼€ì¥´ëŸ¬ê°€ ê°œì…ì„ í•˜ëŠ” ê²ƒì´ í•„ìš”í•œì§€ ê²€í† 
- obligation, policy operation ê°„ì— addr.select ë¥¼ ì“°ê³  ì•ˆì“°ê³  ì •í•´ì§€ëŠ”ë°, í†µí•©í•´ì•¼ í•  í•„ìš”ì„±? obligation ì€ source  operation ì˜ targets ìƒì†ë°›ëŠ” í˜•ì‹ì´ì§€ë§Œ, addr.select ëŠ” ìƒ˜í”Œë§ í•˜ëŠ” ë°©ì‹
- make_phase_hooks(op, start, sch.cfg["op_specs"][op.kind.name], die, plane) ì—ì„œ op ë¥¼ ë„˜ê²¨ì¤Œì—ë„ ë³„ë„ë¡œ sch.cfg["op_specs"][op.kind.name] ì„ ë„˜ê²¨ì£¼ê³  ìˆë‹¤. í†µí•© ê°€ëŠ¥í•œì§€ ê²€í† 
- sch._schedule_operation ì—ì„œ dur ê³„ì‚° ë¡œì§ ìˆ˜ì • í•„ìš”. StateSeq, Operation clss êµ¬í˜„ê³¼ ì—°ê²°ë¨. Stateseq.times ëŠ” ì ˆëŒ€ê°’ì„ ì €ì¥í•˜ë¯€ë¡œ ë§ˆì§€ë§‰ ê°’ë§Œ ì¶”ì¶œí•´ì„œ ì‚¬ìš©ê°€ëŠ¥. í•˜ì§€ë§Œ, í˜„ì¬ êµ¬í˜„ìƒ times ì— ì €ì¥ë˜ëŠ” ê°’ì€ state ì˜ ëë‚˜ëŠ” ì‹œê°„ì´ ì €ì¥ë¨. ê·¸ë¦¬ê³  operation ì´ ëë‚œ í›„ëŠ” state ê°€ ë‹¤ë¥¸ operation ì´ ìˆ˜í–‰ë˜ê¸° ì „ê¹Œì§€ ë¬´í•œíˆ ìœ ì§€ë˜ë¯€ë¡œ times ì˜ ë§ˆì§€ë§‰ ê°’ì€ 10ms ì˜ ë§¤ìš° í° ê°’ì´ ì €ì¥ë¼ ìˆìŒ 
  - @dataclass<br>
  class StateSeq<br>
  times: List[float]<br>
  states: List[str]<br>
  id: int<br>

## ğŸ¤– Assistant

ì¢‹ì•„. ì•„ë˜ëŠ” **â€œpropose ê±°ì ˆë¥  ìµœì†Œí™”â€**ë¥¼ ìµœìš°ì„  ëª©í‘œë¡œ í•œ ìš°ì„ ìˆœìœ„í™”ëœ To-Do ë¦¬ìŠ¤íŠ¸ì™€, ì¦‰ì‹œ ì ìš© ê°€ëŠ¥í•œ íŒ¨ì¹˜ ìŠ¤í…ì´ì•¼.  

ì›ì¹™: ë°”ë¡œ ì‹¤í–‰ ê°€ëŠ¥ + êµ¬ì¡°ì  ì´ë“ í° ê²ƒ = ìƒìœ„, ì½”ë“œ ì „ë°˜ ë¦¬ìŠ¤í¬ í° ê²ƒ = í•˜ìœ„. ë‹¨, í•„ìˆ˜ ê°œì„ ì€ ìƒìœ„ë¡œ ëŒì–´ì˜¬ë¦¼.

âœ… ìš°ì„ ìˆœìœ„ë³„ To-Do
P0 â€” ì§€ê¸ˆ ì ìš© (êµ¬ì¡° ê°œì„  í¬ê³ , ê±°ì ˆë¥ â†“ íš¨ê³¼ í¼ / ë¦¬ìŠ¤í¬ ë‚®ìŒ)
1. propose ì‹œê·¸ë‹ˆì²˜ í™•ì¥ + í˜¸ì¶œ ì»¨í…ìŠ¤íŠ¸ ì •ê·œí™”
  - earliest_start(= AddressManager.available_at)ë¥¼ propose(...)ì— ì „ë‹¬í•´ precheckê°€ â€œì§€ê¸ˆì´ ì•„ë‹ˆë¼ ì‹¤ì œ ì‹œì‘ê°€ëŠ¥ ì‹œì â€ ê¸°ì¤€ìœ¼ë¡œ íŒë‹¨.
  - Schedulerì˜ PHASE_HOOK ì²˜ë¦¬ ê²½ë¡œì—ì„œ observe_states(now), available_atì„ ìˆ˜ì§‘í•´ í•¨ê»˜ ì „ë‹¬.
2. ObligationManager.pop_urgentë¥¼ plane/ì‹œê°„ ì œì•½ìœ¼ë¡œ í•„í„°ë§
  - ë‹¨ìˆœ heappop ì œê±°. (die, plane) ì¼ì¹˜ + earliest_startë¡œ ì‹œì‘í•´ë„ ë°ë“œë¼ì¸ ë§Œì¡± ê°€ëŠ¥í•œ ì˜ë¬´ë§Œ ë°˜ë‚©.
  - ë‹¤ìˆ˜ì¼ ê²½ìš° ê°€ì¥ ì„ë°•í•œ ë°ë“œë¼ì¸ ìš°ì„ .
3. AddressManager.precheck ì‹¤êµ¬í˜„ (ìµœì†Œ ìœ íš¨ì„±)
  - (die, plane) ì˜ˆì•½ì°½ê³¼ ì‹œê°„ ê²¹ì¹¨ ê¸ˆì§€.
  - block ë‹¨ìœ„ ì¶©ëŒ ë£°(ì˜ˆ: ê°™ì€ blockì— ERASEâ†”PROGRAM/READ ë™ì‹œ ê¸ˆì§€) ìµœì†Œí™” ê·œì¹™.
  - start_hint(= earliest_start) ê¸°ë°˜ ê²€ì‚¬.
4. AddressManager.reserveë¥¼ ë‹¤ì¤‘ plane ì§€ì›
  - Operation.targetsì˜ ì¤‘ë³µ ì—†ëŠ” (die, plane) ì§‘í•© ì „ì²´ì— ì˜ˆì•½ ë°˜ì˜.
  - Schedulerì—ì„œ op.targets ì „ì²´ë¥¼ ì˜ˆì•½.
5. observe_states(now)ë¡œ ì‹œê° ê¸°ë°˜ ìŠ¤ëƒ…ìƒ·
  - ì‹œê·¸ë‹ˆì²˜ì— now ì¶”ê°€, ë²„í‚·ë§ ë¡œì§ì„ nowë¥¼ ë°›ì•„ ê°±ì‹ (ìŠ¤í…ì´ì–´ë„ í˜•íƒœ í†µì¼).
6. ì˜ë¬´(Obligation) ìš°ì„ ìˆœìœ„ ì²˜ë¦¬ ê·œì¹™ ê³ ì •
  - proposeì—ì„œ ì˜ë¬´ ìš°ì„  â†’ ì •ì±… í›„ë³´ ìˆœ.
  - ì˜ë¬´ ë¶ˆê°€(ì‚¬ì „ê²€ì‚¬ ì‹¤íŒ¨) ì‹œ ëŒ€ì²´ íƒ€ê²Ÿ ì¬ì‹œë„ í›„ì—ë§Œ ì •ì±… í›„ë³´ë¡œ ë„˜ì–´ê°.

P1 â€” ë‹¤ìŒ ë‹¨ê³„ (ê±°ì ˆë¥ â†“/íŠœë‹ë ¥â†‘, ë¦¬ìŠ¤í¬ ë³´í†µ)
7. Hook ì‹œê°„ ì–‘ìí™”(Resolution) ë„ì…
  - PHASE_HOOK ìƒì„± ì‹œ **ì‹œë®¬ë ˆì´í„° í•´ìƒë„(ì˜ˆ: 0.01us)**ë¡œ quantize(time) ì²˜ë¦¬ â†’ ì¤‘ë³µ/ê²½í•© ì™„í™”.
8. Policy ê°€ì¤‘ ì„ íƒì„ â€œphase-ì¡°ê±´í™” weightâ€ë¡œ ë‹¨ìˆœí™”
  - ì§€ê¸ˆì€ ì—¬ëŸ¬ ê°€ì¤‘ì„ ê³±í•˜ëŠ” êµ¬ì¡°. phase_labelì— ì§ì ‘ ëŒ€ì‘í•˜ëŠ” ì‚¬ì „ ê³„ì‚° weight í…Œì´ë¸”(START/MID/END)ì„ ì‚¬ìš©í•´ ìƒ˜í”Œ/ì„¤ëª… ìš©ì´ì„±â†‘.
9. AddressManager.selectì˜ ë‹¤ì¤‘ plane/ì¸í„°ë¦¬ë¸Œ ì„ íƒ ìŠ¤í™
  - ë°˜í™˜í˜•ì„ List[Address]ë¡œ ê³ ì •í•˜ê³ , fanout/interleave ì˜µì…˜(ê¸°ë³¸ 1) ì¶”ê°€.
  - ì •ì±…/ì˜ë¬´ ëª¨ë‘ ë™ì¼ ì¸í„°í˜ì´ìŠ¤ë¡œ ì‚¬ìš©.
10. Scheduler._schedule_operationì˜ duration ê³„ì‚°ì„ ë˜í¼ë¡œ ì¼ì›í™”

- get_op_duration(op) ì¶”ê°€:
  - í˜„ì¬(ìƒëŒ€ duration í•©) ë°©ì‹ ì§€ì›
  - í–¥í›„ StateSeq.times(ì ˆëŒ€)ë¡œ ì „í™˜ ì‹œë„ ì‹œì—ë„ wrapper êµì²´ë§Œìœ¼ë¡œ ëŒ€ì‘.

11. ObligationManager ë‹¤ê±´ ì²˜ë¦¬ ì •ì±… êµ¬ì²´í™”

- ë™ì¼ planeì—ì„œ ë‹¤ìˆ˜ ì˜ë¬´ â†’ ë°ë“œë¼ì¸ ìš°ì„ , ë™ë¥  ì‹œ ë°œê¸‰ ìˆœì„œ.
- ì˜µì…˜: horizon ë‚´ ë¯¸ì„ë°• ì˜ë¬´ëŠ” ë³´ë¥˜.

12. make_phase_hooks API í†µì¼

- op.kindë¡œ cfgë¥¼ ì°¾ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ, ì¸ìì—ì„œ ì¤‘ë³µ cfg ì œê±°(ë‚´ë¶€ì—ì„œ ì°¸ì¡°) â€” í›„ë°©í˜¸í™˜ ìœ ì§€.

P2 â€” ì´í›„ (ìµœì í™”/ë¦¬í¬íŒ…, ë¦¬ìŠ¤í¬ ë‚®ìŒ)
13. BusySlot ì˜ë¯¸ ë¶€ì—¬(ë˜ëŠ” ì‚­ì œ)

- ìœ ì§€ ì‹œ: plane utilization/ê²¹ì¹¨ ë””ë²„ê¹…/ë¦¬í¬íŠ¸ì— ì‚¬ìš©.
- ë¯¸ì‚¬ìš©ì´ë©´ ì œê±°.

14. plane interleave READ ìµœì í™”(ìŠ¤ì¼€ì¤„ëŸ¬ ê°œì…)

- Look-ahead ìœˆë„ì—ì„œ READ ì „ì§„/ë¶„ì‚°(ê±°ì ˆë¥ ì— ì§ì ‘ ì˜í–¥ì€ ì ì–´ í›„ìˆœìœ„).

15. op.movable ì¬ê²€í† 

- ì¬ë°°ì¹˜ê°€ ì—†ëŠ” í•œ ë‹¹ì¥ í•„ìš” X. í›„ì† ìµœì í™” ë‹¨ê³„ì—ì„œ ë°˜ì˜.

ğŸ› ï¸ P0 íŒ¨ì¹˜ â€” ì¦‰ì‹œ ì ìš© ìŠ¤í… & ì½”ë“œ ì¡°ê°
ì•„ë˜ ì¡°ê°ì€ ë„¤ê°€ ë§Œë“  nandsim_demo.py ê¸°ì¤€ìœ¼ë¡œ ë¶€ë¶„ ì¹˜í™˜í•˜ë©´ ë¼.
(1) observe_states/available_at/ì»¨í…ìŠ¤íŠ¸ â†’ propose ì „ë‹¬
Scheduler (PHASE_HOOK ì²˜ë¦¬ë¶€)

```python
# before:
# global_state, local_state = self.addr.observe_states(hook.die, hook.plane)
# op = self.SPE.propose(self.now, hook, global_state, local_state)

# after:
earliest_start = self.addr.available_at(hook.die, hook.plane)
global_state, local_state = self.addr.observe_states(hook.die, hook.plane, self.now)
op = self.SPE.propose(self.now, hook, global_state, local_state, earliest_start)

```

AddressManager.observe_states ì‹œê·¸ë‹ˆì²˜

```python
def observe_states(self, die:int, plane:int, now_us: float):
    # ë²„í‚· ê³„ì‚°ì— now_usë¥¼ í™œìš©(ë°ëª¨ì—ì„  ë³´ì •ë§Œ)
    prog = len(self.programmed[(die,plane)])
    pgmable_ratio  = "mid" if prog < 10 else "low"
    readable_ratio = "mid" if prog > 0 else "low"
    plane_busy_frac = "low"  # TODO: ì˜ˆì•½ í…Œì´ë¸” ê¸°ë°˜ìœ¼ë¡œ ê³„ì‚° ê°€ëŠ¥
    return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls": "host"},
            {"plane_busy_frac": plane_busy_frac})

```

(2) PolicyEngine.propose ì‹œê·¸ë‹ˆì²˜ í™•ì¥ + ì˜ë¬´ ìš°ì„  + precheck
ì‹œê·¸ë‹ˆì²˜ ë³€ê²½

```python
def propose(self, now_us: float, hook: PhaseHook,
            global_state: Dict[str,str], local_state: Dict[str,str],
            earliest_start: float) -> Optional[Operation]:

```

ì˜ë¬´ ìš°ì„  + precheck ì ìš©

```python
# ì˜ë¬´ ìš°ì„  (plane/ì‹œê°„ í•„í„° ì ìš©ëœ pop_urgent ì‚¬ìš©)
ob = self.obl.pop_urgent(now_us, hook.die, hook.plane,
                         horizon_us=5.0, earliest_start=earliest_start)
if ob:
    if self.addr.precheck(ob.require, ob.targets, start_hint=earliest_start):
        cfg_op = self.cfg["op_specs"][ob.require.name]
        op = build_operation(ob.require, cfg_op, ob.targets)
        op.meta["source"]="obligation"
        return op
    # ì˜ë¬´ íƒ€ê²Ÿ ì¬ì‹œë„ ë¡œì§(ì„ íƒ): ì´ ë°ëª¨ì—ì„  ìƒëµ -> ì¼ë°˜ í›„ë³´ë¡œ ì „í™˜

```

ì •ì±… í›„ë³´ì—ë„ precheck

```python
targets = self.addr.select(kind, hook.die, hook.plane)  # ì´í›„ P1ì—ì„œ fanout ì˜µì…˜ ì¶”ê°€
if not targets: return None
if not self.addr.precheck(kind, targets, start_hint=earliest_start):
    return None
op = build_operation(kind, self.cfg["op_specs"][pick], targets)
op.meta["source"]="policy"
return op

```

(3) ObligationManager.pop_urgent êµ¬í˜„(í•„í„°ë§ í¬í•¨)

```python
def pop_urgent(self, now_us: float, die:int, plane:int,
               horizon_us: float, earliest_start: float) -> Optional[Obligation]:
    # ê°€ì¥ ì´ë¥¸ ë°ë“œë¼ì¸ë¶€í„° ìŠ¤ìº”(í•„í„° ì¡°ê±´ ë§Œì¡± ì‹œ pop)
    kept = []
    chosen = None
    while self.heap and not chosen:
        item = heapq.heappop(self.heap)
        ob = item.ob
        # 1) plane ì¼ì¹˜
        tgt = ob.targets[0]
        if tgt.die != die or tgt.plane != plane:
            kept.append(item); continue
        # 2) horizon ë‚´ ë˜ëŠ” ë‹¨ìˆœíˆ í•­ìƒ ê³ ë ¤(ë°ëª¨: horizon ì²´í¬)
        if (ob.deadline_us - now_us) > max(horizon_us, 0.0):
            kept.append(item); continue
        # 3) earliest_startë¡œ ì‹œì‘í•´ë„ ë°ë“œë¼ì¸ì„ ì•„ì£¼ ëŒ€ëµ ë§Œì¡±í•  ìˆ˜ ìˆëŠ”ì§€(ë³´ìˆ˜ì ìœ¼ë¡œ í†µê³¼)
        if earliest_start <= ob.deadline_us:
            chosen = ob
        else:
            # ì´ë¯¸ ëŠ¦ì—ˆë‹¤ë©´ ìŠ¤í‚µ(ì‹¤ì‹œìŠ¤í…œì€ ì¬ê³„íš/í˜ë„í‹°)
            continue
    # ë‚¨ì€ ê²ƒ ë³µì›
    for it in kept:
        heapq.heappush(self.heap, it)
    return chosen

```

(4) AddressManager.precheck + ì˜ˆì•½ í…Œì´ë¸” + ë‹¤ì¤‘ plane ì˜ˆì•½
ìƒíƒœ ë³´ê´€ í•„ë“œ ì¶”ê°€

```python
class AddressManager:
    def __init__(...):
        ...
        self.resv = {(0,p): [] for p in range(self.planes)}  # [(start,end,block)]

```

precheck êµ¬í˜„

```python
def precheck(self, kind: OpKind, targets: List[Address], start_hint: float) -> bool:
    # 1) ì‹œê°„ ê²¹ì¹¨ ê²€ì‚¬
    #    ë‹¨ìˆœ: ëª¨ë“  ëŒ€ìƒ planeì— ëŒ€í•´ (start_hint, start_hint+min_guard) ì°½ì´ ê¸°ì¡´ ì˜ˆì•½ê³¼ ê²¹ì¹˜ì§€ ì•Šë„ë¡
    MIN_GUARD = 0.0  # ë°ëª¨: 0, ì‹¤ì„œë¹„ìŠ¤: opë³„ ì˜ˆë¹„ì‹œê°„
    end_hint = start_hint + MIN_GUARD
    seen = set()
    for t in targets:
        key = (t.die, t.plane)
        if key in seen: continue
        seen.add(key)
        for (s,e,b) in self.resv[key]:
            if not (end_hint <= s or e <= start_hint):
                return False
    # 2) block ì¶©ëŒ ë£°(ì˜ˆ: ê°™ì€ blockì— ERASEì™€ READ/PROGRAM ë™ì‹œ ê¸ˆì§€)
    #    ë°ëª¨: ê°„ë‹¨íˆ í†µê³¼
    return True

```

reserve ë‹¤ì¤‘ plane ë°˜ì˜ & commit ê·¸ëŒ€ë¡œ

```python
def reserve(self, die:int, plane:int, start:float, end:float, block:int=None):
    self.available[(die,plane)] = max(self.available[(die,plane)], end)
    self.resv[(die,plane)].append((start, end, block))

# Scheduler._schedule_operationì—ì„œ targets ì „ì²´ ì˜ˆì•½
# before:
# self.addr.reserve(die, plane, start, end)
# after:
for t in { (a.die, a.plane, a.block) for a in op.targets }:
    self.addr.reserve(t[0], t[1], start, end, block=t[2])

```

(5) observe_states(now) ì ìš©ìœ¼ë¡œ í˜¸ì¶œë¶€ ì¼ê´€í™”
- ìœ„ (1)ì—ì„œ ì ìš©í•œ ëŒ€ë¡œ ëª¨ë“  PHASE_HOOK ê²½ë¡œê°€ ë™ì¼ ì»¨í…ìŠ¤íŠ¸ë¥¼ ê°–ê²Œ ë¨.

â–¶ ì‹¤í–‰ ìˆœì„œ (Step-by-Step)
1. Scheduler â†’ PHASE_HOOK ì²˜ë¦¬ë¶€ì— earliest_start/now ë°˜ì˜ ë° propose ì‹œê·¸ë‹ˆì²˜ ì—…ë°ì´íŠ¸.
2. PolicyEngine.proposeì— ì˜ë¬´ ìš°ì„  + precheck ë„ì…(ìœ„ ì½”ë“œ ì¡°ê°).
3. ObligationManager.pop_urgentë¥¼ í•„í„°ë§ ë²„ì „ìœ¼ë¡œ êµì²´.
4. AddressManagerì— resv í…Œì´ë¸” ì¶”ê°€ â†’ precheck/reserve êµ¬í˜„ â†’ ë‹¤ì¤‘ plane ì˜ˆì•½ìœ¼ë¡œ ìŠ¤ì¼€ì¤„ëŸ¬ ìˆ˜ì •.
5. **AddressManager.observe_states(now)`**ë¡œ ì‹œê·¸ë‹ˆì²˜ í†µì¼.
6. ë¡œê¹…: propose ê²°ê³¼ê°€ Noneì¸ ë¹„ìœ¨(í›… ëŒ€ë¹„) ì²´í¬ â†’ ê±°ì ˆë¥ /ë¬´ìŠ¤ì¼€ì¤„ë¥  ì§€í‘œ ì¶”ê°€(ê°„ë‹¨íˆ ì¹´ìš´í„°ë§Œ).

ì—¬ê¸°ê¹Œì§€ê°€ P0 íŒ¨ì¹˜. ì´ ìƒíƒœì—ì„œ **ê±°ì ˆë¥ (=precheck ì‹¤íŒ¨ë¡œ ìŠ¤ì¼€ì¤„ ë¶ˆê°€)**ì´ ìœ ì˜ë¯¸í•˜ê²Œ ë–¨ì–´ì ¸ì•¼ í•œë‹¤.

(ì°¸ê³ ) P1ì—ì„œ ë°”ë¡œ ë¶™ì¼ ì‘ì€ ì¡°ê°
Hook ì‹œê°„ ì–‘ìí™”

```python
SIM_RES_US = 0.01
def quantize(t): 
    return round(t / SIM_RES_US) * SIM_RES_US

# make_phase_hooks(...) ëì—ì„œ:
h.time_us = quantize(h.time_us)

```

duration ë˜í¼

```python
def get_op_duration(op: Operation) -> float:
    # í˜„ì¬ êµ¬ì¡°: ìƒëŒ€ duration í•©
    return sum(seg.dur_us for seg in op.states)
# Scheduler._schedule_operationì—ì„œ dur ê³„ì‚° êµì²´
dur = get_op_duration(op)

```

í•„ìš”í•˜ë©´ ìœ„ íŒ¨ì¹˜ë“¤ì„ ë‚´ê°€ ì¤€ ë‹¨ì¼ íŒŒì¼ ë°ëª¨ì— ë¶™ì¸ í†µí•©ë³¸ìœ¼ë¡œ ë§Œë“¤ì–´ ì¤„ ìˆ˜ ìˆì–´. ë‹¤ìŒ í„´ì—ì„œ ì›í•˜ë©´ ë°”ë¡œ í•©ì³ì„œ ì „ë‹¬í• ê²Œ.

## ğŸ‘¤ User

í†µí•©ë³¸ ë§Œë“¤ì–´ì¤˜

## ğŸ¤– Assistant

ì•„ë˜ëŠ” P0 íŒ¨ì¹˜ê°€ ëª¨ë‘ ë°˜ì˜ëœ ë‹¨ì¼ íŒŒì¼ í†µí•©ë³¸ì´ì—ìš”.
- propose(...)ì— earliest_start ì „ë‹¬
- observe_states(die, plane, now) ì‹œê·¸ë‹ˆì²˜ ë°˜ì˜
- ObligationManager.pop_urgent(...)ê°€ die/plane/ì‹œê°„ ì¡°ê±´ìœ¼ë¡œ í•„í„°
- AddressManager.precheck(...) ì‹¤êµ¬í˜„(ì‹œê°„ ê²¹ì¹¨/ê°„ë‹¨ ì¶©ëŒ ë£°)
- AddressManager.reserve(...)ê°€ ë‹¤ì¤‘ plane ì˜ˆì•½ ë°˜ì˜
- Scheduler._schedule_operation(...)ì´ op.targets ì „ì²´ ê¸°ì¤€ìœ¼ë¡œ ì˜ˆì•½/í›… ìƒì„±
- ì˜ë¬´(Obligation) ìš°ì„  â†’ ì •ì±… í›„ë³´ ìˆœìœ¼ë¡œ ì²˜ë¦¬
- ë§ˆì§€ë§‰ì— ìŠ¤ì¼€ì¤„ í†µê³„(ì œì•ˆ/ì„±ê³µ) ë¡œê·¸ ì¶œë ¥

íŒŒì¼ëª… ì˜ˆ: nandsim_demo_p0.py

```python
# nandsim_demo_p0.py â€” P0 í†µí•©ë³¸ (stdlib-only)
# - Event-jump Scheduler
# - Phase Hook ìƒì„±(ìŠ¤ì¼€ì¤„ëŸ¬)
# - PolicyEngine with earliest_start + precheck
# - Obligation (READ -> DOUT) with plane/time filtering
# - AddressManager: state snapshot(now), precheck/reserve with multi-plane
# - ê°„ë‹¨ í†µê³„: propose calls / scheduled ops

from __future__ import annotations
import heapq, random
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple, Set

# ---------------------------- Config ----------------------------

CFG = {
    "rng_seed": 12345,
    "policy": {
        "queue_refill_period_us": 3.0,
        "lookahead_k": 4,
        "run_until_us": 150.0,
    },
    "weights": {
        "base": {  # class=host only for demo
            "host": {
                "READ": 0.85,
                "PROGRAM": 0.10,
                "ERASE": 0.05,
                "SR": 0.00,
                "RESET": 0.00,
                "DOUT": 0.00,  # obligation-driven only
            }
        },
        "g_state": {  # very light demo weights
            "pgmable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.8},
            "readable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.9},
        },
        "g_local": {"plane_busy_frac": {"low": 1.2, "mid": 1.0, "high": 0.9}},
        "g_phase": {
            "READ": {"START_NEAR": 1.2, "MID_NEAR": 0.9, "END_NEAR": 1.2},
            "PROGRAM": {"START_NEAR": 1.1, "MID_NEAR": 1.0, "END_NEAR": 0.9},
            "ERASE": {"START_NEAR": 0.9, "MID_NEAR": 1.1, "END_NEAR": 1.1},
            "SR": {"START_NEAR": 1.0, "MID_NEAR": 1.0, "END_NEAR": 1.0},
            "RESET": {"START_NEAR": 1.0, "MID_NEAR": 1.0, "END_NEAR": 1.0},
        },
    },
    "mixture": {"classes": {"host": 1.0}},  # host-only for demo
    "op_specs": {
        "READ": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 8.0, "std": 1.5, "min": 2.0}},
                {"name": "DATA_OUT", "dist": {"kind": "normal", "mean": 2.0, "std": 0.4, "min": 0.5}},
            ],
            "hooks": [
                {"when": "STATE_START", "states": ["ISSUE", "CORE_BUSY", "DATA_OUT"], "jitter_us": 0.1},
                {"when": "STATE_MID", "states": ["CORE_BUSY"], "jitter_us": 0.2},
                {"when": "STATE_END", "states": ["DATA_OUT"], "jitter_us": 0.1},
            ],
            "phase_offset_us": {"default": 0.0},
        },
        "DOUT": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.2}},
                {"name": "DATA_OUT", "dist": {"kind": "normal", "mean": 1.0, "std": 0.2, "min": 0.2}},
            ],
            "hooks": [
                {"when": "STATE_START", "states": ["DATA_OUT"], "jitter_us": 0.05},
                {"when": "STATE_END", "states": ["DATA_OUT"], "jitter_us": 0.05},
            ],
            "phase_offset_us": {"default": 0.0},
        },
        "PROGRAM": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 20.0, "std": 3.0, "min": 8.0}},
            ],
            "hooks": [{"when": "STATE_END", "states": ["CORE_BUSY"], "jitter_us": 0.2}],
            "phase_offset_us": {"default": 0.0},
        },
        "ERASE": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 40.0, "std": 5.0, "min": 15.0}},
            ],
            "hooks": [{"when": "STATE_END", "states": ["CORE_BUSY"], "jitter_us": 0.2}],
            "phase_offset_us": {"default": 0.0},
        },
    },
    "obligations": [
        {
            "issuer": "READ",
            "require": "DOUT",
            "window_us": {"kind": "normal", "mean": 6.0, "std": 1.5, "min": 1.0},
            "priority_boost": {"start_us_before_deadline": 2.5, "boost_factor": 2.0, "hard_slot": True},
        }
    ],
    "priority": {
        "order": ["HOST", "READ", "DOUT", "ERASE", "PROGRAM_NEW", "PROGRAM_TARGET", "SR", "RESET"],
        "starvation_aging_alpha": 0.01,
    },
    "topology": {"dies": 1, "planes_per_die": 2, "blocks_per_plane": 4, "pages_per_block": 16},
}

# ---------------------------- Models ----------------------------

class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)

@dataclass
class BusySlot:
    start_us: float
    end_us: float
    op: Operation

def _addr_str(a: Address)->str:
    return f"(d{a.die},p{a.plane},b{a.block},pg{a.page})"

# ---------------------------- Utility: Distributions ----------------------------

def sample_dist(d: Dict[str, Any]) -> float:
    k = d["kind"]
    if k == "fixed":
        return float(d["value"])
    if k == "normal":
        m, s = d["mean"], d["std"]
        mn = d.get("min", 0.0)
        v = random.gauss(m, s)
        return max(v, mn)
    if k == "exp":
        lam = d["lambda"]
        return random.expovariate(lam)
    raise ValueError(f"unknown dist kind: {k}")

def rand_jitter(ampl_us: float) -> float:
    if ampl_us<=0: return 0.0
    return random.uniform(-ampl_us, ampl_us)

# ---------------------------- OpSpec: build ops & hooks ----------------------------

def build_operation(kind: OpKind, cfg_op: Dict[str, Any], targets: List[Address]) -> Operation:
    states=[]
    for s in cfg_op["states"]:
        dur = sample_dist(s["dist"])
        states.append(StateSeg(name=s["name"], dur_us=dur))
    return Operation(kind=kind, targets=targets, states=states)

def make_phase_hooks(op: Operation, start_us: float, cfg_op: Dict[str, Any], die:int, plane:int) -> List[PhaseHook]:
    hooks_cfg = cfg_op.get("hooks", [])
    offset = cfg_op.get("phase_offset_us",{}).get("default",0.0)
    base_t = start_us + offset
    hooks=[]
    cur = base_t
    for seg in op.states:
        seg_start = cur
        seg_mid   = cur + seg.dur_us*0.5
        seg_end   = cur + seg.dur_us
        for rule in hooks_cfg:
            if seg.name not in rule["states"]:
                continue
            jitter = rule.get("jitter_us", 0.0)
            if rule["when"]=="STATE_START":
                hooks.append(PhaseHook(time_us=seg_start + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.START", die=die, plane=plane))
            elif rule["when"]=="STATE_MID":
                hooks.append(PhaseHook(time_us=seg_mid   + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.MID",   die=die, plane=plane))
            elif rule["when"]=="STATE_END":
                hooks.append(PhaseHook(time_us=seg_end   + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.END",   die=die, plane=plane))
        cur = seg_end
    return hooks

# ---------------------------- Address Manager ----------------------------

class AddressManager:
    def __init__(self, cfg: Dict[str, Any]):
        topo = cfg["topology"]
        self.dies = topo["dies"]
        self.planes = topo["planes_per_die"]
        # plane availability absolute times
        self.available: Dict[Tuple[int,int], float] = {(0,p): 0.0 for p in range(self.planes)}
        # rotating cursors per plane
        self.cursors: Dict[Tuple[int,int], List[int]] = {(0,p): [0,0,0] for p in range(self.planes)}  # [block, next_pgm_page, next_rd_page]
        self.pages_per_block = topo["pages_per_block"]
        self.blocks_per_plane = topo["blocks_per_plane"]
        # simplistic programmed set per plane
        self.programmed: Dict[Tuple[int,int], Set[Tuple[int,int]]] = {(0,p): set() for p in range(self.planes)}
        # reservation table per plane: list of (start,end,block)
        self.resv: Dict[Tuple[int,int], List[Tuple[float,float,Optional[int]]]] = {(0,p): [] for p in range(self.planes)}

    # ---- observation / selection / checks ----

    def available_at(self, die:int, plane:int) -> float:
        return self.available[(die,plane)]

    def observe_states(self, die:int, plane:int, now_us: float):
        prog = len(self.programmed[(die,plane)])
        # naive buckets for demo
        pgmable_ratio  = "mid" if prog < 10 else "low"
        readable_ratio = "mid" if prog > 0 else "low"
        plane_busy_frac = "low"  # (could be derived from resv overlap with [now,now+Î”])
        return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls": "host"},
                {"plane_busy_frac": plane_busy_frac})

    def select(self, kind: OpKind, die:int, plane:int) -> List[Address]:
        if kind == OpKind.READ:
            prog = sorted(self.programmed[(die,plane)])
            tgt = prog[0] if prog else (0,0)
            return [Address(die, plane, block=tgt[0], page=tgt[1])]
        if kind == OpKind.DOUT:
            raise RuntimeError("DOUT selection must be provided by obligation targets")
        if kind == OpKind.PROGRAM:
            b, pgm_p, _ = self.cursors[(die,plane)]
            addr = Address(die, plane, block=b, page=pgm_p)
            # advance cursor
            pgm_p += 1
            if pgm_p >= self.pages_per_block:
                pgm_p = 0
                b = (b+1) % self.blocks_per_plane
            self.cursors[(die,plane)] = [b, pgm_p, self.cursors[(die,plane)][2]]
            return [addr]
        if kind == OpKind.ERASE:
            b = self.cursors[(die,plane)][0]
            return [Address(die, plane, block=b, page=None)]
        return [Address(die, plane, block=0, page=0)]

    def precheck(self, kind: OpKind, targets: List[Address], start_hint: float) -> bool:
        """Minimal feasibility check: time overlap + simple block rule."""
        MIN_GUARD = 0.0
        end_hint = start_hint + MIN_GUARD
        # 1) time overlap across all planes in targets
        seen_planes = set()
        for t in targets:
            key = (t.die, t.plane)
            if key in seen_planes: 
                continue
            seen_planes.add(key)
            for (s,e,_) in self.resv[key]:
                if not (end_hint <= s or e <= start_hint):
                    return False
        # 2) simple block rule (placeholder for real dep rules)
        #    forbid ERASE on a block if it's been programmed recently (not tracked here) â€” skip for demo
        return True

    # ---- reserve / commit ----

    def reserve(self, die:int, plane:int, start:float, end:float, block: Optional[int]=None):
        self.available[(die,plane)] = max(self.available[(die,plane)], end)
        self.resv[(die,plane)].append((start, end, block))

    def commit(self, op: Operation):
        t = op.targets[0]
        key = (t.die, t.plane)
        if op.kind == OpKind.PROGRAM and t.page is not None:
            self.programmed[key].add((t.block, t.page))
        elif op.kind == OpKind.ERASE:
            # erase whole block
            self.programmed[key] = {pp for pp in self.programmed[key] if pp[0] != t.block}

# ---------------------------- Obligation Manager ----------------------------

@dataclass(order=True)
class _ObHeapItem:
    deadline_us: float
    seq: int
    ob: "Obligation" = field(compare=False)

@dataclass
class Obligation:
    require: OpKind
    targets: List[Address]
    deadline_us: float
    boost_factor: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg_list: List[Dict[str,Any]]):
        self.specs = cfg_list
        self.heap: List[_ObHeapItem] = []
        self._seq = 0

    def on_commit(self, op: Operation, now_us: float):
        for spec in self.specs:
            if spec["issuer"] == op.kind.name:
                dt = sample_dist(spec["window_us"])
                ob = Obligation(
                    require = OpKind[spec["require"]],
                    targets = op.targets,
                    deadline_us = now_us + dt,
                    boost_factor = spec["priority_boost"]["boost_factor"],
                    hard_slot = spec["priority_boost"].get("hard_slot", False),
                )
                heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=self._seq, ob=ob))
                self._seq += 1
                print(f"[{now_us:7.2f} us] OBLIG  created: {op.kind.name} -> {ob.require.name} by {ob.deadline_us:7.2f} us, target={_addr_str(ob.targets[0])}")

    def pop_urgent(self, now_us: float, die:int, plane:int,
                   horizon_us: float, earliest_start: float) -> Optional[Obligation]:
        """Return earliest-deadline obligation for this (die,plane) that we still can start by earliest_start."""
        if not self.heap: 
            return None
        kept: List[_ObHeapItem] = []
        chosen: Optional[Obligation] = None
        while self.heap and not chosen:
            item = heapq.heappop(self.heap)
            ob = item.ob
            tgt = ob.targets[0]
            same_plane = (tgt.die == die and tgt.plane == plane)
            in_horizon = ((ob.deadline_us - now_us) <= max(horizon_us, 0.0))
            feasible_time = (earliest_start <= ob.deadline_us)  # coarse feasibility
            if same_plane and in_horizon and feasible_time:
                chosen = ob
                break
            kept.append(item)
        for it in kept:
            heapq.heappush(self.heap, it)
        return chosen

# ---------------------------- Policy Engine ----------------------------

class PolicyEngine:
    def __init__(self, cfg, addr_mgr: AddressManager, obl_mgr: ObligationManager):
        self.cfg = cfg
        self.addr = addr_mgr
        self.obl = obl_mgr

    def _score(self, op_name: str, phase_label: str, global_state: Dict[str,str], local_state: Dict[str,str]) -> float:
        w = self.cfg["weights"]["base"]["host"].get(op_name, 0.0)
        w *= self.cfg["weights"]["g_state"]["pgmable_ratio"].get(global_state["pgmable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_state"]["readable_ratio"].get(global_state["readable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_local"]["plane_busy_frac"].get(local_state["plane_busy_frac"], 1.0)
        near = "MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w *= self.cfg["weights"]["g_phase"].get(op_name, {}).get(near, 1.0)
        return w

    def propose(self, now_us: float, hook: PhaseHook,
                global_state: Dict[str,str], local_state: Dict[str,str],
                earliest_start: float) -> Optional[Operation]:
        # 0) Obligation first (plane/time filtered)
        ob = self.obl.pop_urgent(now_us, hook.die, hook.plane,
                                 horizon_us=10.0, earliest_start=earliest_start)
        if ob:
            if self.addr.precheck(ob.require, ob.targets, start_hint=earliest_start):
                cfg_op = self.cfg["op_specs"][ob.require.name]
                op = build_operation(ob.require, cfg_op, ob.targets)
                op.meta["source"]="obligation"
                return op
            # else: could attempt alternative targets (omitted in demo)

        # 1) Policy path: weighted pick under phase/state
        cand = []
        for name in ["READ", "PROGRAM", "ERASE"]:
            s = self._score(name, hook.label, global_state, local_state)
            if s>0: cand.append((name, s))
        if not cand: return None
        total = sum(s for _,s in cand)
        r = random.random()*total
        acc=0.0
        pick = cand[-1][0]
        for name, s in cand:
            acc += s
            if r <= acc:
                pick=name; break

        kind = OpKind[pick]
        targets = self.addr.select(kind, hook.die, hook.plane)  # P1: multi-plane/fanout í™•ì¥ ê°€ëŠ¥
        if not targets:
            return None
        if not self.addr.precheck(kind, targets, start_hint=earliest_start):
            return None
        op = build_operation(kind, self.cfg["op_specs"][pick], targets)
        op.meta["source"]="policy"
        return op

# ---------------------------- Scheduler ----------------------------

class Scheduler:
    def __init__(self, cfg, addr_mgr: AddressManager, policy_engine: PolicyEngine, obl_mgr: ObligationManager):
        self.cfg=cfg; self.addr=addr_mgr; self.SPE=policy_engine; self.obl=obl_mgr
        self.now=0.0
        self.ev=[]  # (time, seq, type, payload)
        self._seq=0
        self.stat_propose_calls = 0
        self.stat_scheduled = 0
        self._push(0.0, "QUEUE_REFILL", None)
        # Bootstrap hooks per plane
        for plane in range(self.addr.planes):
            self._push(0.0, "PHASE_HOOK", PhaseHook(0.0, "BOOT.START", 0, plane))

    def _push(self, t: float, typ: str, payload: Any):
        heapq.heappush(self.ev, (t, self._seq, typ, payload)); self._seq+=1

    def _unique_plane_keys(self, targets: List[Address]) -> List[Tuple[int,int,int]]:
        # (die, plane, block) tuples deduped
        s=set()
        for a in targets:
            s.add((a.die, a.plane, a.block))
        return list(s)

    def _start_time_for_targets(self, targets: List[Address]) -> float:
        # start cannot be earlier than any involved plane's availability
        planes = {(a.die, a.plane) for a in targets}
        avail = [self.addr.available_at(d,p) for (d,p) in planes]
        return max([self.now] + avail)

    def _schedule_operation(self, op: Operation):
        start = self._start_time_for_targets(op.targets)
        dur = sum(seg.dur_us for seg in op.states)
        end  = start + dur
        # reserve for all involved planes
        for d,p,b in self._unique_plane_keys(op.targets):
            self.addr.reserve(d, p, start, end, block=b)
        # events
        self._push(start, "OP_START", op)
        self._push(end,   "OP_END",   op)
        # hooks for each involved plane
        for d,p,_ in self._unique_plane_keys(op.targets):
            hooks = make_phase_hooks(op, start, self.cfg["op_specs"][op.kind.name], d, p)
            for h in hooks:
                self._push(h.time_us, "PHASE_HOOK", h)
        first = op.targets[0]
        print(f"[{self.now:7.2f} us] SCHED  {op.kind.name:7s} on targets={len(op.targets)} start={start:7.2f} end={end:7.2f} 1st={_addr_str(first)} src={op.meta.get('source')}")
        self.stat_scheduled += 1

    def run_until(self, t_end: float):
        while self.ev and self.ev[0][0] <= t_end:
            self.now, _, typ, payload = heapq.heappop(self.ev)
            if typ=="QUEUE_REFILL":
                # seed hooks to keep flow
                for plane in range(self.addr.planes):
                    self._push(self.now, "PHASE_HOOK", PhaseHook(self.now, "REFILL.NUDGE", 0, plane))
                nxt = self.now + self.cfg["policy"]["queue_refill_period_us"]
                self._push(nxt, "QUEUE_REFILL", None)

            elif typ=="PHASE_HOOK":
                hook: PhaseHook = payload
                earliest_start = self.addr.available_at(hook.die, hook.plane)
                global_state, local_state = self.addr.observe_states(hook.die, hook.plane, self.now)
                self.stat_propose_calls += 1
                op = self.SPE.propose(self.now, hook, global_state, local_state, earliest_start)
                if op:
                    self._schedule_operation(op)
                else:
                    # no viable op at this hook; that's fine
                    pass

            elif typ=="OP_START":
                op: Operation = payload
                first = op.targets[0]
                print(f"[{self.now:7.2f} us] START  {op.kind.name:7s} target={_addr_str(first)}")

            elif typ=="OP_END":
                op: Operation = payload
                first = op.targets[0]
                print(f"[{self.now:7.2f} us] END    {op.kind.name:7s} target={_addr_str(first)}")
                # commit state first
                self.addr.commit(op)
                # then obligations
                self.obl.on_commit(op, self.now)

        # summary
        print(f"\n=== Stats ===")
        print(f"propose calls : {self.stat_propose_calls}")
        print(f"scheduled ops : {self.stat_scheduled}")
        if self.stat_propose_calls:
            rate = 100.0 * self.stat_scheduled / self.stat_propose_calls
            print(f"accept ratio  : {rate:.1f}%")

# ---------------------------- Main ----------------------------

def main():
    random.seed(CFG["rng_seed"])
    addr = AddressManager(CFG)
    obl  = ObligationManager(CFG["obligations"])
    spe  = PolicyEngine(CFG, addr, obl)
    sch  = Scheduler(CFG, addr, spe, obl)
    run_until = CFG["policy"]["run_until_us"]
    print("=== NAND Sequence Generator Demo (P0 Patched) ===")
    sch.run_until(run_until)
    print("=== Done ===")

if __name__ == "__main__":
    main()

```

ì›í•˜ëŠ” ëŒ€ë¡œ ë°”ë¡œ ì‹¤í–‰í•˜ë©´ ë©ë‹ˆë‹¤:

```bash
python3 nandsim_demo_p0.py

```

ë‹¤ìŒ ë‹¨ê³„ë¡œ ê°€ë©´,
- Hook ì‹œê°„ ì–‘ìí™”(quantize),
- policy phaseë³„ weight í…Œì´ë¸” ê°„ì†Œí™”,
- multi-plane select(fanout/interleave) ì˜µì…˜,
- duration ë˜í¼(get_op_duration),
- BusySlot í™œìš©/ë¦¬í¬íŠ¸

ê°™ì€ P1/P2 í•­ëª©ì„ ì´ì–´ì„œ ë¶™ì¼ ìˆ˜ ìˆì–´ìš”.

## ğŸ‘¤ User

ê° ì•„ì´í…œë³„ risk í‰ê°€ í›„ ì§„í–‰í•´

## ğŸ¤– Assistant

ì•„ë˜ëŠ” ë³´ì™„ í•­ëª©ë³„ ë¦¬ìŠ¤í¬ í‰ê°€ì™€ ë°”ë¡œ ì§„í–‰í•  ì‹¤í–‰ í”Œëœì´ì•¼.  

ì›ì¹™: ì¦‰ì‹œ íš¨ê³¼Â·êµ¬ì¡° ì´ë“ í¼ = ìƒìœ„, ê´‘ë²”ìœ„ íŒŒê¸‰Â·ë¶ˆí™•ì‹¤ì„± í¼ = í•˜ìœ„. ë‹¨, í•„ìˆ˜ ê°œì„ ì€ ìƒí–¥ ë°°ì¹˜.

1) í•­ëª©ë³„ ë¦¬ìŠ¤í¬ í‰ê°€

| ID | ë³´ì™„ í•­ëª© | ìœ„í—˜ë„ | ì˜í–¥ ë²”ìœ„ | ì‹¤íŒ¨ ì‹œ ì¦ìƒ | ì™„í™”/í…ŒìŠ¤íŠ¸ í¬ì¸íŠ¸ |
| --- | --- | --- | --- | --- | --- |
| A | propose ì»¨í…ìŠ¤íŠ¸ ì •ê·œí™”(earliest_start/now ì ìš©) â€“ ì´ë¯¸ ì ìš©(P0) | ë‚®ìŒ | SPE/Scheduler ê²½ê³„ | ë¦¬ì ì…˜â†‘ | í›…ë§ˆë‹¤ ë™ì¼ ì»¨í…ìŠ¤íŠ¸ ì „ë‹¬ ì—¬ë¶€ ë¡œê·¸ë¡œ í™•ì¸ |
| B | pop_urgent plane/ì‹œê°„ í•„í„° â€“ ì´ë¯¸ ì ìš©(P0) | ë‚®ìŒ | Obligationë§Œ | ì˜ë¬´ ëˆ„ë½/ì¡°ê¸° ë§Œë£Œ | deadline ì¶©ì¡±ë¥ Â·ì˜ë¬´ ë¯¸ì¶©ì¡±ë¥  ë©”íŠ¸ë¦­ |
| C | precheck ìµœì†Œ êµ¬í˜„ â€“ ì´ë¯¸ ì ìš©(P0) | ì¤‘ | ì˜ˆì•½/ì˜ì¡´ì„± í‘œë©´ | false accept/false reject | ê²¹ì¹¨Â·ë¸”ë¡ì¶©ëŒ ìœ ë‹›í…ŒìŠ¤íŠ¸(ë‹¨ì¼/ë‹¤ì¤‘ plane) |
| D | ë‹¤ì¤‘ plane ì˜ˆì•½(Reserve All Targets) â€“ ì´ë¯¸ ì ìš©(P0) | ë‚®ìŒ | AddressManager | ê²½í•©/íƒ€ì„ë¼ì¸ ì™œê³¡ | ëª¨ë“  ëŒ€ìƒ planeì˜ available_at ìƒìŠ¹ í™•ì¸ |
| E | observe_states(now) ì‹œê°„ ë°˜ì˜ â€“ ì´ë¯¸ ì ìš©(P0) | ë‚®ìŒ | ì •ì±… ê°€ì¤‘ | ë¶„í¬ ë“œë¦¬í”„íŠ¸ | now ê¸°ì¤€ ë²„í‚· ë³€í™” ìŠ¤ëƒ…ìƒ· ë¹„êµ |
| F | BusySlot ëª©ì  ì¬ì •ì˜/ì •ë¦¬ | ë‚®ìŒ | ë¦¬í¬íŒ… | ë¶ˆí•„ìš” ë©”ëª¨ë¦¬ | ìœ ì§€ ì‹œ í™œìš© ì§€í‘œ ì •ì˜(plane util, overlap) |
| G | observe_states ë¹„ìœ¨ ì‚°ì‹ ê°œì„ (plane busy, pgm/read ratio ì •í™•í™”) | ì¤‘ | ì •ì±… ê°€ì¤‘ | í¸í–¥ëœ ìƒ˜í”Œ | ì˜ˆì•½í‘œ ê¸°ë°˜ ê°€ë™ë¥  ì¶”ì •Â·ë‹¨ìœ„í…ŒìŠ¤íŠ¸ |
| H | í›… ìŠ¤í™ ë‹¨ìˆœí™”(START/MID/END 3ìƒ ê¸°ë³¸í˜•) | ì¤‘ | Hook ìƒì„±/ë¶„í¬ | í›… ë°€ë„ ë³€í™”â†’ë¶„í¬ë³€í˜• | êµ¬ë²„ì „ í˜¸í™˜: ë¯¸ì§€ì • ì‹œ 3ìƒ ìë™ ìœ ë„ |
| I | addr.select ë‹¤ì¤‘ plane/ì¸í„°ë¦¬ë¸Œ ë°˜í™˜ | ì¤‘ | ì„ íƒ/ì˜ˆì•½ | ì£¼ì†Œ ë¶ˆì¼ì¹˜, ì˜ˆì•½ ëˆ„ë½ | ë°˜í™˜í˜• ê³ ì •(List[Address]) + fanout ì˜µì…˜ |
| J | ì˜ë¬´ íƒ€ê¹ƒ ì²˜ë¦¬ ë¡œì§(ìˆœì°¨ read/pgm, cache readâ†”dout ì˜¤í”„ì…‹) | ë†’ìŒ(í•„ìˆ˜) | Obligation/ì£¼ì†Œ ìƒíƒœ | ì˜ëª»ëœ íƒ€ê¹ƒÂ·ì˜ë¬´ ë¯¸ì¶©ì¡± | source-op íŠ¸ë˜ì»¤Â·ì˜¤í”„ì…‹ í•¨ìˆ˜Â·íšŒê·€í…ŒìŠ¤íŠ¸ |
| K | ì •ì±… ì„ íƒ ë¡œì§: phase-ì¡°ê±´ ê°€ì¤‘ìœ¼ë¡œ ë‹¨ìˆœí™” | ë‚®ìŒ | SPE | ê°€ì¤‘ ì˜¤ë‚¨ìš© | ë‹¨ì¼ í…Œì´ë¸”ë¡œ ì‹œë‚˜ë¦¬ì˜¤ ì¬í˜„ ê²€ì¦ |
| L | ì˜ë¬´ vs ì •ì±… ìš°ì„ ìˆœìœ„(ë¶€ìŠ¤íŒ…/í•˜ë“œìŠ¬ë¡¯) ë³´ê°• | ì¤‘ | SPE/ìŠ¤ì¼€ì¤„ | ì˜ë¬´ ë§ˆê° ì†Œì‹¤ | boost window/hard-slot ì‹œë‚˜ë¦¬ì˜¤ í…ŒìŠ¤íŠ¸ |
| M | op.movable í•„ìš”ì„± ì¬ê²€í†  | ë‚®ìŒ | ì¬ë°°ì¹˜ | ì˜í–¥ ì ìŒ | í›„ìˆœìœ„(ì¬ë°°ì¹˜ ë„ì… ì‹œ í™œì„±) |
| N | ì—°ì† ì˜ˆì•½Â·ì˜ì¡´ì„±(erase/pgm/read ê¸ˆì§€ ê·œì¹™ ê°•í™”) | ë†’ìŒ(í•„ìˆ˜) | dep-check | ìˆœì„œ ìœ„ë°˜Â·ë°ì´í„° ë¬´ê²°ì„± ë¶•ê´´ | ë¸”ë¡/í˜ì´ì§€ ìŠ¤ì½”í”„ ë½Â·ê·¸ë˜í”„ ê²€ì‚¬ |
| O | í›… ì‹œê°„ í•´ìƒë„(quantize) | ë‚®ìŒ | ì´ë²¤íŠ¸ í | ê·¼ì†Œí•œ ì‹œê°„ í”ë“¤ë¦¼ | ì „ì—­ SIM_RES_US ë„ì…Â·íšŒê·€ ë¡œê·¸ ë¹„êµ |
| P | plane interleave read ìµœì í™”(look-ahead) | ì¤‘ | Scheduler | ê¸°ëŒ€ë³´ë‹¤ ë‚®ì€ ë³‘ë ¬ì„± | look-ahead K ì œí•œÂ·ì „í›„ util ë¹„êµ |
| Q | addr.select vs ì˜ë¬´ íƒ€ê¹ƒ í†µí•© ì¸í„°í˜ì´ìŠ¤ | ë‚®ìŒ | ì„ íƒ API | ì½”ë“œ ì¤‘ë³µ | get_targets(kind, source_op=None) ì–´ëŒ‘í„° |
| R | make_phase_hooks ì¸ì ì •ë¦¬(op.kindë¡œ cfg ì¡°íšŒ) | ë‚®ìŒ | Hook ìƒì„± | ìœ ì§€ë³´ìˆ˜ì„± | ë‚´ë¶€ ì¡°íšŒë¡œ ì¼ì›í™”Â·í…ŒìŠ¤íŠ¸ ë™ì¼ì„± |
| S | duration ê³„ì‚° ë˜í¼/StateSeq.times ì „í™˜ ëŒ€ë¹„ | ì¤‘ | Scheduler | dur ì˜¤ì‚° | get_op_duration ë˜í¼ ë„ì…Â·ë‹¨ìœ„í…ŒìŠ¤íŠ¸ |

í•„ìˆ˜ ê°œì„ : J(ì˜ë¬´ íƒ€ê¹ƒ ì²˜ë¦¬), N(ì—°ì† ì˜ˆì•½Â·ì˜ì¡´ì„± ê°•í™”) â€” ìœ„í—˜ì€ ë†’ì§€ë§Œ, ì‹œí€€ìŠ¤ ì •í•©ì„±ì— í•µì‹¬ì´ë¼ ìƒí–¥.

2) ì‹¤í–‰ í”Œëœ (ìš°ì„ ìˆœìœ„Â·ë³‘í–‰ ê°€ëŠ¥ì„± ë°˜ì˜)
Step 1 â€” ì €ìœ„í—˜/ê³ íš¨ìœ¨ ì•ˆì •í™” (ì¦‰ì‹œ)
- O í›…/ì´ë²¤íŠ¸ ì‹œê°„ quantize (ì „ì—­ SIM_RES_US)
- S get_op_duration(op) ë˜í¼ ë„ì…, _schedule_operationì—ì„œ ì‚¬ìš©
- R make_phase_hooks(op, start, die, plane)ë¡œ ì‹œê·¸ë‹ˆì²˜ ë‹¨ìˆœí™”(ë‚´ë¶€ì—ì„œ CFG["op_specs"][op.kind.name] ì¡°íšŒ)
- G(ë¶€ë¶„) observe_statesì˜ plane_busy_fracë¥¼ available_at(now) > now ? high : lowë¡œ ìµœì†Œ ë³´ì • (ì •í™• ì‚°ì‹ì€ Step 3)

ë¦¬ìŠ¤í¬: ë‚®ìŒ / íš¨ê³¼: ê²°ì •ì  íƒ€ì´ë° ì•ˆì •, ìœ ì§€ë³´ìˆ˜ì„±â†‘
Step 2 â€” ì˜ë¬´/ì •ì±… ì¶©ëŒ ìµœì†Œí™” (í•„ìˆ˜)
- L ì˜ë¬´ ë¶€ìŠ¤íŒ…/í•˜ë“œìŠ¬ë¡¯ ë°˜ì˜: deadline - now <= boost_windowì¼ ë•Œ ì˜ë¬´ ìš°ì„  ë°˜í™˜. hard_slot=Trueë©´ horizon ë¬´ì‹œí•˜ê³  ë°˜í™˜(ë‹¨ precheckëŠ” ìœ ì§€)
- Q get_targets(kind, source_op=None) ì–´ëŒ‘í„°ë¡œ ì˜ë¬´/ì •ì±… íƒ€ê¹ƒ ê²½ë¡œ í†µí•©
- K ì •ì±… ì„ íƒì„ phase-ì¡°ê±´ í…Œì´ë¸”(START/MID/END)ë¡œ ë‹¨ìˆœí™”

ë¦¬ìŠ¤í¬: ì¤‘ / íš¨ê³¼: ì˜ë¬´ ë¯¸ì¶©ì¡±ë¥ â†“, ë¶„í¬ ì œì–´ ìš©ì´
Step 3 â€” ì •í•©ì„± ê°•í™” (í•„ìˆ˜Â·ê³ ìœ„í—˜ ë‹¨ê³„)
- J ì˜ë¬´ íƒ€ê¹ƒ ì²˜ë¦¬ ë¡œì§:
  - (a) Sequential READ/PGM: page += 1 ì¶”ì (ì†ŒìŠ¤ op ë©”íƒ€ ë³´ê´€)
  - (b) Cache READâ†’DOUT: DOUT íƒ€ê¹ƒ = cache-readì˜ page - 1
  - ì†ŒìŠ¤ op â†’ ì˜ë¬´ opë¡œ íƒ€ê¹ƒ ë³€í™˜ í•¨ìˆ˜(pure function) ë„ì…
- N ì˜ì¡´ì„±/ì—°ì† ì˜ˆì•½:
  - ë¸”ë¡ ìŠ¤ì½”í”„ ë½(ERASE â†” PGM/READ ë™ì‹œ ê¸ˆì§€), í˜ì´ì§€ ìŠ¤ì½”í”„ ë½(PGM â†” READ)
  - precheckì— ìŠ¤ì½”í”„ ë³„ ì¶©ëŒ ê²€ì‚¬ ì¶”ê°€
  - ê°„ë‹¨í•œ ì˜ì¡´ì„± ê·¸ë˜í”„(before/after, scope)ë¡œ ì‚¬ì´í´/ìœ„ë°˜ ê²€ì¶œ

ë¦¬ìŠ¤í¬: ë†’ìŒ / ì™„í™”: ë‹¨ê³„ë³„ ê²Œì´íŠ¸(READ/PGMë§Œâ†’ERASEí™•ì¥), í’ë¶€í•œ ë‹¨ìœ„í…ŒìŠ¤íŠ¸
Step 4 â€” ì •ì±…Â·ê´€ì¸¡ ê°œì„  (ì¤‘ìœ„í—˜)
- I ë‹¤ì¤‘ plane fanout/interleave ì§€ì›(ë°˜í™˜í˜• ìœ ì§€, ì˜µì…˜ ì¶”ê°€)
- G(ì™„ì „) ì˜ˆì•½í‘œ ê¸°ë°˜ ê°€ë™ë¥  ê³„ì‚°(ìœˆë„ìš° ì»¤ë²„ë¦¬ì§€ ê·¼ì‚¬)
- H í›… 3ìƒ ê¸°ë³¸í˜• ì§€ì›(êµ¬ìŠ¤í™ í˜¸í™˜)
- P READ look-ahead ì¬ë°°ì¹˜(íš¨ìœ¨â†‘, ì •í•©ì„± ì²´í¬ ì´ì¤‘ê²€ì¦)

Step 5 â€” ì •ë¦¬/ë¦¬í¬íŒ…
- F BusySlot í™œìš© í™•ì •(ìœ ì§€ ì‹œ ë©”íŠ¸ë¦­) ë˜ëŠ” ì œê±°
- ë¬¸ì„œ/ë©”íŠ¸ë¦­: ì˜ë¬´ ë¯¸ì¶©ì¡±ë¥ , accept ratio, plane util, ë¦¬ì ì…˜ ì‚¬ìœ  ë¶„í¬

3) ì§€ê¸ˆ ë‹¹ì¥ ì ìš©í•  ì†Œê·œëª¨ íŒ¨ì¹˜(ìš”ì•½)
ì•„ë˜ 4ê°œëŠ” ì½”ë“œ ì˜í–¥ ì‘ê³  ì•ˆì •í™” íš¨ê³¼ í¼ â€” Step 1 ì¦‰ì‹œ ì ìš©:
1. ì‹œê°„ quantize

```python
SIM_RES_US = 0.01
def quantize(t): return round(t / SIM_RES_US) * SIM_RES_US

# Scheduler._push, OP_START/END, PHASE_HOOK enqueue ì‹œì ì— t=quantize(t)
# make_phase_hooks(...) ë‚´ë¶€ì—ì„œ h.time_us = quantize(h.time_us)

```

2. duration ë˜í¼

```python
def get_op_duration(op): return sum(seg.dur_us for seg in op.states)
# _schedule_operation: dur = get_op_duration(op)

```

3. make_phase_hooks ì‹œê·¸ ë‹¨ìˆœí™”

```python
def make_phase_hooks(op, start_us, die, plane):
    cfg_op = CFG["op_specs"][op.kind.name]
    ...

```

(í˜¸ì¶œë¶€ì—ì„œ cfg ì¸ì ì œê±°)
4. observe_states(now) ìµœì†Œ ë³´ì •

```python
def observe_states(die, plane, now_us):
    busy = self.available_at(die, plane) > now_us
    plane_busy_frac = "high" if busy else "low"
    ...

```

ì›í•˜ë©´ ìœ„ 4ê°œëŠ” í˜„ í†µí•©ë³¸ì— ë°”ë¡œ ë¶™ì¸ ì½”ë“œë¡œ ë„˜ê²¨ì¤„ê²Œ.

4) ë‹¨ìœ„í…ŒìŠ¤íŠ¸ ì²´í¬ë¦¬ìŠ¤íŠ¸ (ê° ë‹¨ê³„ ì™„ë£Œ ê¸°ì¤€)
- ì˜ë¬´ ì¶©ì¡±ë¥ : READâ†’DOUT 95%+ (horizon/boost ì„¤ì • í•˜)
- accept ratio: í›… ëŒ€ë¹„ ìŠ¤ì¼€ì¤„ ë¹„ìœ¨ ìƒìŠ¹(ê¸°ì¤€ì„  ëŒ€ë¹„ +X%)
- ê²¹ì¹¨ ê¸ˆì§€: ê°™ì€ blockì— ERASEì™€ READ/PGM ë™ì‹œ ê¸ˆì§€ ì¼€ì´ìŠ¤ í†µê³¼
- ì‹œê°„ ì•ˆì •ì„±: quantize ì „í›„ ë™ì¼ ì‹œí€€ìŠ¤(seed ê³ ì •) ì—¬ë¶€
- ë¶„í¬ ì•ˆì •ì„±: phaseë³„ READ/PROGRAM ë¹„ìœ¨ì´ ì„¤ì • ê°€ì¤‘ê³¼ ì¼ì¹˜(Â±í—ˆìš©ì˜¤ì°¨)

ë‹¤ìŒ ë©”ì‹œì§€ì—ì„œ Step 1 íŒ¨ì¹˜ ì ìš© í†µí•©ë³¸ì„ ë°”ë¡œ ì œê³µí• ê²Œ. ì›í•˜ë©´ **Step 2(ì˜ë¬´ ë¶€ìŠ¤íŒ…Â·íƒ€ê¹ƒ ì–´ëŒ‘í„°Â·phase-ì¡°ê±´ ê°€ì¤‘)**ê¹Œì§€ ë¬¶ì–´ì„œ ë‚´ì¤„ ìˆ˜ë„ ìˆì–´.

## ğŸ‘¤ User

ê·¸ ì „ì— phase-ì¡°ê±´ ë³„ í™•ë¥  ë¶„í¬ë¥¼ ì–´ë–»ê²Œ êµ¬í˜„í•  ê±´ì§€ í™•ì¸í•˜ê³  ë„˜ì–´ê°€ì. ë‚´ê°€ ì˜ë„í•œ ë°”ëŠ” operation-phase ê°€ ê³±í•´ì§„ ì¡°ê±´ì—ì„œì˜ í™•ë¥ ì´ì•¼. ì˜ˆë¥¼ ë“¤ë©´, { "READ.ISSE": { "READ": 0.0, "PROGRAM": 0.0, ...}, "READ.CORE_BUSY": { ...}, "PROGRAM.ISSUE": {...}, ... } ì´ëŸ° í˜•íƒœì•¼. ë„ˆì˜ ê³„íšê³¼ ë‚˜ì˜ ì„¤ëª…ì´ ë§ëŠ”ì§€ ì»¨íŒí•´ì¤˜.

## ğŸ¤– Assistant

ë§ì•„â€”ë„¤ê°€ ì˜ë„í•œ â€œoperationÃ—phase(=í˜„ì¬ í›…ì˜ ì—°ì‚°/ìŠ¤í…Œì´íŠ¸/í¬ì§€ì…˜) ì¡°ê±´ì—ì„œì˜ í™•ë¥ ë¡œ ë‹¤ìŒ operationì„ ìƒ˜í”Œë§â€ ë°©ì‹ì„ ê·¸ëŒ€ë¡œ ì“¸ ê±°ì•¼. ë‚˜ëŠ” ì´ê±¸ phase-ì¡°ê±´ ë¶„í¬ í…Œì´ë¸”ë¡œ êµ¬í˜„í•˜ê³ , ì¡´ì¬í•˜ë©´ ê·¸ê±¸ 1ìˆœìœ„ë¡œ, ì—†ìœ¼ë©´ ì ì§„ì  ë°±ì˜¤í”„ë¡œ ì²˜ë¦¬í•˜ë ¤ í–ˆì–´.
ì•„ë˜ì²˜ëŸ¼ ì •ë¦¬í• ê²Œ.
í•©ì˜ë˜ëŠ” ëª¨ë¸
- í›… ë¼ë²¨ì„ "{CURR_OP}.{STATE}.{POS}"ë¡œ í‘œì¤€í™”

ì˜ˆ: READ.CORE_BUSY.START, PROGRAM.ISSUE.END

(POSëŠ” START/MID/END; ë„¤ê°€ ì›í•˜ë©´ POS ì—†ëŠ” 2-íŠœí”Œë„ ì§€ì›)
- ë¶„í¬ í…Œì´ë¸”ì€ â€œí˜„ì¬ í›… ì»¨í…ìŠ¤íŠ¸ â†’ ë‹¤ìŒ op ë¶„í¬â€ë¥¼ ë§¤í•‘:
- ìƒ˜í”Œë§ ìš°ì„ ìˆœìœ„(ë°±ì˜¤í”„):
  1. OP.STATE.POS (ê°€ì¥ êµ¬ì²´)
  2. OP.STATE
  3. STATE (ì˜µì…˜)
  4. DEFAULT

(í•´ë‹¹ ë¶„í¬ì˜ í•©ì´ 0ì´ê±°ë‚˜ í‚¤ ë¯¸ì¡´ì¬ë©´ ë‹¤ìŒ ë‹¨ê³„ë¡œ ë°±ì˜¤í”„)
- Obligation ìš°ì„ : ê¸°í•œ ì„ë°• ì˜ë¬´ê°€ ìˆìœ¼ë©´ ë¨¼ì € ì²˜ë¦¬(ê°€ëŠ¥ ì‹œ ë°”ë¡œ ë°˜í™˜); ì—†ì„ ë•Œë§Œ ìœ„ ë¶„í¬ë¡œ ìƒ˜í”Œ.
- DOUT: ê¸°ë³¸ì€ ì˜ë¬´ë¡œë§Œ ë°œìƒ(ë¶„í¬ í…Œì´ë¸”ì—” 0ìœ¼ë¡œ ë‘ê±°ë‚˜ í‚¤ ìƒëµ). í•„ìš”í•˜ë©´ í¬í•¨ ê°€ëŠ¥.

êµ¬í˜„ í¬ì¸íŠ¸ (ê°„ë‹¨ íŒ¨ì¹˜ ìŠ¤ì¼€ì¹˜)
1) í›… ë¼ë²¨ íŒŒì‹±

```python
def parse_hook_key(label: str):
    # e.g., "READ.CORE_BUSY.START" -> ("READ","CORE_BUSY","START")
    parts = label.split(".")
    if len(parts) >= 3:
        return parts[0], parts[1], parts[2]
    if len(parts) == 2:
        return parts[0], parts[1], None
    return None, None, None  # BOOT/REFILL ê°™ì€ íŠ¹ìˆ˜ í›…ì€ DEFAULTë¡œ

```

2) ë¶„í¬ ê°€ì ¸ì˜¤ê¸°(ë°±ì˜¤í”„ í¬í•¨)

```python
def get_phase_dist(cfg, hook_label: str):
    op, state, pos = parse_hook_key(hook_label)
    pc = cfg.get("phase_conditional", {})
    # í›„ë³´ í‚¤ë“¤: ê°€ì¥ êµ¬ì²´ -> ì¼ë°˜ -> ë””í´íŠ¸
    keys = []
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    if state:                keys.append(state)   # ì„ íƒ ì‚¬í•­ (ì›í•˜ë©´ ì‚¬ìš©)
    keys.append("DEFAULT")
    for k in keys:
        dist = pc.get(k)
        if dist and sum(dist.values()) > 0:
            return dist
    return None  # ìµœì¢… ë°±ì˜¤í”„ëŠ” ê¸°ì¡´ ê°€ì¤‘ ë°©ì‹

```

3) PolicyEngine.propose ë‚´ë¶€ì˜ ì„ íƒ ë¡œì§ êµì²´

```python
# ì˜ë¬´ ìš°ì„ (í˜„í–‰ ìœ ì§€)
ob = self.obl.pop_urgent(...); ...
# ì—†ìœ¼ë©´ phase-ì¡°ê±´ ë¶„í¬ ì‹œë„
dist = get_phase_dist(self.cfg, hook.label)
if dist:
    # í•„ìš” ì‹œ DOUT ì œì™¸
    items = [(name, p) for name,p in dist.items() if name in self.cfg["op_specs"]]
    total = sum(p for _,p in items)
    if total > 0:
        r = random.random() * total
        acc = 0.0
        pick = items[-1][0]
        for name, p in items:
            acc += p
            if r <= acc:
                pick = name; break
        kind = OpKind[pick]
        targets = self.addr.select(kind, hook.die, hook.plane)
        if targets and self.addr.precheck(kind, targets, start_hint=earliest_start):
            op = build_operation(kind, self.cfg["op_specs"][pick], targets)
            op.meta["source"] = "policy.phase_conditional"
            return op
# ë°±ì˜¤í”„: ê¸°ì¡´ì˜ ê³±ì…ˆ ê°€ì¤‘(_score) ë°©ì‹ìœ¼ë¡œ ì‹œë„

```

ì´ë ‡ê²Œ í•˜ë©´ **ë„ˆì˜ ì˜ë„(â€œí˜„ì¬ í›…ì˜ OPÃ—STATE(Ã—POS) ì¡°ê±´ ë¶„í¬â€)**ê°€ ìµœìš°ì„ ìœ¼ë¡œ ì ìš©ë˜ê³ , ì„¤ì •ì´ ë¹„ì–´ìˆê±°ë‚˜ 0í•©ì¼ ë•Œë§Œ ê¸°ì¡´ ê°€ì¤‘ ê³± ë°©ì‹ìœ¼ë¡œ ìì—°ìŠ¤ëŸ½ê²Œ ë‚´ë ¤ê°€.

ê¶Œì¥ ìŠ¤í‚¤ë§ˆ (Configì— ì¶”ê°€)

```yaml
phase_conditional:
  READ.ISSUE:
    READ: 0.00
    PROGRAM: 0.80
    ERASE: 0.20
  READ.CORE_BUSY.START:
    READ: 0.05
    PROGRAM: 0.85
    ERASE: 0.10
  PROGRAM.ISSUE:
    READ: 0.50
    PROGRAM: 0.25
    ERASE: 0.25
  DEFAULT:
    READ: 0.60
    PROGRAM: 0.30
    ERASE: 0.10

```

ì£¼ì˜/í…ŒìŠ¤íŠ¸
- í‚¤ í‘œì¤€í™”: í›… ë¼ë²¨ê³¼ í…Œì´ë¸” í‚¤ ëª¨ë‘ ëŒ€ë¬¸ì & ê³µë°± ì—†ì´(CORE_BUSY)ë¡œ ë§ì¶”ì. (ì§ˆë¬¸ ì˜ˆì˜ READ.ISSEëŠ” READ.ISSUEë¡œ êµì •)
- í•© 1.0 ê°•ì œ X: í•©ì´ 1ì´ ì•„ë‹ˆì–´ë„ ê°€ì¤‘ì¹˜ë¡œ ì·¨ê¸‰(ì •ê·œí™” ì—†ì´ ë£°ë ›).
- ê¸°ë¡: ì–´ë–¤ í‚¤ë¡œ ì„ íƒëëŠ”ì§€ op.meta["phase_key_used"] ì €ì¥ â†’ ë¶„í¬ íŠœë‹/ê²€ì¦ ì‹œê°í™”.

ì´ êµ¬ì¡°ë©´ ë„¤ê°€ ì›í•œ â€œoperation-phase ê³± ì¡°ê±´ ë¶„í¬â€ê°€ ê·¸ëŒ€ë¡œ ë°˜ì˜ë¼. ì›í•˜ë©´ ì§€ê¸ˆ í†µí•©ë³¸ì— ì´ ë¡œì§ì„ ë°”ë¡œ ë¶™ì—¬ì„œ ì—…ë°ì´íŠ¸í•´ì¤„ê²Œ.

## ğŸ‘¤ User

ì—…ë°ì´íŠ¸ í•´ì¤˜.

## ğŸ¤– Assistant

ì•„ë˜ëŠ” phase-ì¡°ê±´ ë¶„í¬(í˜„ì¬ í›…ì˜ OP.STATE(.POS) ì¡°ê±´ì—ì„œ ë‹¤ìŒ operation í™•ë¥ ì„ ì§ì ‘ ì§€ì •) ë¥¼ í†µí•©í•œ ì—…ë°ì´íŠ¸ ë²„ì „ ë‹¨ì¼ íŒŒì¼ì…ë‹ˆë‹¤.
- CFG["phase_conditional"] ì¶”ê°€
- í›… ë¼ë²¨ íŒŒì‹± â†’ OP.STATE.POS/OP.STATE â†’ DEFAULT ìˆœ ë°±ì˜¤í”„
- PolicyEngine.proposeê°€ ì˜ë¬´ ìš°ì„  â†’ phase-ì¡°ê±´ ë¶„í¬ â†’ (ë°±ì˜¤í”„) ê¸°ì¡´ ê°€ì¤‘ ë°©ì‹ ìˆœìœ¼ë¡œ ì„ íƒ
- ì„ íƒëœ phase í‚¤ëŠ” op.meta["phase_key_used"]ì— ê¸°ë¡

íŒŒì¼ëª… ì˜ˆ: nandsim_demo_p0_phase.py

```python
# nandsim_demo_p0_phase.py â€” P0 í†µí•©ë³¸ + Phase-Conditional ë¶„í¬
# - Event-jump Scheduler
# - Phase Hook ìƒì„±(ìŠ¤ì¼€ì¤„ëŸ¬)
# - PolicyEngine: obligation ìš°ì„  â†’ "OP.STATE(.POS)" ë¶„í¬ â†’ ê°€ì¤‘(score) ë°±ì˜¤í”„
# - AddressManager: state snapshot(now), precheck/reserve with multi-plane
# - ê°„ë‹¨ í†µê³„: propose calls / scheduled ops

from __future__ import annotations
import heapq, random
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple, Set

# ---------------------------- Config ----------------------------

CFG = {
    "rng_seed": 12345,
    "policy": {
        "queue_refill_period_us": 3.0,
        "lookahead_k": 4,
        "run_until_us": 150.0,
    },
    "weights": {  # (phase-conditional ì—†ì„ ë•Œ ë°±ì˜¤í”„ìš©)
        "base": {  # class=host only for demo
            "host": {
                "READ": 0.85,
                "PROGRAM": 0.10,
                "ERASE": 0.05,
                "SR": 0.00,
                "RESET": 0.00,
                "DOUT": 0.00,  # obligation-driven only
            }
        },
        "g_state": {  # very light demo weights
            "pgmable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.8},
            "readable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.9},
        },
        "g_local": {"plane_busy_frac": {"low": 1.2, "mid": 1.0, "high": 0.9}},
        "g_phase": {
            "READ": {"START_NEAR": 1.2, "MID_NEAR": 0.9, "END_NEAR": 1.2},
            "PROGRAM": {"START_NEAR": 1.1, "MID_NEAR": 1.0, "END_NEAR": 0.9},
            "ERASE": {"START_NEAR": 0.9, "MID_NEAR": 1.1, "END_NEAR": 1.1},
            "SR": {"START_NEAR": 1.0, "MID_NEAR": 1.0, "END_NEAR": 1.0},
            "RESET": {"START_NEAR": 1.0, "MID_NEAR": 1.0, "END_NEAR": 1.0},
        },
    },
    "mixture": {"classes": {"host": 1.0}},  # host-only for demo
    # phase-conditional: í›… ì»¨í…ìŠ¤íŠ¸(OP.STATE ë˜ëŠ” OP.STATE.POS) â†’ ë‹¤ìŒ op ë¶„í¬
    "phase_conditional": {
        "READ.ISSUE":              {"READ": 0.00, "PROGRAM": 0.80, "ERASE": 0.20},
        "READ.CORE_BUSY.START":    {"READ": 0.05, "PROGRAM": 0.85, "ERASE": 0.10},
        "READ.CORE_BUSY.MID":      {"READ": 0.10, "PROGRAM": 0.70, "ERASE": 0.20},
        "READ.DATA_OUT.START":     {"READ": 0.60, "PROGRAM": 0.25, "ERASE": 0.15},
        "PROGRAM.ISSUE":           {"READ": 0.50, "PROGRAM": 0.25, "ERASE": 0.25},
        "PROGRAM.CORE_BUSY.END":   {"READ": 0.60, "PROGRAM": 0.10, "ERASE": 0.30},
        "DEFAULT":                 {"READ": 0.60, "PROGRAM": 0.30, "ERASE": 0.10},
    },
    "op_specs": {
        "READ": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 8.0, "std": 1.5, "min": 2.0}},
                {"name": "DATA_OUT", "dist": {"kind": "normal", "mean": 2.0, "std": 0.4, "min": 0.5}},
            ],
            "hooks": [
                {"when": "STATE_START", "states": ["ISSUE", "CORE_BUSY", "DATA_OUT"], "jitter_us": 0.1},
                {"when": "STATE_MID", "states": ["CORE_BUSY"], "jitter_us": 0.2},
                {"when": "STATE_END", "states": ["DATA_OUT"], "jitter_us": 0.1},
            ],
            "phase_offset_us": {"default": 0.0},
        },
        "DOUT": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.2}},
                {"name": "DATA_OUT", "dist": {"kind": "normal", "mean": 1.0, "std": 0.2, "min": 0.2}},
            ],
            "hooks": [
                {"when": "STATE_START", "states": ["DATA_OUT"], "jitter_us": 0.05},
                {"when": "STATE_END", "states": ["DATA_OUT"], "jitter_us": 0.05},
            ],
            "phase_offset_us": {"default": 0.0},
        },
        "PROGRAM": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 20.0, "std": 3.0, "min": 8.0}},
            ],
            "hooks": [{"when": "STATE_END", "states": ["CORE_BUSY"], "jitter_us": 0.2}],
            "phase_offset_us": {"default": 0.0},
        },
        "ERASE": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 40.0, "std": 5.0, "min": 15.0}},
            ],
            "hooks": [{"when": "STATE_END", "states": ["CORE_BUSY"], "jitter_us": 0.2}],
            "phase_offset_us": {"default": 0.0},
        },
    },
    "obligations": [
        {
            "issuer": "READ",
            "require": "DOUT",
            "window_us": {"kind": "normal", "mean": 6.0, "std": 1.5, "min": 1.0},
            "priority_boost": {"start_us_before_deadline": 2.5, "boost_factor": 2.0, "hard_slot": True},
        }
    ],
    "priority": {
        "order": ["HOST", "READ", "DOUT", "ERASE", "PROGRAM_NEW", "PROGRAM_TARGET", "SR", "RESET"],
        "starvation_aging_alpha": 0.01,
    },
    "topology": {"dies": 1, "planes_per_die": 2, "blocks_per_plane": 4, "pages_per_block": 16},
}

# ---------------------------- Models ----------------------------

class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)

@dataclass
class BusySlot:
    start_us: float
    end_us: float
    op: Operation

def _addr_str(a: Address)->str:
    return f"(d{a.die},p{a.plane},b{a.block},pg{a.page})"

# ---------------------------- Utility: Distributions & Phase Keys ----------------------------

def sample_dist(d: Dict[str, Any]) -> float:
    k = d["kind"]
    if k == "fixed":
        return float(d["value"])
    if k == "normal":
        m, s = d["mean"], d["std"]
        mn = d.get("min", 0.0)
        v = random.gauss(m, s)
        return max(v, mn)
    if k == "exp":
        lam = d["lambda"]
        return random.expovariate(lam)
    raise ValueError(f"unknown dist kind: {k}")

def rand_jitter(ampl_us: float) -> float:
    if ampl_us<=0: return 0.0
    return random.uniform(-ampl_us, ampl_us)

def parse_hook_key(label: str):
    # e.g., "READ.CORE_BUSY.START" -> ("READ","CORE_BUSY","START")
    parts = label.split(".")
    if len(parts) >= 3:
        return parts[0], parts[1], parts[2]
    if len(parts) == 2:
        return parts[0], parts[1], None
    return None, None, None  # BOOT/REFILL ë“±

def get_phase_dist(cfg: Dict[str,Any], hook_label: str):
    op, state, pos = parse_hook_key(hook_label)
    pc = cfg.get("phase_conditional", {})
    candidates = []
    if op and state and pos: candidates.append(f"{op}.{state}.{pos}")
    if op and state:         candidates.append(f"{op}.{state}")
    candidates.append("DEFAULT")
    for key in candidates:
        dist = pc.get(key)
        if dist and sum(dist.values()) > 0:
            return dist, key
    return None, None

# ---------------------------- OpSpec: build ops & hooks ----------------------------

def build_operation(kind: OpKind, cfg_op: Dict[str, Any], targets: List[Address]) -> Operation:
    states=[]
    for s in cfg_op["states"]:
        dur = sample_dist(s["dist"])
        states.append(StateSeg(name=s["name"], dur_us=dur))
    return Operation(kind=kind, targets=targets, states=states)

def make_phase_hooks(op: Operation, start_us: float, cfg_op: Dict[str, Any], die:int, plane:int) -> List[PhaseHook]:
    hooks_cfg = cfg_op.get("hooks", [])
    offset = cfg_op.get("phase_offset_us",{}).get("default",0.0)
    base_t = start_us + offset
    hooks=[]
    cur = base_t
    for seg in op.states:
        seg_start = cur
        seg_mid   = cur + seg.dur_us*0.5
        seg_end   = cur + seg.dur_us
        for rule in hooks_cfg:
            if seg.name not in rule["states"]:
                continue
            jitter = rule.get("jitter_us", 0.0)
            if rule["when"]=="STATE_START":
                hooks.append(PhaseHook(time_us=seg_start + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.START", die=die, plane=plane))
            elif rule["when"]=="STATE_MID":
                hooks.append(PhaseHook(time_us=seg_mid   + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.MID",   die=die, plane=plane))
            elif rule["when"]=="STATE_END":
                hooks.append(PhaseHook(time_us=seg_end   + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.END",   die=die, plane=plane))
        cur = seg_end
    return hooks

# ---------------------------- Address Manager ----------------------------

class AddressManager:
    def __init__(self, cfg: Dict[str, Any]):
        topo = cfg["topology"]
        self.dies = topo["dies"]
        self.planes = topo["planes_per_die"]
        # plane availability absolute times
        self.available: Dict[Tuple[int,int], float] = {(0,p): 0.0 for p in range(self.planes)}
        # rotating cursors per plane
        self.cursors: Dict[Tuple[int,int], List[int]] = {(0,p): [0,0,0] for p in range(self.planes)}  # [block, next_pgm_page, next_rd_page]
        self.pages_per_block = topo["pages_per_block"]
        self.blocks_per_plane = topo["blocks_per_plane"]
        # simplistic programmed set per plane
        self.programmed: Dict[Tuple[int,int], Set[Tuple[int,int]]] = {(0,p): set() for p in range(self.planes)}
        # reservation table per plane: list of (start,end,block)
        self.resv: Dict[Tuple[int,int], List[Tuple[float,float,Optional[int]]]] = {(0,p): [] for p in range(self.planes)}

    # ---- observation / selection / checks ----

    def available_at(self, die:int, plane:int) -> float:
        return self.available[(die,plane)]

    def observe_states(self, die:int, plane:int, now_us: float):
        prog = len(self.programmed[(die,plane)])
        # naive buckets for demo
        pgmable_ratio  = "mid" if prog < 10 else "low"
        readable_ratio = "mid" if prog > 0 else "low"
        plane_busy_frac = "high" if self.available_at(die,plane) > now_us else "low"
        return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls": "host"},
                {"plane_busy_frac": plane_busy_frac})

    def select(self, kind: OpKind, die:int, plane:int) -> List[Address]:
        if kind == OpKind.READ:
            prog = sorted(self.programmed[(die,plane)])
            tgt = prog[0] if prog else (0,0)
            return [Address(die, plane, block=tgt[0], page=tgt[1])]
        if kind == OpKind.DOUT:
            raise RuntimeError("DOUT selection must be provided by obligation targets")
        if kind == OpKind.PROGRAM:
            b, pgm_p, _ = self.cursors[(die,plane)]
            addr = Address(die, plane, block=b, page=pgm_p)
            # advance cursor
            pgm_p += 1
            if pgm_p >= self.pages_per_block:
                pgm_p = 0
                b = (b+1) % self.blocks_per_plane
            self.cursors[(die,plane)] = [b, pgm_p, self.cursors[(die,plane)][2]]
            return [addr]
        if kind == OpKind.ERASE:
            b = self.cursors[(die,plane)][0]
            return [Address(die, plane, block=b, page=None)]
        return [Address(die, plane, block=0, page=0)]

    def precheck(self, kind: OpKind, targets: List[Address], start_hint: float) -> bool:
        """Minimal feasibility check: time overlap + simple block rule."""
        MIN_GUARD = 0.0
        end_hint = start_hint + MIN_GUARD
        # 1) time overlap across all planes in targets
        seen_planes = set()
        for t in targets:
            key = (t.die, t.plane)
            if key in seen_planes: 
                continue
            seen_planes.add(key)
            for (s,e,_) in self.resv[key]:
                if not (end_hint <= s or e <= start_hint):
                    return False
        # 2) simple block rule (placeholder)
        return True

    # ---- reserve / commit ----

    def reserve(self, die:int, plane:int, start:float, end:float, block: Optional[int]=None):
        self.available[(die,plane)] = max(self.available[(die,plane)], end)
        self.resv[(die,plane)].append((start, end, block))

    def commit(self, op: Operation):
        t = op.targets[0]
        key = (t.die, t.plane)
        if op.kind == OpKind.PROGRAM and t.page is not None:
            self.programmed[key].add((t.block, t.page))
        elif op.kind == OpKind.ERASE:
            # erase whole block
            self.programmed[key] = {pp for pp in self.programmed[key] if pp[0] != t.block}

# ---------------------------- Obligation Manager ----------------------------

@dataclass(order=True)
class _ObHeapItem:
    deadline_us: float
    seq: int
    ob: "Obligation" = field(compare=False)

@dataclass
class Obligation:
    require: OpKind
    targets: List[Address]
    deadline_us: float
    boost_factor: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg_list: List[Dict[str,Any]]):
        self.specs = cfg_list
        self.heap: List[_ObHeapItem] = []
        self._seq = 0

    def on_commit(self, op: Operation, now_us: float):
        for spec in self.specs:
            if spec["issuer"] == op.kind.name:
                dt = sample_dist(spec["window_us"])
                ob = Obligation(
                    require = OpKind[spec["require"]],
                    targets = op.targets,
                    deadline_us = now_us + dt,
                    boost_factor = spec["priority_boost"]["boost_factor"],
                    hard_slot = spec["priority_boost"].get("hard_slot", False),
                )
                heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=self._seq, ob=ob))
                self._seq += 1
                print(f"[{now_us:7.2f} us] OBLIG  created: {op.kind.name} -> {ob.require.name} by {ob.deadline_us:7.2f} us, target={_addr_str(ob.targets[0])}")

    def pop_urgent(self, now_us: float, die:int, plane:int,
                   horizon_us: float, earliest_start: float) -> Optional[Obligation]:
        """Return earliest-deadline obligation for this (die,plane) that we still can start by earliest_start."""
        if not self.heap: 
            return None
        kept: List[_ObHeapItem] = []
        chosen: Optional[Obligation] = None
        while self.heap and not chosen:
            item = heapq.heappop(self.heap)
            ob = item.ob
            tgt = ob.targets[0]
            same_plane = (tgt.die == die and tgt.plane == plane)
            in_horizon = ((ob.deadline_us - now_us) <= max(horizon_us, 0.0)) or ob.hard_slot
            feasible_time = (earliest_start <= ob.deadline_us)  # coarse feasibility
            if same_plane and in_horizon and feasible_time:
                chosen = ob
                break
            kept.append(item)
        for it in kept:
            heapq.heappush(self.heap, it)
        return chosen

# ---------------------------- Policy Engine ----------------------------

class PolicyEngine:
    def __init__(self, cfg, addr_mgr: AddressManager, obl_mgr: ObligationManager):
        self.cfg = cfg
        self.addr = addr_mgr
        self.obl = obl_mgr

    def _score(self, op_name: str, phase_label: str, global_state: Dict[str,str], local_state: Dict[str,str]) -> float:
        w = self.cfg["weights"]["base"]["host"].get(op_name, 0.0)
        w *= self.cfg["weights"]["g_state"]["pgmable_ratio"].get(global_state["pgmable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_state"]["readable_ratio"].get(global_state["readable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_local"]["plane_busy_frac"].get(local_state["plane_busy_frac"], 1.0)
        near = "MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w *= self.cfg["weights"]["g_phase"].get(op_name, {}).get(near, 1.0)
        return w

    def _roulette(self, dist: Dict[str, float], allow: set) -> Optional[str]:
        items = [(name, p) for name, p in dist.items() if name in allow and p > 0.0]
        if not items: 
            return None
        total = sum(p for _, p in items)
        r = random.random() * total
        acc = 0.0
        pick = items[-1][0]
        for name, p in items:
            acc += p
            if r <= acc:
                pick = name; break
        return pick

    def propose(self, now_us: float, hook: PhaseHook,
                global_state: Dict[str,str], local_state: Dict[str,str],
                earliest_start: float) -> Optional[Operation]:
        # 0) Obligation first (plane/time filtered)
        ob = self.obl.pop_urgent(now_us, hook.die, hook.plane,
                                 horizon_us=10.0, earliest_start=earliest_start)
        if ob:
            if self.addr.precheck(ob.require, ob.targets, start_hint=earliest_start):
                cfg_op = self.cfg["op_specs"][ob.require.name]
                op = build_operation(ob.require, cfg_op, ob.targets)
                op.meta["source"]="obligation"
                op.meta["phase_key_used"]="(obligation)"
                return op
            # else: could attempt alternative targets (omitted in demo)

        # 1) Phase-conditional distribution (OP.STATE.POS â†’ OP.STATE â†’ DEFAULT)
        allow = set(self.cfg["op_specs"].keys()) - {"DOUT"}  # DOUTëŠ” ì˜ë¬´ ê¸°ë³¸
        dist, used_key = get_phase_dist(self.cfg, hook.label)
        if dist:
            pick = self._roulette(dist, allow)
            if pick:
                kind = OpKind[pick]
                targets = self.addr.select(kind, hook.die, hook.plane)
                if targets and self.addr.precheck(kind, targets, start_hint=earliest_start):
                    op = build_operation(kind, self.cfg["op_specs"][pick], targets)
                    op.meta["source"]="policy.phase_conditional"
                    op.meta["phase_key_used"]=used_key
                    return op
            # distê°€ ìˆì–´ë„ íƒ€ê¹ƒ/ì‚¬ì „ê²€ì‚¬ ì‹¤íŒ¨ ì‹œ score ë°±ì˜¤í”„ ì‹œë„

        # 2) Backoff: ê¸°ì¡´ ê³±ì…ˆ ê°€ì¤‘(score) ë°©ì‹
        cand = []
        for name in ["READ", "PROGRAM", "ERASE"]:
            s = self._score(name, hook.label, global_state, local_state)
            if s>0: cand.append((name, s))
        if not cand: return None
        total = sum(s for _,s in cand)
        r = random.random()*total
        acc=0.0
        pick = cand[-1][0]
        for name, s in cand:
            acc += s
            if r <= acc:
                pick=name; break

        kind = OpKind[pick]
        targets = self.addr.select(kind, hook.die, hook.plane)
        if not targets:
            return None
        if not self.addr.precheck(kind, targets, start_hint=earliest_start):
            return None
        op = build_operation(kind, self.cfg["op_specs"][pick], targets)
        op.meta["source"]="policy.score_backoff"
        op.meta["phase_key_used"]="(score_backoff)"
        return op

# ---------------------------- Scheduler ----------------------------

class Scheduler:
    def __init__(self, cfg, addr_mgr: AddressManager, policy_engine: PolicyEngine, obl_mgr: ObligationManager):
        self.cfg=cfg; self.addr=addr_mgr; self.SPE=policy_engine; self.obl=obl_mgr
        self.now=0.0
        self.ev=[]  # (time, seq, type, payload)
        self._seq=0
        self.stat_propose_calls = 0
        self.stat_scheduled = 0
        self._push(0.0, "QUEUE_REFILL", None)
        # Bootstrap hooks per plane
        for plane in range(self.addr.planes):
            self._push(0.0, "PHASE_HOOK", PhaseHook(0.0, "BOOT.START", 0, plane))

    def _push(self, t: float, typ: str, payload: Any):
        heapq.heappush(self.ev, (t, self._seq, typ, payload)); self._seq+=1

    def _unique_plane_keys(self, targets: List[Address]) -> List[Tuple[int,int,int]]:
        # (die, plane, block) tuples deduped
        s=set()
        for a in targets:
            s.add((a.die, a.plane, a.block))
        return list(s)

    def _start_time_for_targets(self, targets: List[Address]) -> float:
        # start cannot be earlier than any involved plane's availability
        planes = {(a.die, a.plane) for a in targets}
        avail = [self.addr.available_at(d,p) for (d,p) in planes]
        return max([self.now] + avail)

    def _schedule_operation(self, op: Operation):
        start = self._start_time_for_targets(op.targets)
        dur = sum(seg.dur_us for seg in op.states)
        end  = start + dur
        # reserve for all involved planes
        for d,p,b in self._unique_plane_keys(op.targets):
            self.addr.reserve(d, p, start, end, block=b)
        # events
        self._push(start, "OP_START", op)
        self._push(end,   "OP_END",   op)
        # hooks for each involved plane
        for d,p,_ in self._unique_plane_keys(op.targets):
            hooks = make_phase_hooks(op, start, self.cfg["op_specs"][op.kind.name], d, p)
            for h in hooks:
                self._push(h.time_us, "PHASE_HOOK", h)
        first = op.targets[0]
        print(f"[{self.now:7.2f} us] SCHED  {op.kind.name:7s} on targets={len(op.targets)} start={start:7.2f} end={end:7.2f} 1st={_addr_str(first)} src={op.meta.get('source')} key={op.meta.get('phase_key_used')}")
        self.stat_scheduled += 1

    def run_until(self, t_end: float):
        while self.ev and self.ev[0][0] <= t_end:
            self.now, _, typ, payload = heapq.heappop(self.ev)
            if typ=="QUEUE_REFILL":
                # seed hooks to keep flow
                for plane in range(self.addr.planes):
                    self._push(self.now, "PHASE_HOOK", PhaseHook(self.now, "REFILL.NUDGE", 0, plane))
                nxt = self.now + self.cfg["policy"]["queue_refill_period_us"]
                self._push(nxt, "QUEUE_REFILL", None)

            elif typ=="PHASE_HOOK":
                hook: PhaseHook = payload
                earliest_start = self.addr.available_at(hook.die, hook.plane)
                global_state, local_state = self.addr.observe_states(hook.die, hook.plane, self.now)
                self.stat_propose_calls += 1
                op = self.SPE.propose(self.now, hook, global_state, local_state, earliest_start)
                if op:
                    self._schedule_operation(op)
                else:
                    # no viable op at this hook; that's fine
                    pass

            elif typ=="OP_START":
                op: Operation = payload
                first = op.targets[0]
                print(f"[{self.now:7.2f} us] START  {op.kind.name:7s} target={_addr_str(first)}")

            elif typ=="OP_END":
                op: Operation = payload
                first = op.targets[0]
                print(f"[{self.now:7.2f} us] END    {op.kind.name:7s} target={_addr_str(first)}")
                # commit state first
                self.addr.commit(op)
                # then obligations
                self.obl.on_commit(op, self.now)

        # summary
        print(f"\n=== Stats ===")
        print(f"propose calls : {self.stat_propose_calls}")
        print(f"scheduled ops : {self.stat_scheduled}")
        if self.stat_propose_calls:
            rate = 100.0 * self.stat_scheduled / self.stat_propose_calls
            print(f"accept ratio  : {rate:.1f}%")

# ---------------------------- Main ----------------------------

def main():
    random.seed(CFG["rng_seed"])
    addr = AddressManager(CFG)
    obl  = ObligationManager(CFG["obligations"])
    spe  = PolicyEngine(CFG, addr, obl)
    sch  = Scheduler(CFG, addr, spe, obl)
    run_until = CFG["policy"]["run_until_us"]
    print("=== NAND Sequence Generator Demo (P0 + Phase-Conditional) ===")
    sch.run_until(run_until)
    print("=== Done ===")

if __name__ == "__main__":
    main()

```

ë©”ëª¨
- CFG["phase_conditional"]ì—ì„œ ì •ì˜ë˜ì§€ ì•Šì€ í›…ì€ ìë™ìœ¼ë¡œ DEFAULT â†’ (ì—†ê±°ë‚˜ í•©ì´ 0ì´ë©´) ê¸°ì¡´ ê°€ì¤‘(score) ë°©ì‹ìœ¼ë¡œ ë°±ì˜¤í”„í•©ë‹ˆë‹¤.
- DOUTì€ ì—¬ì „íˆ ì˜ë¬´(READâ†’DOUT) ë¡œë§Œ ë°œìƒí•˜ë„ë¡ í•„í„°ë§ë˜ì–´ ìˆì–´ìš”. í•„ìš”í•˜ë©´ ë¶„í¬ì— ë„£ì„ ìˆ˜ë„ ìˆì§€ë§Œ, í˜„ì¬ êµ¬ì¡°ì—ì„œëŠ” ì˜ë¬´ ìš°ì„  ê·œì¹™ì´ ìì—°ìŠ¤ëŸ½ìŠµë‹ˆë‹¤.
- ì–´ë–¤ phase í‚¤ê°€ ì‹¤ì œë¡œ ì“°ì˜€ëŠ”ì§€ëŠ” key=... ë¡œ ë¡œê·¸ì— í‘œì‹œë©ë‹ˆë‹¤.

ì›í•˜ë©´ ì—¬ê¸°ì— ì‹œê°„ ì–‘ìí™”(quantize), duration ë˜í¼, fanout/interleave ì˜µì…˜ê¹Œì§€ ì´ì–´ì„œ ë¬¶ì–´ì¤„ê²Œ.

## ğŸ‘¤ User

ë¬¶ì–´ì„œ ì œê³µí•´ì¤˜.

## ğŸ¤– Assistant

ì¢‹ì•„â€”ìš”ì²­í•œ í•­ëª©ì„ í•œ íŒŒì¼ì— ëª¨ë‘ ë¬¶ì€ í†µí•©ë³¸ì´ì•¼.  

í¬í•¨ëœ ê°œì„ ì‚¬í•­:
- Phase-ì¡°ê±´ ë¶„í¬(í›… ë¼ë²¨ OP.STATE(.POS) â†’ ë‹¤ìŒ op í™•ë¥ )
- ì‹œê°„ ì–‘ìí™”(SIM_RES_US, quantize)
- duration ë˜í¼(get_op_duration)
- multi-plane fanout / interleave (config ê¸°ë°˜, AddressManager.select(..., fanout, interleave))

íŒŒì¼ëª… ì˜ˆ: nandsim_demo_p1_bundle.py

```python
# nandsim_demo_p1_bundle.py â€” Phase-conditional + Quantize + Duration wrapper + Multi-plane fanout/interleave
# Stdlib only.

from __future__ import annotations
import heapq, random
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple, Set

# ---------------------------- Simulation Resolution ----------------------------
SIM_RES_US = 0.01
def quantize(t: float) -> float:
    return round(t / SIM_RES_US) * SIM_RES_US

# ---------------------------- Config ----------------------------

CFG = {
    "rng_seed": 12345,
    "policy": {
        "queue_refill_period_us": 3.0,
        "lookahead_k": 4,
        "run_until_us": 180.0,
    },
    # backoff weights (phase-conditional ë¯¸ì¡´ì¬/0í•©ì¼ ë•Œ ì‚¬ìš©)
    "weights": {
        "base": {"host": {"READ": 0.85, "PROGRAM": 0.10, "ERASE": 0.05, "SR": 0.00, "RESET": 0.00, "DOUT": 0.00}},
        "g_state": {"pgmable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.8},
                    "readable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.9}},
        "g_local": {"plane_busy_frac": {"low": 1.2, "mid": 1.0, "high": 0.9}},
        "g_phase": {
            "READ": {"START_NEAR": 1.2, "MID_NEAR": 0.9, "END_NEAR": 1.2},
            "PROGRAM": {"START_NEAR": 1.1, "MID_NEAR": 1.0, "END_NEAR": 0.9},
            "ERASE": {"START_NEAR": 0.9, "MID_NEAR": 1.1, "END_NEAR": 1.1},
            "SR": {"START_NEAR": 1.0, "MID_NEAR": 1.0, "END_NEAR": 1.0},
            "RESET": {"START_NEAR": 1.0, "MID_NEAR": 1.0, "END_NEAR": 1.0},
        },
    },
    "mixture": {"classes": {"host": 1.0}},  # demo: host only
    # í˜„ì¬ í›… ì»¨í…ìŠ¤íŠ¸(OP.STATE ë˜ëŠ” OP.STATE.POS) â†’ ë‹¤ìŒ op í™•ë¥ 
    "phase_conditional": {
        "READ.ISSUE":              {"READ": 0.00, "PROGRAM": 0.80, "ERASE": 0.20},
        "READ.CORE_BUSY.START":    {"READ": 0.05, "PROGRAM": 0.85, "ERASE": 0.10},
        "READ.CORE_BUSY.MID":      {"READ": 0.10, "PROGRAM": 0.70, "ERASE": 0.20},
        "READ.DATA_OUT.START":     {"READ": 0.60, "PROGRAM": 0.25, "ERASE": 0.15},
        "PROGRAM.ISSUE":           {"READ": 0.50, "PROGRAM": 0.25, "ERASE": 0.25},
        "PROGRAM.CORE_BUSY.END":   {"READ": 0.60, "PROGRAM": 0.10, "ERASE": 0.30},
        "DEFAULT":                 {"READ": 0.60, "PROGRAM": 0.30, "ERASE": 0.10},
    },
    # fanout / interleave ì •ì±… (phaseë³„ override ì§€ì›)
    "selection": {
        "defaults": {
            "READ":    {"fanout": 1, "interleave": True},
            "PROGRAM": {"fanout": 1, "interleave": True},
            "ERASE":   {"fanout": 1, "interleave": False},
        },
        # OP.STATE(.POS) â†’ {fanout, interleave} override
        "phase_overrides": {
            "READ.CORE_BUSY.START": {"fanout": 2, "interleave": True},  # ì˜ˆ: CORE_BUSY ì‹œì‘ì—” 2-plane READ
        }
    },
    "op_specs": {
        "READ": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 8.0, "std": 1.5, "min": 2.0}},
                {"name": "DATA_OUT", "dist": {"kind": "normal", "mean": 2.0, "std": 0.4, "min": 0.5}},
            ],
            "hooks": [
                {"when": "STATE_START", "states": ["ISSUE", "CORE_BUSY", "DATA_OUT"], "jitter_us": 0.1},
                {"when": "STATE_MID", "states": ["CORE_BUSY"], "jitter_us": 0.2},
                {"when": "STATE_END", "states": ["DATA_OUT"], "jitter_us": 0.1},
            ],
            "phase_offset_us": {"default": 0.0},
        },
        "DOUT": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.2}},
                {"name": "DATA_OUT", "dist": {"kind": "normal", "mean": 1.0, "std": 0.2, "min": 0.2}},
            ],
            "hooks": [
                {"when": "STATE_START", "states": ["DATA_OUT"], "jitter_us": 0.05},
                {"when": "STATE_END", "states": ["DATA_OUT"], "jitter_us": 0.05},
            ],
            "phase_offset_us": {"default": 0.0},
        },
        "PROGRAM": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 20.0, "std": 3.0, "min": 8.0}},
            ],
            "hooks": [{"when": "STATE_END", "states": ["CORE_BUSY"], "jitter_us": 0.2}],
            "phase_offset_us": {"default": 0.0},
        },
        "ERASE": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 40.0, "std": 5.0, "min": 15.0}},
            ],
            "hooks": [{"when": "STATE_END", "states": ["CORE_BUSY"], "jitter_us": 0.2}],
            "phase_offset_us": {"default": 0.0},
        },
    },
    "obligations": [
        {
            "issuer": "READ",
            "require": "DOUT",
            "window_us": {"kind": "normal", "mean": 6.0, "std": 1.5, "min": 1.0},
            "priority_boost": {"start_us_before_deadline": 2.5, "boost_factor": 2.0, "hard_slot": True},
        }
    ],
    "priority": {
        "order": ["HOST", "READ", "DOUT", "ERASE", "PROGRAM_NEW", "PROGRAM_TARGET", "SR", "RESET"],
        "starvation_aging_alpha": 0.01,
    },
    "topology": {"dies": 1, "planes_per_die": 4, "blocks_per_plane": 8, "pages_per_block": 16},
}

# ---------------------------- Models ----------------------------

class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)

@dataclass
class BusySlot:
    start_us: float
    end_us: float
    op: Operation

def _addr_str(a: Address)->str:
    return f"(d{a.die},p{a.plane},b{a.block},pg{a.page})"

# ---------------------------- Utility ----------------------------

def sample_dist(d: Dict[str, Any]) -> float:
    k = d["kind"]
    if k == "fixed":
        return float(d["value"])
    if k == "normal":
        m, s = d["mean"], d["std"]
        mn = d.get("min", 0.0)
        v = random.gauss(m, s)
        return max(v, mn)
    if k == "exp":
        lam = d["lambda"]
        return random.expovariate(lam)
    raise ValueError(f"unknown dist kind: {k}")

def rand_jitter(ampl_us: float) -> float:
    if ampl_us<=0: return 0.0
    return random.uniform(-ampl_us, ampl_us)

def parse_hook_key(label: str):
    # e.g., "READ.CORE_BUSY.START" -> ("READ","CORE_BUSY","START")
    parts = label.split(".")
    if len(parts) >= 3:
        return parts[0], parts[1], parts[2]
    if len(parts) == 2:
        return parts[0], parts[1], None
    return None, None, None  # BOOT/REFILL ë“± ë¹„ì •í˜• í›…

def get_phase_dist(cfg: Dict[str,Any], hook_label: str):
    op, state, pos = parse_hook_key(hook_label)
    pc = cfg.get("phase_conditional", {})
    candidates = []
    if op and state and pos: candidates.append(f"{op}.{state}.{pos}")
    if op and state:         candidates.append(f"{op}.{state}")
    candidates.append("DEFAULT")
    for key in candidates:
        dist = pc.get(key)
        if dist and sum(dist.values()) > 0:
            return dist, key
    return None, None

def get_phase_selection_override(cfg: Dict[str,Any], hook_label: str, kind_name: str):
    # fanout/interleave ê²°ì •: phase override > defaults
    op, state, pos = parse_hook_key(hook_label)
    po = cfg.get("selection", {}).get("phase_overrides", {})
    keys = []
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    for k in keys:
        val = po.get(k)
        if val:
            f = int(val.get("fanout", 1))
            iv = bool(val.get("interleave", True))
            return f, iv
    dflt = cfg.get("selection", {}).get("defaults", {}).get(kind_name, {"fanout":1,"interleave":True})
    return int(dflt.get("fanout",1)), bool(dflt.get("interleave", True))

def get_op_duration(op: Operation) -> float:
    # wrapper: í˜„ì¬ëŠ” ìƒëŒ€ duration í•©, ì¶”í›„ StateSeq.times(ì ˆëŒ€)ë¡œ ëŒ€ì²´ ê°€ëŠ¥
    return sum(seg.dur_us for seg in op.states)

# ---------------------------- OpSpec: build ops & hooks ----------------------------

def build_operation(kind: OpKind, cfg_op: Dict[str, Any], targets: List[Address]) -> Operation:
    states=[]
    for s in cfg_op["states"]:
        dur = sample_dist(s["dist"])
        states.append(StateSeg(name=s["name"], dur_us=dur))
    return Operation(kind=kind, targets=targets, states=states)

def make_phase_hooks(cfg: Dict[str,Any], op: Operation, start_us: float, die:int, plane:int) -> List[PhaseHook]:
    cfg_op = cfg["op_specs"][op.kind.name]
    hooks_cfg = cfg_op.get("hooks", [])
    offset = cfg_op.get("phase_offset_us",{}).get("default",0.0)
    base_t = start_us + offset
    hooks=[]
    cur = base_t
    for seg in op.states:
        seg_start = cur
        seg_mid   = cur + seg.dur_us*0.5
        seg_end   = cur + seg.dur_us
        for rule in hooks_cfg:
            if seg.name not in rule["states"]:
                continue
            jitter = rule.get("jitter_us", 0.0)
            if rule["when"]=="STATE_START":
                hooks.append(PhaseHook(time_us=quantize(seg_start + rand_jitter(jitter)), label=f"{op.kind.name}.{seg.name}.START", die=die, plane=plane))
            elif rule["when"]=="STATE_MID":
                hooks.append(PhaseHook(time_us=quantize(seg_mid   + rand_jitter(jitter)), label=f"{op.kind.name}.{seg.name}.MID",   die=die, plane=plane))
            elif rule["when"]=="STATE_END":
                hooks.append(PhaseHook(time_us=quantize(seg_end   + rand_jitter(jitter)), label=f"{op.kind.name}.{seg.name}.END",   die=die, plane=plane))
        cur = seg_end
    return hooks

# ---------------------------- Address Manager ----------------------------

class AddressManager:
    def __init__(self, cfg: Dict[str, Any]):
        topo = cfg["topology"]
        self.cfg = cfg
        self.dies = topo["dies"]
        self.planes = topo["planes_per_die"]
        self.pages_per_block = topo["pages_per_block"]
        self.blocks_per_plane = topo["blocks_per_plane"]

        self.available: Dict[Tuple[int,int], float] = {(0,p): 0.0 for p in range(self.planes)}
        self.cursors: Dict[Tuple[int,int], List[int]] = {(0,p): [0,0,0] for p in range(self.planes)}  # [block, next_pgm_page, next_rd_page]
        self.programmed: Dict[Tuple[int,int], Set[Tuple[int,int]]] = {(0,p): set() for p in range(self.planes)}
        self.resv: Dict[Tuple[int,int], List[Tuple[float,float,Optional[int]]]] = {(0,p): [] for p in range(self.planes)}

    # ---- observation / selection / checks ----

    def available_at(self, die:int, plane:int) -> float:
        return self.available[(die,plane)]

    def observe_states(self, die:int, plane:int, now_us: float):
        prog = len(self.programmed[(die,plane)])
        pgmable_ratio  = "mid" if prog < 10 else "low"
        readable_ratio = "mid" if prog > 0 else "low"
        plane_busy_frac = "high" if self.available_at(die,plane) > now_us else "low"
        return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls": "host"},
                {"plane_busy_frac": plane_busy_frac})

    def _plane_ring(self, start_plane:int, fanout:int, interleave:bool) -> List[int]:
        # interleave=Trueë©´ start_planeë¶€í„° ì‹œê³„ë°©í–¥ìœ¼ë¡œ fanoutê°œ ì„ íƒ
        if fanout <= 1:
            return [start_plane]
        ring = []
        P = self.planes
        idx = start_plane
        for _ in range(fanout):
            ring.append(idx)
            idx = (idx + 1) % P  # ê°„ë‹¨ ì¸ì ‘ ë¶„ì‚°
        return ring

    def select(self, kind: OpKind, die:int, plane:int, fanout:int=1, interleave:bool=True) -> List[Address]:
        planes = self._plane_ring(plane, fanout, interleave)
        targets: List[Address] = []
        for pl in planes:
            if kind == OpKind.READ:
                prog = sorted(self.programmed[(die,pl)])
                tgt = prog[0] if prog else (0,0)
                targets.append(Address(die, pl, block=tgt[0], page=tgt[1]))
            elif kind == OpKind.DOUT:
                raise RuntimeError("DOUT selection must be provided by obligation targets")
            elif kind == OpKind.PROGRAM:
                b, pgm_p, _ = self.cursors[(die,pl)]
                targets.append(Address(die, pl, block=b, page=pgm_p))
                # advance cursor
                pgm_p += 1
                if pgm_p >= self.pages_per_block:
                    pgm_p = 0
                    b = (b+1) % self.blocks_per_plane
                self.cursors[(die,pl)] = [b, pgm_p, self.cursors[(die,pl)][2]]
            elif kind == OpKind.ERASE:
                b = self.cursors[(die,pl)][0]
                targets.append(Address(die, pl, block=b, page=None))
            else:
                targets.append(Address(die, pl, block=0, page=0))
        return targets

    def precheck(self, kind: OpKind, targets: List[Address], start_hint: float) -> bool:
        """Minimal feasibility check: time overlap + simple block rule placeholder."""
        start_hint = quantize(start_hint)
        end_hint = start_hint  # guard 0 for now
        seen_planes = set()
        for t in targets:
            key = (t.die, t.plane)
            if key in seen_planes: 
                continue
            seen_planes.add(key)
            for (s,e,_) in self.resv[key]:
                if not (end_hint <= s or e <= start_hint):
                    return False
        # TODO: extend with scope rules (block/page conflicts)
        return True

    def reserve(self, die:int, plane:int, start:float, end:float, block: Optional[int]=None):
        start = quantize(start); end = quantize(end)
        self.available[(die,plane)] = max(self.available[(die,plane)], end)
        self.resv[(die,plane)].append((start, end, block))

    def commit(self, op: Operation):
        t = op.targets[0]
        key = (t.die, t.plane)
        if op.kind == OpKind.PROGRAM and t.page is not None:
            self.programmed[key].add((t.block, t.page))
        elif op.kind == OpKind.ERASE:
            self.programmed[key] = {pp for pp in self.programmed[key] if pp[0] != t.block}

# ---------------------------- Obligation Manager ----------------------------

@dataclass(order=True)
class _ObHeapItem:
    deadline_us: float
    seq: int
    ob: "Obligation" = field(compare=False)

@dataclass
class Obligation:
    require: OpKind
    targets: List[Address]
    deadline_us: float
    boost_factor: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg_list: List[Dict[str,Any]]):
        self.specs = cfg_list
        self.heap: List[_ObHeapItem] = []
        self._seq = 0

    def on_commit(self, op: Operation, now_us: float):
        for spec in self.specs:
            if spec["issuer"] == op.kind.name:
                dt = sample_dist(spec["window_us"])
                ob = Obligation(
                    require = OpKind[spec["require"]],
                    targets = op.targets,
                    deadline_us = quantize(now_us + dt),
                    boost_factor = spec["priority_boost"]["boost_factor"],
                    hard_slot = spec["priority_boost"].get("hard_slot", False),
                )
                heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=self._seq, ob=ob))
                self._seq += 1
                print(f"[{now_us:7.2f} us] OBLIG  created: {op.kind.name} -> {ob.require.name} by {ob.deadline_us:7.2f} us, target={_addr_str(ob.targets[0])}")

    def pop_urgent(self, now_us: float, die:int, plane:int,
                   horizon_us: float, earliest_start: float) -> Optional[Obligation]:
        """Earliest-deadline obligation for this (die,plane) feasible at earliest_start."""
        if not self.heap: 
            return None
        kept: List[_ObHeapItem] = []
        chosen: Optional[Obligation] = None
        now_us = quantize(now_us)
        earliest_start = quantize(earliest_start)
        while self.heap and not chosen:
            item = heapq.heappop(self.heap)
            ob = item.ob
            tgt = ob.targets[0]
            same_plane = (tgt.die == die and tgt.plane == plane)
            in_horizon = ((ob.deadline_us - now_us) <= max(horizon_us, 0.0)) or ob.hard_slot
            feasible_time = (earliest_start <= ob.deadline_us)
            if same_plane and in_horizon and feasible_time:
                chosen = ob
                break
            kept.append(item)
        for it in kept:
            heapq.heappush(self.heap, it)
        return chosen

# ---------------------------- Policy Engine ----------------------------

class PolicyEngine:
    def __init__(self, cfg, addr_mgr: AddressManager, obl_mgr: ObligationManager):
        self.cfg = cfg
        self.addr = addr_mgr
        self.obl = obl_mgr

    def _score(self, op_name: str, phase_label: str, global_state: Dict[str,str], local_state: Dict[str,str]) -> float:
        w = self.cfg["weights"]["base"]["host"].get(op_name, 0.0)
        w *= self.cfg["weights"]["g_state"]["pgmable_ratio"].get(global_state["pgmable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_state"]["readable_ratio"].get(global_state["readable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_local"]["plane_busy_frac"].get(local_state["plane_busy_frac"], 1.0)
        near = "MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w *= self.cfg["weights"]["g_phase"].get(op_name, {}).get(near, 1.0)
        return w

    def _roulette(self, dist: Dict[str, float], allow: set) -> Optional[str]:
        items = [(name, p) for name, p in dist.items() if name in allow and p > 0.0]
        if not items: 
            return None
        total = sum(p for _, p in items)
        r = random.random() * total
        acc = 0.0
        pick = items[-1][0]
        for name, p in items:
            acc += p
            if r <= acc:
                pick = name; break
        return pick

    def propose(self, now_us: float, hook: PhaseHook,
                global_state: Dict[str,str], local_state: Dict[str,str],
                earliest_start: float) -> Optional[Operation]:
        # 0) Obligation ìš°ì„  (plane/time í•„í„°)
        ob = self.obl.pop_urgent(now_us, hook.die, hook.plane,
                                 horizon_us=10.0, earliest_start=earliest_start)
        if ob:
            if self.addr.precheck(ob.require, ob.targets, start_hint=earliest_start):
                cfg_op = self.cfg["op_specs"][ob.require.name]
                op = build_operation(ob.require, cfg_op, ob.targets)
                op.meta["source"]="obligation"
                op.meta["phase_key_used"]="(obligation)"
                return op

        # 1) Phase-conditional ë¶„í¬ ì‹œë„
        allow = set(self.cfg["op_specs"].keys()) - {"DOUT"}  # DOUTì€ ì˜ë¬´ ê¸°ë³¸
        dist, used_key = get_phase_dist(self.cfg, hook.label)
        fanout, interleave = get_phase_selection_override(self.cfg, hook.label, "<DEFAULT>")
        if dist:
            pick = self._roulette(dist, allow)
            if pick:
                fanout, interleave = get_phase_selection_override(self.cfg, hook.label, pick)
                kind = OpKind[pick]
                targets = self.addr.select(kind, hook.die, hook.plane, fanout=fanout, interleave=interleave)
                if targets and self.addr.precheck(kind, targets, start_hint=earliest_start):
                    op = build_operation(kind, self.cfg["op_specs"][pick], targets)
                    op.meta["source"]="policy.phase_conditional"
                    op.meta["phase_key_used"]=used_key
                    op.meta["fanout"]=fanout; op.meta["interleave"]=interleave
                    return op
            # ì‹¤íŒ¨ ì‹œ score ë°±ì˜¤í”„

        # 2) Backoff: ê¸°ì¡´ ê³±ì…ˆ ê°€ì¤‘(score)
        cand = []
        for name in ["READ", "PROGRAM", "ERASE"]:
            s = self._score(name, hook.label, global_state, local_state)
            if s>0: cand.append((name, s))
        if not cand: return None
        total = sum(s for _,s in cand)
        r = random.random()*total
        acc=0.0
        pick = cand[-1][0]
        for name, s in cand:
            acc += s
            if r <= acc:
                pick=name; break

        kind = OpKind[pick]
        fanout, interleave = get_phase_selection_override(self.cfg, hook.label, pick)
        targets = self.addr.select(kind, hook.die, hook.plane, fanout=fanout, interleave=interleave)
        if not targets:
            return None
        if not self.addr.precheck(kind, targets, start_hint=earliest_start):
            return None
        op = build_operation(kind, self.cfg["op_specs"][pick], targets)
        op.meta["source"]="policy.score_backoff"
        op.meta["phase_key_used"]="(score_backoff)"
        op.meta["fanout"]=fanout; op.meta["interleave"]=interleave
        return op

# ---------------------------- Scheduler ----------------------------

class Scheduler:
    def __init__(self, cfg, addr_mgr: AddressManager, policy_engine: PolicyEngine, obl_mgr: ObligationManager):
        self.cfg=cfg; self.addr=addr_mgr; self.SPE=policy_engine; self.obl=obl_mgr
        self.now=0.0
        self.ev=[]  # (time, seq, type, payload)
        self._seq=0
        self.stat_propose_calls = 0
        self.stat_scheduled = 0
        self._push(0.0, "QUEUE_REFILL", None)
        # Bootstrap hooks per plane
        for plane in range(self.addr.planes):
            self._push(0.0, "PHASE_HOOK", PhaseHook(0.0, "BOOT.START", 0, plane))

    def _push(self, t: float, typ: str, payload: Any):
        t = quantize(t)
        heapq.heappush(self.ev, (t, self._seq, typ, payload)); self._seq+=1

    def _unique_plane_keys(self, targets: List[Address]) -> List[Tuple[int,int,int]]:
        s=set()
        for a in targets:
            s.add((a.die, a.plane, a.block))
        return list(s)

    def _start_time_for_targets(self, targets: List[Address]) -> float:
        planes = {(a.die, a.plane) for a in targets}
        avail = [self.addr.available_at(d,p) for (d,p) in planes]
        return quantize(max([self.now] + avail))

    def _schedule_operation(self, op: Operation):
        start = self._start_time_for_targets(op.targets)
        dur = get_op_duration(op)
        end  = quantize(start + dur)
        # reserve for all involved planes
        for d,p,b in self._unique_plane_keys(op.targets):
            self.addr.reserve(d, p, start, end, block=b)
        # events
        self._push(start, "OP_START", op)
        self._push(end,   "OP_END",   op)
        # hooks for each involved plane
        for d,p,_ in self._unique_plane_keys(op.targets):
            hooks = make_phase_hooks(self.cfg, op, start, d, p)
            for h in hooks:
                self._push(h.time_us, "PHASE_HOOK", h)
        first = op.targets[0]
        print(f"[{self.now:7.2f} us] SCHED  {op.kind.name:7s} tgt={len(op.targets)} start={start:7.2f} end={end:7.2f} 1st={_addr_str(first)} src={op.meta.get('source')} key={op.meta.get('phase_key_used')} fanout={op.meta.get('fanout')}")

        self.stat_scheduled += 1

    def run_until(self, t_end: float):
        t_end = quantize(t_end)
        while self.ev and self.ev[0][0] <= t_end:
            self.now, _, typ, payload = heapq.heappop(self.ev)
            if typ=="QUEUE_REFILL":
                for plane in range(self.addr.planes):
                    self._push(self.now, "PHASE_HOOK", PhaseHook(self.now, "REFILL.NUDGE", 0, plane))
                nxt = quantize(self.now + self.cfg["policy"]["queue_refill_period_us"])
                self._push(nxt, "QUEUE_REFILL", None)

            elif typ=="PHASE_HOOK":
                hook: PhaseHook = payload
                earliest_start = self.addr.available_at(hook.die, hook.plane)
                global_state, local_state = self.addr.observe_states(hook.die, hook.plane, self.now)
                self.stat_propose_calls += 1
                op = self.SPE.propose(self.now, hook, global_state, local_state, earliest_start)
                if op:
                    self._schedule_operation(op)

            elif typ=="OP_START":
                op: Operation = payload
                first = op.targets[0]
                print(f"[{self.now:7.2f} us] START  {op.kind.name:7s} target={_addr_str(first)}")

            elif typ=="OP_END":
                op: Operation = payload
                first = op.targets[0]
                print(f"[{self.now:7.2f} us] END    {op.kind.name:7s} target={_addr_str(first)}")
                self.addr.commit(op)
                self.obl.on_commit(op, self.now)

        print(f"\n=== Stats ===")
        print(f"propose calls : {self.stat_propose_calls}")
        print(f"scheduled ops : {self.stat_scheduled}")
        if self.stat_propose_calls:
            rate = 100.0 * self.stat_scheduled / self.stat_propose_calls
            print(f"accept ratio  : {rate:.1f}%")

# ---------------------------- Main ----------------------------

def main():
    random.seed(CFG["rng_seed"])
    addr = AddressManager(CFG)
    obl  = ObligationManager(CFG["obligations"])
    spe  = PolicyEngine(CFG, addr, obl)
    sch  = Scheduler(CFG, addr, spe, obl)
    run_until = CFG["policy"]["run_until_us"]
    print("=== NAND Sequence Generator Demo (Bundled: phase+quantize+fanout) ===")
    sch.run_until(run_until)
    print("=== Done ===")

if __name__ == "__main__":
    main()

```

ì‚¬ìš© ë°©ë²•

```bash
python3 nandsim_demo_p1_bundle.py

```

ë¬´ì—‡ì´ ë‹¬ë¼ì¡Œë‚˜ (ì§§ê²Œ)
- CFG["phase_conditional"]ë¡œ í›… ì»¨í…ìŠ¤íŠ¸ ê¸°ë°˜ í™•ë¥ ì„ ìµœìš°ì„  ì ìš©, ì‹¤íŒ¨ ì‹œ ê¸°ì¡´ ê°€ì¤‘(score)ë¡œ ë°±ì˜¤í”„.
- CFG["selection"]ì˜ defaultsì™€ phase_overridesë¡œ fanout/interleave ì œì–´.
- ì´ë²¤íŠ¸/í›…/ì»¤ë°‹/ì˜ë¬´ ë°ë“œë¼ì¸ì— ì‹œê°„ ì–‘ìí™” ì ìš©ìœ¼ë¡œ íƒ€ì´ë° ì•ˆì •ì„±â†‘.
- _schedule_operationì€ get_op_durationì„ ì‚¬ìš©, í›—ë‚  StateSeq.timesë¡œ êµì²´ ê°€ëŠ¥.

ë‹¤ìŒìœ¼ë¡œ ì§„í–‰í•  ë•ŒëŠ”:
- ì˜ë¬´ íƒ€ê¹ƒ ë³€í™˜ ë¡œì§(sequential/cached readì— ë”°ë¥¸ ì£¼ì†Œ ì˜¤í”„ì…‹)ê³¼
- ë¸”ë¡/í˜ì´ì§€ ìŠ¤ì½”í”„ ì˜ì¡´ì„± ë£°(ERASEâ†”PGM/READ, PGMâ†”READ ë™ì‹œ ê¸ˆì§€)

ì„ ë¶™ì´ë©´ ì •í•©ì„±ì´ í•œì¸µ ì˜¬ë¼ê°€. ì›í•˜ë©´ ê·¸ ë‘ ê°€ì§€ë„ ë°”ë¡œ íŒ¨ì¹˜ë³¸ìœ¼ë¡œ ì´ì–´ì„œ ë‚´ì¤„ê²Œ.

## ğŸ‘¤ User

=== Stats ===
propose calls : 376
scheduled ops : 370
accept ratio  : 98.4%
=== Done ===
accept ration ê°€ ì¢€ ë–¨ì–´ì§€ê¸´ í–ˆì§€ë§Œ, ì•„ì§ê¹Œì§„ ì¢‹ì•„. 
ë‘ ê°€ì§€ ì§„í–‰í•˜ê¸° ì „ì— ë¦¬ë·°í•˜ê³  ê°€ì. ìš°ì„  ì˜ë¬´ íƒ€ê¹ƒ ë³€í™˜ ë¡œì§ì˜ ëŒ€ìƒì— ëŒ€í•´ ì •í•˜ê³  ê°€ì. Sequential read ë€, host ì˜ ìš”ì²­ì— ì˜í•´ì„œ ì—¬ëŸ¬ page ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì½ëŠ” ë™ì‘ì´ì•¼. ì˜ˆë¥¼ ë“¤ì–´ 20 page ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ì½ì„ ìˆ˜ ìˆì–´. ë°©ë²• ì¤‘ í•˜ë‚˜ëŠ” obligation heap ì— ëª¨ë‘ push í•´ ë‘ëŠ” ê±°ì•¼. ì´ ë°©ì‹ì˜ risk ëŠ” ì¤‘ê°„ì— í•´ë‹¹ block ì„ policy ì— ì˜í•´ì„œ erase/program/read ëª»í•˜ëŠ” ìƒí™©ì´ ë°œìƒí•˜ëŠ”ê±°ì•¼. ë‚´ ëª©ì ì€ ìµœëŒ€í•œ host ì˜ ìš”ì²­ì„ ë“¤ì–´ì£¼ë©´ì„œ policy ì œì•ˆë„ í•  ìˆ˜ ìˆëŠ” ë°©ì‹ì´ì•¼. ê·¸ëŸ¬ê¸° ìœ„í•´ì„  obligation ê³¼ policy ì˜ ìš°ì„  ìˆœìœ„ë¥¼ ì¡°ì •í•´ì•¼ ë˜ê² ì§€. ì´ì²˜ëŸ¼ ê°€ëŠ¥í•œ ë°©ë²•ë“¤ê³¼, ê·¸ê²ƒë“¤ì˜ risk ë¥¼ ì •ë¦¬í•´ë´.

## ğŸ¤– Assistant

ì¢‹ì•„. **â€œHost Sequential READ(ì—°ì† í˜ì´ì§€ ì½ê¸°)â€**ë¥¼ ì–´ë–»ê²Œ ëª¨ë¸ë§/ìŠ¤ì¼€ì¤„ë§í• ì§€ì— ëŒ€í•´, ê°€ëŠ¥í•œ ì „ëµê³¼ ê° ë¦¬ìŠ¤í¬/ì™„í™”ì±…ì„ ë¹„êµ ì •ë¦¬í•˜ê³ , ê¶Œì¥ì•ˆê¹Œì§€ ì œì‹œí• ê²Œ. ëª©í‘œëŠ” **Host SLA(ìˆœì°¨ ì½ê¸° ì™„ì£¼)**ì™€ Policy ì œì•ˆ ììœ ë„ë¥¼ ë™ì‹œì— í™•ë³´í•˜ëŠ” ê²ƒ.

0) ì „ì œ ì •ë¦¬
- ì…ë ¥: Hostê°€ (block=B, start=P0, length=L) í˜•íƒœë¡œ Sequential READ ì„¸ì…˜ì„ ìš”ì²­.
- ê²°ê³¼: í˜ì´ì§€ P0..P0+L-1ì— ëŒ€í•´ READâ†’DOUT(ë˜ëŠ” cache READâ†’DOUT ê·œì¹™) í˜ì–´ê°€ ìˆœì°¨ì ìœ¼ë¡œ ë“±ì¥í•´ì•¼ í•¨.
- ì œì•½: ì¤‘ê°„ì— ê°™ì€ block Bë¡œì˜ ERASE/PROGRAMì€ ì›ì¹™ì ìœ¼ë¡œ ê¸ˆì§€(ë°ì´í„° ì¼ê´€/í˜„ì‹¤ì„±).
- ëª©í‘œ: Host ìš°ì„ ì„ ì§€í‚¤ë˜, ë‹¤ë¥¸ block/planeì—ì„œëŠ” Policy(GC/PGM ë“±)ê°€ ìµœëŒ€í•œ ë³‘í–‰ ê°€ëŠ¥.

1) ì „ëµ ì˜µì…˜ ë¹„êµ
A. Eager-Per-Page Obligations (ì „ì²´ í˜ì´ì§€ë¥¼ ì˜ë¬´ë¡œ í•œ ë²ˆì— heapì— íˆ¬ì…)
- ë°©ë²•: ì„¸ì…˜ ìƒì„± ì‹œ, READ(B,P0) .. READ(B,P0+L-1)ë¥¼ ì „ë¶€ Obligationìœ¼ë¡œ push. ê° READ ì»¤ë°‹ ì‹œ í•´ë‹¹ í˜ì´ì§€ì˜ DOUT ì˜ë¬´ë¥¼ ì¶”ê°€.
- ì¥ì 
  - êµ¬í˜„ ë‹¨ìˆœ. ì˜ë¬´ì •ì±…(ë°ë“œë¼ì¸ ë¶€ìŠ¤íŒ…/í•˜ë“œìŠ¬ë¡¯) ì¬ì‚¬ìš©.
  - ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ììœ ë¡­ê²Œ ì¬ë°°ì¹˜(ê°™ì€ block ë‚´ ìˆœì„œë§Œ ë³´ì¥í•˜ë©´ ë¨).
- ë¦¬ìŠ¤í¬
  - ì˜ë¬´ í­ì¦ â†’ í ì••ë°•: íƒ€ ë¦¬ì†ŒìŠ¤(ë‹¤ë¥¸ plane/block)ì—ì„œ ì •ì±… ì˜¤í¼ê°€ ìƒëŒ€ì ìœ¼ë¡œ ë°€ë¦´ ìˆ˜ ìˆìŒ(ìš°ì„ ìˆœìœ„ ì—­ì „).
  - ì¤‘ê°„ ìƒíƒœ ë³€í™”: ê¸´ ì„¸ì…˜ ì¤‘ê°„ì— GC ì •ì±…ì´ í•´ë‹¹ blockì„ ê±´ë“œë¦¬ë ¤ í•˜ë©´ ì¶©ëŒ(ì‹¤ì œë¡  ê¸ˆì§€í•´ì•¼ í•¨).
  - ë°ë“œë¼ì¸/ìˆœì„œ ê´€ë¦¬ ë³µì¡: í˜ì´ì§€ ië³´ë‹¤ jë¥¼ ë¨¼ì € ì¡ëŠ” ì˜ì‚¬ê²°ì •(ë³‘í–‰/ì¬ë°°ì¹˜)ì´ Hostì˜ ìˆœì°¨ ì§€ì—°ì„ í‚¤ìš¸ ìˆ˜ ìˆìŒ.
- ì™„í™”ì±…
  - ê°™ì€ blockì— ëŒ€í•´ soft-freeze(ERASE/PROGRAM ê¸ˆì§€) ë½.
  - ì˜ë¬´ ë°ë“œë¼ì¸ì„ â€œì¦ê°€ì—´â€ë¡œ ë¶€ì—¬(i < jë©´ dl_i < dl_j) â†’ ìˆœì„œ ìì—° ìœ ë„.
  - heap ì‚¬ì´ì¦ˆ ìƒí•œ + agingìœ¼ë¡œ ì •ì±… ì˜¤í¼ ê¸°ì•„ ë°©ì§€.

B. Lazy Sliding-Window Obligations (ê¶Œì¥)
- ë°©ë²•: ì„¸ì…˜ì„ Session ê°ì²´ë¡œ ë³´ê´€í•˜ê³ , ìœˆë„ìš° í¬ê¸° W(ì˜ˆ: 2~4 í˜ì´ì§€)ë§Œí¼ë§Œ ì˜ë¬´ë¥¼ ì•ë‹¨ì— ìœ ì§€. READê°€ ëë‚˜ë©´ ë‹¤ìŒ í˜ì´ì§€ ì˜ë¬´ë¥¼ ë³´ì¶©(push).
- ì¥ì 
  - í ë¶€í•˜/ì˜ë¬´ ë‚œë¦½ ì™„í™”: í•­ìƒ Wê°œë§Œ í™œì„±.
  - ì •ì±… ë³‘í–‰ ì—¬ì§€â†‘: ì˜ë¬´ ì••ë ¥ì´ ë‚®ì•„ ë‹¤ë¥¸ blockì—” ì •ì±… ì˜¤í¼ê°€ ë” ììœ ë¡œì›€.
  - ìˆœì°¨ì„±Â·SLA ì œì–´: í˜ì´ì§€ë³„ ë°ë“œë¼ì¸/ìŠ¬ë™ì„ ê´€ë¦¬í•´ ì ì ˆíˆ ë¶€ìŠ¤íŒ….
- ë¦¬ìŠ¤í¬
  - ìœˆë„ìš°ê°€ ë„ˆë¬´ ì‘ìœ¼ë©´ I/O ê¹Šì´â†“ â†’ Throughput ì €í•˜.
  - ë„ˆë¬´ í¬ë©´ Aì™€ ê°™ì€ ì••ë°•ìœ¼ë¡œ íšŒê·€.
- ì™„í™”ì±…
  - WëŠ” plane ê°€ìš©/ì˜ˆìƒ READ ì§€ì—° ê¸°ë°˜ ì ì‘ì  íŠœë‹(ì˜ˆ: plane ìœ íœ´ ë¹„ìœ¨â†‘ â†’ Wâ†‘).
  - ì„¸ì…˜ ë‹¨ìœ„ **soft-freeze(lock)**ë¡œ block ì¶©ëŒ ì°¨ë‹¨.
  - Slack-aware ìš°ì„ ìˆœìœ„(ì•„ë˜ Â§3): ë°ë“œë¼ì¸-ì˜ˆìƒì†Œìš”ì‹œê°„ ê¸°ì¤€.

C. Composite/Macro Obligation (í•œ ì„¸ì…˜=í•˜ë‚˜ì˜ ë§¤í¬ë¡œ)
- ë°©ë²•: ì„¸ì…˜ ì „ì²´ë¥¼ CompositeObligationìœ¼ë¡œ ëª¨ë¸ë§. ë‚´ë¶€ì ìœ¼ë¡œ í˜ì´ì§€ ië¥¼ ìˆœì„œëŒ€ë¡œë§Œ ë°°ì¶œ(ê°•í•œ ìˆœì°¨). í•„ìš”ì‹œ OP_START/ENDì— ë”°ë¼ ë‹¤ìŒ í˜ì´ì§€ ìë™ ë°°ì¶œ.
- ì¥ì 
  - ìˆœì„œ ë³´ì¥/ì¼ê´€ì„± ìµœìƒ: ì •ì±… ê°œì…ìœ¼ë¡œ ìˆœì„œ ê¹¨ì§ˆ ì—¬ì§€â†“.
  - ìŠ¤ì¼€ì¤„ë§ ì¶”ë¡ ì´ ì‰¬ì›€(â€œí˜„ì¬ ì„¸ì…˜ì´ ë°°ì¶œí•œ ê²ƒë§Œ ì²˜ë¦¬â€).
- ë¦¬ìŠ¤í¬
  - ë³‘ë ¬ì„±/ìœ ì—°ì„±â†“: ë‹¤ë¥¸ block/planeë¡œì˜ ë¶„ì‚° ìµœì í™” ì–´ë µê³ , ì¤‘ê°„ ì •ì±… ì˜¤í¼ ê°œì… ì—¬ì§€ ë‚®ìŒ.
  - êµ¬í˜„ ë³µì¡: ë§¤í¬ë¡œ ë‚´ë¶€ ìƒíƒœê¸°ê³„ + í›… ì—°ë™.
- ì™„í™”ì±…
  - ë‚´ë¶€ë„ ìœˆë„ìš° Wë¡œ ë°°ì¶œí•˜ë„ë¡ ì„ì–´ Bì™€ ìœ ì‚¬í•œ êµ¬ì¡°ë¡œ ì™„í™”.

D. Hard Reservation(ê°• ë½) + ì •ì±… ììœ 
- ë°©ë²•: ì„¸ì…˜ ìˆ˜ëª… ë™ì•ˆ block Bë¥¼ hard-reserve(ERASE/PROGRAM ì ˆëŒ€ ê¸ˆì§€), READë§Œ í—ˆìš©. ë‹¤ë¥¸ block/planeì—” ì •ì±… ììœ .
- ì¥ì 
  - Host ìˆœì°¨ì„± ë³´ì¥(ë°ì´í„° ë¬´ê²°).
  - êµ¬í˜„ ë‹¨ìˆœ(ë½/ì–¸ë½ë§Œ).
- ë¦¬ìŠ¤í¬
  - GC/PGM ì •ì±… ìœ ì—°ì„± ì†ì‹¤: íŠ¹ì • blockì— ëŒ€í•œ ì •ì±… ì§„ì²™ì´ ì¤‘ë‹¨, ì¥ê¸°ì ìœ¼ë¡œ GC ì••ë ¥â†‘.
- ì™„í™”ì±…
  - TTL/íƒ€ì„ì•„ì›ƒ: ë„ˆë¬´ ì˜¤ë˜ ì¡ê³  ìˆìœ¼ë©´ ìë™ ë‹¤ìš´ê·¸ë ˆì´ë“œâ†’soft-freeze.
  - â€œê¸´ ì„¸ì…˜ì€ ë¶„í• â€: Lì´ í° ìš”ì²­ì€ ì—¬ëŸ¬ sub-sessionìœ¼ë¡œ ë¶„í• í•´ì„œ ë½ ê¸°ê°„ ì§§ê²Œ.

E. Soft Freeze + Slack-aware Priority (ê¶Œì¥ ë³´ì¡°ê¸°ë²•)
- ë°©ë²•: ì„¸ì…˜ blockì—ëŠ” soft-freeze íƒœê·¸(ERASE/PROGRAM Weightâ†“, READâ†‘)ë§Œ ê±¸ê³ , ì‹¤ì œ ìŠ¤ì¼€ì¤„ì€ slack(=deadlineâˆ’earliest_startâˆ’est_cost) ê¸°ë°˜ìœ¼ë¡œ Host ì˜ë¬´ì˜ ë¶€ìŠ¤íŒ…ì„ ë™ì ìœ¼ë¡œ ì ìš©. Slackì´ ì„ê³„ ì´í•˜ë©´ Host ìš°ì„ , ì—¬ìœ ë©´ Policy í—ˆìš©.
- ì¥ì 
  - ê· í˜• ì¡íŒ ê³µì¡´: Host SLAë¥¼ ì§€í‚¤ë˜, Policyë„ idle timeì— ì ê·¹ ìˆ˜í–‰.
  - GC/PGMì„ ë‹¤ë¥¸ blockìœ¼ë¡œ ëŒë¦¬ëŠ” ìœ ë„ íš¨ê³¼.
- ë¦¬ìŠ¤í¬
  - ìŠ¬ë™ ì¶”ì • ë¶€ì •í™• ì‹œ SLA ìœ„ë°˜/ê³¼ë„ë¶€ìŠ¤íŒ….
- ì™„í™”ì±…
  - ë³´ìˆ˜ì  ì¶”ì •(READ ì§€ì—° ìƒê³„ ì‚¬ìš©) + ì‹¤í–‰ í†µê³„ë¡œ ì˜¨ë¼ì¸ ë³´ì •.

2) ê¶Œì¥ ì¡°í•© (í˜„ í”„ë ˆì„ì— ê°€ì¥ ì˜ ë§ëŠ” ë°©ì‹)

B. Lazy Sliding-Window + E. Soft Freeze + Slack-aware Priority  

(í•„ìš” ì‹œ D í•˜ë“œë½ì„ â€˜ì˜ˆì™¸ ì¼€ì´ìŠ¤â€™ë¡œ ì œí•œì ìœ¼ë¡œ ì‚¬ìš©)

ì´ìœ 
- ì§€ê¸ˆ êµ¬ì¡°(ì´ë²¤íŠ¸ í›… + ObligationManager + precheck)ì—ì„œ ìœˆë„ìš° ê¸°ë°˜ ë³´ì¶©ì´ ìì—°ìŠ¤ëŸ½ê³ , íÂ·ìš°ì„ ìˆœìœ„ì˜ ì••ë ¥ ì œì–´ê°€ ìš©ì´.
- soft-freezeë¡œ ë°ì´í„° ë¬´ê²°/ì¶©ëŒ ìœ„í—˜ì„ í¬ê²Œ ë‚®ì¶”ë©´ì„œë„, ë‹¤ë¥¸ block/planeì—ì„  ì •ì±… ì˜¤í¼ë¥¼ ì ê·¹ í—ˆìš©.
- ìŠ¬ë™ ê¸°ë°˜ ìš°ì„ ìˆœìœ„ë¡œ Host ì¼ë³€ë„ ê¸°ì•„ë¥¼ ë°©ì§€.

3) ì˜ë¬´ vs. ì •ì±… ìš°ì„ ìˆœìœ„ ê·œì¹™(ê¶Œì¥ ìƒì„¸)
1. ì„¸ì…˜ ìƒì„± ì‹œ:
  - SeqReadSession{block=B, next=P0, end=P0+L-1, W} ìƒì„±.
  - fill_window()ë¡œ ìµœëŒ€ Wê°œì˜ READ ì˜ë¬´ë¥¼ push(ë°ë“œë¼ì¸ì€ ì¦ê°€ì—´).
  - AddressManagerì— block=B soft-freeze íƒœê·¸(ERASE/PROGRAM weightâ†“, precheckì—ì„œ ê²½ê³ /ê±°ì ˆ ì˜µì…˜).
2. propose()ì—ì„œ ì„ íƒ ìˆœì„œ:
  - (a) ê¸‰í•œ ì˜ë¬´: deadline - now <= boost_window ë˜ëŠ” hard_slot â†’ ì¦‰ì‹œ ìš°ì„ .
  - (b) ìŠ¬ë™ ê¸°ë°˜ ë¹„êµ: ë‹¤ìŒ READ ì˜ë¬´ì˜ slackì´ â‰¤ slack_thresholdë©´ Host ì˜ë¬´ ìš°ì„ , ì•„ë‹ˆë©´ ì •ì±… í›„ë³´ í—ˆìš©.
  - (c) ì •ì±… í›„ë³´: ë‹¨, soft-freeze blockì€ íƒ€ê²Ÿì—ì„œ ì œì™¸(precheck/weightì—ì„œ ì»·).
  - (d) READ ì™„ë£Œ ì‹œ: í•´ë‹¹ í˜ì´ì§€ì˜ DOUT ì˜ë¬´ push(Î”t ë¶„í¬). ê·¸ë¦¬ê³  ì„¸ì…˜ fill_window()ë¡œ ë‹¤ìŒ READ ë³´ì¶©.
3. ì¢…ë£Œ:
  - next > endë©´ ì„¸ì…˜ ì¢…ë£Œ, soft-freeze í•´ì œ.

4) ìºì‹œ ë¦¬ë“œ/ì‹œí€€ì…œ íƒ€ê¹ƒ ë³€í™˜ ê·œì¹™ (ì˜ë¬´ íƒ€ê¹ƒ ë³€í™˜ ë¡œì§)
- Sequential READ
  - ì›ë³¸: READ(B, page=k) ì»¤ë°‹
  - DOUT ì˜ë¬´: DOUT(B, page=k) (ì¼ë°˜ READ-DOUT)
- Cache READ ì‹œë‚˜ë¦¬ì˜¤ (ë„¤ê°€ ì–¸ê¸‰: cache read ë¨¼ì €, DOUT ë‚˜ì¤‘; DOUT ì£¼ì†Œ page-1)
  - ì›ë³¸: CACHE_READ(B, page=k) ì»¤ë°‹
  - DOUT ì˜ë¬´: DOUT(B, page=k-1)
- PGM/READ ì‹œí€€ìŠ¤ ì˜¤í”„ì…‹
  - Sequential PROGRAM: PROGRAM(B, page=k) ì»¤ë°‹ í›„, k := k+1ë¡œ Session í¬ì¸í„° ì§„í–‰
  - (í•„ìš”ì‹œ) READ ì„¸ì…˜ê³¼ì˜ ì¶©ëŒì€ block soft-freezeë¡œ ì°¨ë‹¨

êµ¬í˜„ íŒ: ObligationTranslatorë¥¼ ë„£ì–´ source-op â†’ required-opë¡œ íƒ€ê¹ƒ ë³€í™˜ì„ ìˆœìˆ˜ í•¨ìˆ˜ë¡œ ê´€ë¦¬:

```python
def translate_obligation(source_op, spec)->List[Address]:
    if spec.require == "DOUT" and source_op.kind == "CACHE_READ":
        return [Address(B, plane, block=source.block, page=source.page-1)]
    # default: same address

```

5) ë¦¬ìŠ¤í¬/ì™„í™” ìš”ì•½ í‘œ

| ì „ëµ | ì£¼ìš” ë¦¬ìŠ¤í¬ | ì¦ìƒ | ì™„í™” |
| --- | --- | --- | --- |
| A. Eager ì „ëŸ‰ push | í ì••ë°•, ì •ì±… ê¸°ì•„, ìˆœì„œ ì§€ì—° | accept ratioëŠ” ë†’ì•„ë„ ì •ì±… ì»¤ë°‹â†“ | soft-freeze, ì¦ê°€ì—´ ë°ë“œë¼ì¸, heap ìƒí•œ |
| B. Lazy Window âœ… | W ì„ íƒ ë¶€ì ì ˆ | Throughput ì €í•˜ or í ì••ë°• | W ì ì‘í˜•, plane ìœ íœ´ìœ¨ ê¸°ë°˜ ì¡°ì • |
| C. Composite Macro | ë³‘ë ¬ì„±â†“, êµ¬í˜„ ë³µì¡ | ì •ì±… ì œì•ˆ ê¸°íšŒâ†“ | ë‚´ë¶€ ìœˆë„ìš°í™”, ì˜ˆì™¸ì  ì ìš© |
| D. Hard Reservation | GC/PGM ìœ ì—°ì„±â†“ | ì¥ê¸°ì  GC ì••ë ¥â†‘ | TTL/Timeout, sub-session ë¶„í•  |
| E. Soft Freeze âœ… | ìŠ¬ë™ ì¶”ì • ì˜¤ì°¨ | Host ì§€ì—° or ê³¼ë„í•œ Host ìš°ì„  | ë³´ìˆ˜ì  ì¶”ì •, ì‹¤í–‰ í†µê³„ë¡œ ë³´ì • |

6) ë°”ë¡œ ì ìš©í•  êµ¬í˜„ ê³„íš (Step-by-step)
1. Session ëª¨ë¸ ì¶”ê°€
  - SeqReadSession{block, next, end, window, deadlines[], soft_freeze=True}
  - API: fill_window(now), on_read_commit(page), is_done()
2. ObligationManager í™•ì¥
  - on_host_req_seqread(B,P0,L) â†’ Session ìƒì„± + fill_window()
  - on_commit(READ(B,k)) â†’ DOUT(B,k) ì˜ë¬´ push + session.on_read_commit(k) â†’ fill_window()
3. AddressManager soft-freeze
  - block ë‹¨ìœ„ íƒœê·¸: soft_freeze_blocks={B: ttl}
  - precheck()ì™€ policy weightì—ì„œ ERASE/PROGRAMì˜ ê±°ì ˆ/íŒ¨ë„í‹° ì ìš©
4. SPE ìš°ì„ ìˆœìœ„ ë¡œì§
  - pop_urgent() â†’ boost window/hard-slot ë°˜ì˜(ì´ë¯¸ ì¼ë¶€ ìˆìŒ)
  - ìŠ¬ë™ ê³„ì‚°: slack = deadline - earliest_start - est_read_cost
  - slack <= Të©´ Host ì˜ë¬´ ìš°ì„ , ì•„ë‹ˆë©´ policy í—ˆìš©
  - policy í›„ë³´ëŠ” soft-freeze block ì œì™¸
5. ìœˆë„ìš° W íŠœë‹
  - ì´ˆê¸° W=2~4 â†’ ë©”íŠ¸ë¦­ ê¸°ë°˜ ì¡°ì •: Host ì§€ì—°/accept ratio/plane util ë³´ê³  ìë™ ë³´ì •

7) ê²°ë¡  (ê¶Œê³ )
- Lazy Sliding-Window + Soft Freeze + Slack-aware Priority ì¡°í•©ìœ¼ë¡œ ê°€ì.
- ìºì‹œë¦¬ë“œ/ìˆœì°¨ì˜¤í”„ì…‹ì€ ObligationTranslatorë¡œ ì¤‘ì•™ì§‘ì¤‘ ì²˜ë¦¬.
- Hard Reservationì€ ì˜ˆì™¸ì ìœ¼ë¡œ(ê¸´ ì„¸ì…˜/íƒ€ì„ì•„ì›ƒ ê¸°ì¤€)ë§Œ ì‚¬ìš©.

ì›í•˜ë©´, ìœ„ ì„¤ê³„ë¥¼ ê¸°ì¤€ìœ¼ë¡œ Session/Translatorë¥¼ ë¶™ì¸ P2 íŒ¨ì¹˜ ì½”ë“œ(ë°ëª¨ ìˆ˜ì¤€)ê¹Œì§€ í•œ ë²ˆì— ì œê³µí• ê²Œ.

## ğŸ‘¤ User

ì¢‹ì•„. ê·¸ëŸ°ë°, í•œê°€ì§€ ê´€ì ì„ ì¶”ê°€í•˜ì. ê²°êµ­ ë‚´ê°€ í•˜ê³  ì‹¶ì€ ê±´, ì‹œê°„ ìˆœìœ¼ë¡œ ì§„í–‰ë˜ëŠ” nand sequence ì˜ output ì„ ì¼ì •í•œ format ìœ¼ë¡œ ì •ì˜í•˜ê³ , ê·¸ê²ƒì„ ATE ê°€ ì œê³µí•˜ëŠ” pattern íŒŒì¼ë¡œ ë³€í™˜í•˜ëŠ”ê±°ì•¼. ì§€ê¸ˆ event ê¸°ë°˜ì˜ ë¡œì§ì˜ ì¥ì ì€ policy ë‘ obligation ì„ íŠœë‹í•  ìˆ˜ ìˆë‹¤ëŠ” ì¥ì ì´ ìˆì–´. í•˜ì§€ë§Œ ì‹¤ì œë¡œ í•„ìš”í•œ ê²ƒì€
- nand sequence ë¥¼ ì‹œê°„ìˆœ ë‚˜ì—´í•´ì„œ output ì„ ìƒì„±
- timeline ì—ì„œ die, plane ì´ ë³„ë„ë¡œ ì¡´ì¬í•˜ì§€ ì•Šê³  í†µí•©ëœ í•˜ë‚˜ì˜ sequence ê°€ ì¡´ì¬
- idle time ë„ ëª¨ë‘ í•˜ë‚˜ì˜ operation ìœ¼ë¡œ ì·¨ê¸‰. ì˜ˆ) nop
- ëª¨ë“  operation ì—ëŠ” ê³ ìœ í•œ duration ì´ ì¡´ì¬. ì ˆëŒ€ì  resolution ì€ ì—†ìŒ. nop ë„ duration ì´ ìˆê³ , duration ë‹¨ìœ„ë¥¼ ê³±í•˜ì—¬ duration ì„ í™•ì¥
ì´ ì¡°ê±´ì— ë§ì¶°ì„œ í˜„ì¬ì˜ ì‹œìŠ¤í…œ êµ¬ì¡°ë¥¼ í‰ê°€í•˜ê³ , ê³„ì† ì´ì–´ë‚˜ê°€ë„ ê´œì°®ì€ê±´ì§€ ì•Œë ¤ì¤˜

## ğŸ¤– Assistant

í•µì‹¬ë¶€í„° ê²°ë¡ : ì§€ê¸ˆì˜ ì´ë²¤íŠ¸ ê¸°ë°˜ êµ¬ì¡°ë¥¼ ìœ ì§€í•´ë„, ë„¤ê°€ ì›í•˜ëŠ” â€œë‹¨ì¼ ê¸€ë¡œë²Œ ì‹œí€€ìŠ¤(Die/Plane í†µí•©) + NOP í¬í•¨ + ê°€ë³€ duration ë‹¨ìœ„â€ ì¶œë ¥ì€ ì¶©ë¶„íˆ ë‹¬ì„± ê°€ëŠ¥í•´.  

ë‹¤ë§Œ ì¶œë ¥ìš©ìœ¼ë¡œ ë‘ ê°œì˜ ë ˆì´ì–´ë¥¼ ì¶”ê°€í•˜ë©´ êµ¬ì¡°ê°€ ê¹”ë”í•´ì ¸:
1. BusResource(ì¸í„°í˜ì´ìŠ¤ ìì›) ê²Œì´íŒ… ë ˆì´ì–´ â€“ â€œë²„ìŠ¤(ì±„ë„)â€ë¥¼ ì‹¤ì œë¡œ ì ìœ í•˜ëŠ” ìƒíƒœ êµ¬ê°„ë§Œ ì „ì—­ ìƒí˜¸ë°°íƒ€ë¡œ ê´€ë¦¬
2. GlobalTimelineBuilder(ê¸€ë¡œë²Œ íƒ€ì„ë¼ì¸ íˆ¬ì˜ê¸°) â€“ ë²„ìŠ¤ì— ë‚˜íƒ€ë‚˜ëŠ” ì´ë²¤íŠ¸ë¥¼ ì‹œê°„ìˆœìœ¼ë¡œ ëª¨ì•„ ë‹¨ì¼ ì‹œí€€ìŠ¤ë¡œ ì§ë ¬í™”, ê°­ì—ëŠ” NOP ì‚½ì…, ë§ˆì§€ë§‰ì— ë‹¨ìœ„ ìŠ¤ì¼€ì¼ë§(ATE íŒ¨í„´ ë³€í™˜ìš©)

ì•„ë˜ì— ìƒì„¸ í‰ê°€ì™€ ë³€ê²½ í¬ì¸íŠ¸/ë¦¬ìŠ¤í¬/ì‹¤í–‰ ê³„íšì„ ì •ë¦¬í–ˆì–´.

1) ìš”êµ¬ì‚¬í•­ê³¼ í˜„ì¬ êµ¬ì¡°ì˜ ì •í•©ì„±
ìš”êµ¬ì‚¬í•­ â†” í˜„ì¬ êµ¬ì¡°
- â€œì‹œê°„ìˆœ ë‚˜ì—´ëœ í•˜ë‚˜ì˜ ì‹œí€€ìŠ¤â€

â†’ í˜„ì¬ëŠ” per-planeë¡œ OP_START/OP_ENDê°€ ë™ì‹œ ë‹¤ë°œë¡œ ì¡´ì¬. Busë¥¼ ì ìœ í•˜ëŠ” stateë§Œ ì „ì—­ìœ¼ë¡œ ì·¨í•©í•˜ë©´ í•˜ë‚˜ì˜ ë²„ìŠ¤ ì‹œí€€ìŠ¤ë¡œ ìˆ˜ë ´ ê°€ëŠ¥.
- â€œdie/plane êµ¬ë¶„ ì—†ëŠ” í†µí•© ì‹œí€€ìŠ¤â€

â†’ ë‚´ë¶€ ìŠ¤ì¼€ì¤„ì€ die/plane-awareë¡œ ìœ ì§€(í˜„ êµ¬ì¡° ê·¸ëŒ€ë¡œ), ì¶œë ¥ ì‹œì ì— die/plane ì •ë³´ëŠ” ë©”íƒ€ë°ì´í„°ë¡œë§Œ ë³´ì¡´í•˜ê³  ë‹¨ì¼ ìŠ¤íŠ¸ë¦¼ìœ¼ë¡œ ì§ë ¬í™”.
- â€œIdleë„ NOPë¡œ ì·¨ê¸‰, ëª¨ë“  opëŠ” duration ê°€ì§â€

â†’ í˜„ì¬ StateSegì— duration ì¡´ì¬. ë²„ìŠ¤ ê³µë°± êµ¬ê°„ì„ ê³„ì‚°í•˜ì—¬ NOP(duration)ì„ ì‚½ì…í•˜ë©´ ìš”ê±´ ì¶©ì¡±.
- â€œì ˆëŒ€ í•´ìƒë„ ì—†ìŒ, NOP duration í™•ì¥ìœ¼ë¡œ ê¸¸ì´ ì¡°ì ˆâ€

â†’ ë‚´ë¶€ëŠ” Î¼s ë“± ì—°ì†ì‹œê°„ìœ¼ë¡œ ë‘ê³ , Export ë‹¨ê³„ì—ì„œ TU(Time Unit) ì„ íƒ í›„ dur_units = round(duration/TU)ë¡œ ë²¡í„°í™”. í•„ìš” ì‹œ ëˆ„ì ì˜¤ì°¨ ë³´ì •ìš© NOP ë³´ìƒ(Â±1 unit) ì‚½ì….

ë”°ë¼ì„œ ìŠ¤ì¼€ì¤„ëŸ¬/ì •ì±…/ì˜ë¬´ ë¡œì§ì€ ìœ ì§€í•˜ë˜, â€œë²„ìŠ¤ì— ë³´ì´ëŠ” ê²ƒë§Œâ€ì„ ì „ì—­ íƒ€ì„ë¼ì¸ìœ¼ë¡œ íˆ¬ì˜í•˜ë©´ ëœë‹¤.

2) ë°˜ë“œì‹œ ë„£ì–´ì•¼ í•˜ëŠ” êµ¬ì¡° ë³€ê²½(ë§ì”Œìš°ê¸°)
(A) BusResource ê²Œì´íŒ… (ì¤‘ìš”)
- ì™œ? ë‘ planeì—ì„œ ë™ì‹œì— READ.ISSUE(ë²„ìŠ¤ ì‚¬ìš©) ê°™ì€ ë²„ìŠ¤ êµ¬ê°„ì´ ê²¹ì¹˜ë©´ ë‹¨ì¼ ì‹œí€€ìŠ¤ë¡œ ë¶ˆê°€ëŠ¥.
- ë°©ë²•: op_specs.states[*]ì— bus ì‚¬ìš© í”Œë˜ê·¸ ì¶”ê°€(ì˜ˆ: bus: true/false).
  - ì˜ˆ) READ: ISSUE(bus=true), CORE_BUSY(false), DATA_OUT(true)
  - PROGRAM/ERASE: ë³´í†µ ISSUE(true), CORE_BUSY(false)
  - DOUT: DATA_OUT(true)
- ìŠ¤ì¼€ì¤„ ì‹œì :
  - Operation ì˜ˆì•½ê³¼ ë™ì‹œì— bus=trueì¸ êµ¬ê°„ì„ ë¶„ë¦¬í•˜ì—¬ BusResourceì— ë³„ë„ ì˜ˆì•½(ì „ì—­ ë‹¨ì¼ ë¦¬ì†ŒìŠ¤).
  - ë˜ëŠ” â€œì˜ë¬´(DOUT)â€ì²˜ëŸ¼ í›„ë‹¨ ë²„ìŠ¤ êµ¬ê°„ì€ ë³„ë„ Operation(=DOUT)ìœ¼ë¡œ ì´ë¯¸ ë¶„ë¦¬ë˜ì–´ ìˆìœ¼ë‹ˆ, ISSUE ìˆœê°„ë§Œ BusResourceë¡œ ë³´ì¥í•´ë„ ì‹¤ìš©ì ìœ¼ë¡œ ì¶©ë¶„.
- precheck í™•ì¥: earliest_startì—ì„œ ë²„ìŠ¤ ì ìœ  ê°€ëŠ¥ ì‹œê°ë„ ê³ ë ¤(= bus_available_at).

ì´ë ‡ê²Œ í•˜ë©´ â€œí›„ë³´ ì œì•ˆ(propose)â€ ë‹¨ê³„ì—ì„œ ê²¹ì¹¨ ê±°ì ˆë¥ ì´ í¬ê²Œ ë‚®ì•„ì§€ê³ , ë‚˜ì¤‘ Export ì§ë ¬í™” ì‹œ ì¶©ëŒì´ ì‚¬ë¼ì§.

(B) GlobalTimelineBuilder (ì¶œë ¥ íŒŒì´í”„ë¼ì¸)
- ì…ë ¥: ìŠ¤ì¼€ì¤„ ê²°ê³¼ì˜ ì´ë²¤íŠ¸/íƒ€ì„ë¼ì¸(ê° Operationì˜ state ì ˆëŒ€ ì‹œê°)
- ì²˜ë¦¬:
  1. ëª¨ë“  Operationì˜ bus=true stateêµ¬ê°„ì„ **(t_start, t_end, kind, meta)**ë¡œ ìˆ˜í™•
  2. ì‹œê°„ ì˜¤ë¦„ì°¨ìˆœ ì •ë ¬ í›„ ì¸ì ‘/ì¤‘ì²© ì •ë¦¬(ê²¹ì¹¨ì€ BusResource ê²Œì´íŒ…ìœ¼ë¡œ ì›ì²œ ì°¨ë‹¨ë¨)
  3. ê°­ â†’ NOP ì‚½ì…: gap = next.start - prev.endê°€ ì–‘ìˆ˜ë©´ NOP(gap)
  4. ë²¡í„°í™”: Export ì„¤ì •ì˜ TUë¥¼ ì„ íƒ â†’ units = round(duration/TU)
    - ëˆ„ì ì˜¤ì°¨ ë³´ì •: ëˆ„ì  fracì„ ê´€ë¦¬í•˜ì—¬ ì¼ì • ì„ê³„ ì´ˆê³¼ ì‹œ NOP Â±1 unit ì‚½ì…
- ì¶œë ¥: List[SeqItem], ì˜ˆ:
- ì´ SeqItem[]ì„ ATE ë³€í™˜ê¸°(ì˜ˆ: CSVâ†’STIL/WGL ë³€í™˜ê¸°)ì— ì „ë‹¬.

3) Export(ATE) ê´€ì ì˜ ì„¤ê³„ í¬ì¸íŠ¸
- TU(Time Unit) ì„ íƒ
  - ê¸°ë³¸ì€ ë‚´ë¶€ ë‹¨ìœ„(Î¼s)ì—ì„œ ì†Œìˆ˜ì  ì—†ëŠ” ë²¡í„° ìœ ë‹›ìœ¼ë¡œ ë°”ê¾¸ê¸° ìœ„í•œ ìŠ¤ì¼€ì¼.
  - ì „ëµ: TU = clamp(min_seg_duration/Îº, TU_min, TU_max) (Îº=2~4), ë„ˆë¬´ ì‘ìœ¼ë©´ íŒ¨í„´ ê¸¸ì´ í­ì¦, ë„ˆë¬´ í¬ë©´ íƒ€ì´ë° ì†ì‹¤â†‘.
  - ëˆ„ì  ì˜¤ì°¨ ë³´ì •: fractional driftê°€ Â±0.5 unit ê·¼ì ‘ ì‹œ NOPë¡œ ë¯¸ì„¸ ë³´ì •.
- ì‹¬ë³¼ ì„¸íŠ¸(ì˜ˆ: NAND ONFI í˜¸í™˜ ì¶”ìƒ ì‹¬ë³¼)
  - CMD(opcode), ADDR(n), DIN(n), DOUT(n), WAIT(tR/tPROG), SR, RESET, NOP
  - ì—¬ê¸°ì„œ WAITì€ ë‚´ë¶€ busyë¥¼ ë²„ìŠ¤ìƒì—ì„œëŠ” NOPë¡œ í†µí•©í•´ë„ ë˜ì§€ë§Œ, ì˜ë¯¸ì„± ìœ ì§€ ìœ„í•´ ë¶„ë¦¬ ê¶Œì¥(ë³€í™˜ê¸°ì—ì„œ ë§¤í•‘).
- die/plane ë§¤ê°œë³€ìˆ˜
  - ì¶œë ¥ ì‹œí€€ìŠ¤ì—ëŠ” ë…¸ì¶œí•˜ì§€ ì•Šë˜, ADDR ì¸ì½”ë”© ë˜ëŠ” metaì— ì €ì¥. ë³€í™˜ê¸°ì—ì„œ ì£¼ì†Œ ë¹„íŠ¸ì— ë°˜ì˜.

4) ë¦¬ìŠ¤í¬ì™€ ëŒ€ì‘

| ë¦¬ìŠ¤í¬ | ì›ì¸ | ì˜í–¥ | ëŒ€ì‘ |
| --- | --- | --- | --- |
| ë²„ìŠ¤ êµ¬ê°„ ê²¹ì¹¨ | ë‹¤ì¤‘ planeì—ì„œ ë™ì‹œì— ISSUE/DOUT | ë‹¨ì¼ ì‹œí€€ìŠ¤ ë¶ˆê°€ | BusResource ê²Œì´íŒ…ìœ¼ë¡œ ìƒí˜¸ë°°íƒ€ ì˜ˆì•½ |
| ì¶œë ¥ í•´ìƒë„ ì†ì‹¤ | TUê°€ ë„ˆë¬´ í¼ | íƒ€ì´ë° ì™œê³¡ | TU ìë™ ì„ íƒ + ì˜¤ì°¨ ëˆ„ì  ë³´ì • NOP |
| ì˜ë¬´ ë°ë“œë¼ì¸ ìœ„ë°˜ | ë²„ìŠ¤ í˜¼ì¡ìœ¼ë¡œ DOUT ì§€ì—° | READâ†’DOUT SLA ì €í•˜ | ìŠ¬ë™ ê¸°ë°˜ ë¶€ìŠ¤íŒ… + BusResource ì„ ì  ê°€ì¤‘ |
| íŒ¨í„´ ê¸¸ì´ í­ì¦ | ë„ˆë¬´ ì‘ì€ TU / ê³¼ë„ NOP | ATE íŒŒì¼ ë¹„ëŒ€ | TU í•˜í•œ/ìƒí•œ, NOP ì••ì¶•(ì—°ì† NOP ë³‘í•©) |
| ì •ì±… ê¸°ì•„ | Host ì—°ì† ì½ê¸° ì„¸ì…˜ ì§‘ì¤‘ | GC/PGM ì •ì²´ | Sliding-window(W ì œí•œ) + soft-freezeë§Œ ì ìš© |

5) í•„ìš”í•œ ì„¤ì •(YAML/CFG) í™•ì¥ì•ˆ

```yaml
export:
  tu_us: 0.01             # ATE time unit(ì˜ˆ: 10ns)
  nop_symbol: NOP
  wait_as_nop: true       # WAITì„ NOPë¡œ ë‚©ì‘í™”í• ì§€
  drift_correction: true  # ëˆ„ì  ì˜¤ì°¨ ë³´ì • í™œì„±í™”

op_specs:
  READ:
    states:
      - {name: ISSUE,     bus: true,  dist: {...}}
      - {name: CORE_BUSY, bus: false, dist: {...}}
      - {name: DATA_OUT,  bus: true,  dist: {...}}
  PROGRAM:
    states:
      - {name: ISSUE,     bus: true,  dist: {...}}
      - {name: CORE_BUSY, bus: false, dist: {...}}
  ERASE:
    states:
      - {name: ISSUE,     bus: true,  dist: {...}}
      - {name: CORE_BUSY, bus: false, dist: {...}}
  DOUT:
    states:
      - {name: ISSUE,     bus: false, dist: {...}}   # í•„ìš”ì‹œ
      - {name: DATA_OUT,  bus: true,  dist: {...}}

```

6) êµ¬í˜„ ìŠ¤ì¼€ì¹˜ (í•µì‹¬ ë©”ì„œë“œ)
6.1 BusResource (ì „ì—­ ìì›)

```python
class BusResource:
    def __init__(self): self.resv = []  # [(start,end)]
    def available_at(self, t0):
        # t0 ì´í›„ ì²« ë¹„ê°€ìš© êµ¬ê°„ì„ í”¼í•´ì„œ earliest start ë°˜í™˜(ê°„ë‹¨ë²„ì „ì€ ë§ˆì§€ë§‰ end)
        return self.resv[-1][1] if self.resv else t0
    def precheck(self, start, end):
        return all(end <= s or e <= start for (s,e) in self.resv)
    def reserve(self, start, end):
        self.resv.append((start,end))

```

- ìŠ¤ì¼€ì¤„ëŸ¬ì—ì„œ bus=true ì„¸ê·¸ë¨¼íŠ¸ë¥¼ ì•Œë©´ ê·¸ êµ¬ê°„ë§Œ ë”°ë¡œ BusResourceì— precheck+reserve.

6.2 GlobalTimelineBuilder

```python
def build_global_timeline(ops, cfg):
    # 1) bus=true ì„¸ê·¸ë¨¼íŠ¸ ìˆ˜í™•
    segs = []
    for op in ops:
        t = op.abs_start
        for s in op.states:
            start, end = t, t + s.dur_us
            if s.bus: segs.append((start, end, op, s))
            t = end
    segs.sort(key=lambda x: x[0])

    # 2) NOP ì‚½ì… + ë²¡í„°í™”
    tu = cfg["export"]["tu_us"]
    items=[]
    tcur=None
    drift=0.0
    for (s,e,op,seg) in segs:
        if tcur is None: tcur = s
        if s > tcur:
            # gap -> NOP
            gap = s - tcur
            units = round((gap + drift)/tu)
            drift += gap - units*tu
            if units>0: items.append(SeqItem("NOP", units, {}))
            tcur = s
        dur = e - s
        units = round((dur + drift)/tu)
        drift += dur - units*tu
        if units>0:
            sym, meta = to_symbol(seg, op)  # CMD/ADDR/DIN/DOUT/â€¦
            items.append(SeqItem(sym, units, meta))
        tcur = e
    return compress_nop(items)  # ì—°ì† NOP ë³‘í•©

```

to_symbol()ì€ op.kind/stateì— ë”°ë¼ ë²„ìŠ¤ì— ì‹¤ë¦¬ëŠ” ì‹¬ë³¼ê³¼ **ë©”íƒ€(opcode/addr/len)**ë¥¼ êµ¬ì„±.

7) ê³„ì† ì´ êµ¬ì¡°ë¡œ ê°€ë„ ë˜ë‚˜? â†’ Yes, with two add-ons
- ì •ì±…/ì˜ë¬´ íŠœë‹ ì¥ì ì€ ê·¸ëŒ€ë¡œ ìœ ì§€.
- BusResource + GlobalTimelineBuilderë¥¼ ì–¹ì–´ ì¶œë ¥ ìš”êµ¬(ë‹¨ì¼ ì‹œí€€ìŠ¤, NOP í¬í•¨, ê°€ë³€ duration)ì— ì •í™•íˆ ë¶€í•©.
- ë‚´ë¶€ ë³‘ë ¬ì„±(plane interleave)ì€ ê·¸ëŒ€ë¡œ ì‚´ë¦¬ê³ , ë²„ìŠ¤ ë…¸ì¶œ ë ˆë²¨ì—ì„œë§Œ ì§ë ¬í™”í•˜ë©´ ATE ë³€í™˜ì— ì í•©í•œ â€œí•œ ì¤„ì§œë¦¬â€ íƒ€ì„ë¼ì¸ì´ ë‚˜ì˜¨ë‹¤.

8) ì‹¤í–‰ ê³„íš(ê°„ë‹¨ To-Do)
P0 (ë°”ë¡œ)
1. op_specs.states[*].bus: bool ë„ì…, ê¸°ë³¸ê°’ ì±„ì›€
2. BusResource ì¶”ê°€, Scheduler._schedule_operationì—ì„œ bus=true ì„¸ê·¸ë¨¼íŠ¸ ì‚¬ì „ê²€ì‚¬/ì˜ˆì•½
3. GlobalTimelineBuilder ì´ˆì•ˆ êµ¬í˜„ + export.tu_us ì„¤ì • + NOP ì‚½ì…/ë²¡í„°í™”/ì˜¤ì°¨ë³´ì •
4. í†µê³„: bus utilization, NOP ë¹„ìœ¨, drift ëˆ„ì 

P1  

5. to_symbol() ë§¤í•‘ í…Œì´ë¸” ì •ë¦¬(CMD/ADDR/DIN/DOUT/WAIT/NOP)  

6. ìŠ¬ë™ ê¸°ë°˜ ì˜ë¬´ ë¶€ìŠ¤íŒ…ì— bus_available_at ë°˜ì˜
P2  

7. ATE ë³€í™˜ê¸° ì–´ëŒ‘í„°(CSVâ†’ëª©í‘œ í¬ë§·(STIL/WGL ë“±))  

8. íšŒê·€: seed ê³ ì • ì‹œ íŒ¨í„´ ë™ì¼ì„± ë³´ì¥

í•œ ì¤„ ìš”ì•½
- í˜„ ì´ë²¤íŠ¸ êµ¬ì¡°ëŠ” ê·¸ëŒ€ë¡œ ë‘ê³ , (1) Bus ì ìœ  êµ¬ê°„ì„ ì „ì—­ ìì›ìœ¼ë¡œ ê²Œì´íŒ…í•˜ê³  (2) ë²„ìŠ¤ì— ë¹„ì¹˜ëŠ” ì´ë²¤íŠ¸ë§Œ ëª¨ì•„ NOPë¥¼ ì±„ì›Œ ë„£ëŠ” ê¸€ë¡œë²Œ íƒ€ì„ë¼ì¸ì„ ë§Œë“¤ë©´, ë„¤ê°€ ì›í•˜ëŠ” **ATE íŒ¨í„´ ë³€í™˜ìš© â€œí•˜ë‚˜ì˜ ì‹œí€€ìŠ¤â€**ë¥¼ ì•ˆì •ì ìœ¼ë¡œ ë½‘ì•„ë‚¼ ìˆ˜ ìˆì–´.

## ğŸ‘¤ User

ê³„íšì€ ì¢‹ì•„. ì—¬ê¸°ì„œ 2ê°€ì§€ ì¶”ê°€í•´ì„œ ê²€í† í•˜ì. multi-plane ë™ì‘, ê·¸ë¦¬ê³  erase, program CORE_BUSY ì— ì˜ ëª¨ë“  plane ì ìœ ì•¼. ì„¸ë¶€ë‚´ìš©ì€ ì•„ë˜ ì°¸ì¡°. 
- multi-plane read, multi-plane pgm, multi-plane erase ë™ì‘ ì¶”ê°€
- multi-plane ë™ì‘ì€ target plane ì´ ë™ì‹œì— ì—¬ëŸ¬ê°œì´ê³ , ISSUE ì‹œì— plane address ë¥¼ (0,1,2,3) ë˜ëŠ” (0,2,3) ìœ¼ë¡œ ì „ë‹¬.
- multi-plane target plane ì´ ëª¨ë‘ CORE_BUSY ë¡œ ì ìœ ë¨. page ì–´ë“œë ˆìŠ¤ëŠ” multi-plane ë‚´ì—ì„œëŠ” ë™ì¼í•´ì•¼ í•˜ê³ , CORE_BUSY ì¤‘ê°„ì— SR, RESET ë“±ì€ í—ˆìš© ê°€ëŠ¥í•´
- sequential multi-plane read, program ë„ ê°€ëŠ¥í•´ì•¼ í•¨
- erase, program ì´ ì‹œì‘ë˜ë©´ CORE_BUSY ìƒíƒœê°€ target die ë‚´ ëª¨ë“  plane ì´ ë™ì¼í•œ ìƒíƒœë¡œ ì ìœ ë¨.
ê²€í†  ì‹œì‘í•´

## ğŸ¤– Assistant

ì¢‹ì•„. ë©€í‹°â€‘í”Œë ˆì¸ ë™ì‘ê³¼ ERASE/PROGRAMì˜ dieâ€‘wide CORE_BUSY ì ìœ ë¥¼ ë„£ì—ˆì„ ë•Œì˜ ì¼ê´€ëœ ì˜ë¯¸ë¡ (semantics), ìŠ¤ì¼€ì¤„ë§/ì‚¬ì „ê²€ì‚¬/ì„ íƒ/Export(ATE ë³€í™˜)ê¹Œì§€ì˜ ì„¤ê³„ ë³€ê²½ì ì„ ì •ë¦¬í•˜ê³ , ìœ„í—˜Â·ì™„í™”ì±…ê³¼ êµ¬í˜„ ìŠ¤í…+ì½”ë“œ ìŠ¤ì¼€ì¹˜ê¹Œì§€ ì œì‹œí• ê²Œ.

1) í•©ì˜í•  ë™ì‘ ì˜ë¯¸(ìš´ì˜ ê·œì¹™)
1.1 ì—°ì‚°ë³„ ì ìœ  ë²”ìœ„(Scope)ì™€ í˜ì´ì§€ ì œì•½

| Op | ISSUE ë²„ìŠ¤ ì‚¬ìš© | CORE_BUSY ì ìœ  ë²”ìœ„ | í˜ì´ì§€ ë™ê¸°í™” | ë¹„ê³  |
| --- | --- | --- | --- | --- |
| READ (multi-plane) | ë‹¨ì¼ ISSUE (plane list: ì˜ˆ PL={0,1,2,3}) | planeâ€‘setë§Œ ì ìœ  | ë™ì¼ page í•„ìˆ˜ | CORE_BUSY ì¤‘ì—ë„ SR/RESET í—ˆìš©(ë²„ìŠ¤ë§Œ ìƒí˜¸ë°°íƒ€) |
| PROGRAM (multi-plane) | ë‹¨ì¼ ISSUE (plane list) | dieâ€‘wide ì ìœ  (íƒ€ê²Ÿ dieì˜ ëª¨ë“  plane) | ë™ì¼ page í•„ìˆ˜ | ë‚´ë¶€ ë™ê¸°í™” ìš”êµ¬. SR/RESET í—ˆìš© |
| ERASE (multi-plane) | ë‹¨ì¼ ISSUE (plane list ë˜ëŠ” block list) | dieâ€‘wide ì ìœ  | page ì—†ìŒ | SR/RESET í—ˆìš© |
| DOUT | DATA_OUT ë²„ìŠ¤ ì‚¬ìš© | ì—†ìŒ | READì™€ ë™ì¼ ì£¼ì†Œ | ë©€í‹°â€‘í”Œë ˆì¸ READ ë’¤ DOUTì€ per plane ë˜ëŠ” ë¬¶ìŒ ëª¨ë‘ ì§€ì› ê°€ëŠ¥(ì˜µì…˜) |
| SR/RESET | ë²„ìŠ¤ ì‚¬ìš© | ì—†ìŒ | - | ì–¸ì œë“  ë°œí–‰ ê°€ëŠ¥(ë‹¨, ë²„ìŠ¤ëŠ” ìƒí˜¸ë°°íƒ€) |

í•µì‹¬: PROGRAM/ERASEëŠ” CORE_BUSY ë™ì•ˆ die ë‚´ ëª¨ë“  planeì´ ì ìœ . READëŠ” ì„ íƒ planeâ€‘setë§Œ ì ìœ .

2) Config ìŠ¤í‚¤ë§ˆ í™•ì¥(í•„ìˆ˜)
2.1 ìƒíƒœë³„ ë²„ìŠ¤ í”Œë˜ê·¸ + ì ìœ  ë²”ìœ„(scope) + í˜ì´ì§€ ë™ê¸°í™”

```yaml
op_specs:
  READ:
    scope: PLANE_SET              # CORE_BUSY ì ìœ  ë²”ìœ„
    page_equal_required: true
    states:
      - {name: ISSUE,     bus: true,  dist: {...}}
      - {name: CORE_BUSY, bus: false, dist: {...}}
      - {name: DATA_OUT,  bus: true,  dist: {...}}

  PROGRAM:
    scope: DIE_WIDE
    page_equal_required: true
    states:
      - {name: ISSUE,     bus: true,  dist: {...}}
      - {name: CORE_BUSY, bus: false, dist: {...}}

  ERASE:
    scope: DIE_WIDE
    page_equal_required: false
    states:
      - {name: ISSUE,     bus: true,  dist: {...}}
      - {name: CORE_BUSY, bus: false, dist: {...}}

  DOUT:
    scope: NONE
    page_equal_required: true
    states:
      - {name: ISSUE,     bus: false, dist: {...}}
      - {name: DATA_OUT,  bus: true,  dist: {...}}

```

2.2 ë©€í‹°â€‘í”Œë ˆì¸ ì„ íƒ ì •ì±…(phase override í¬í•¨)

```yaml
selection:
  defaults:
    READ:    {fanout: 1, interleave: true}
    PROGRAM: {fanout: 2, interleave: true}      # ë©€í‹°â€‘í”Œë ˆì¸ ì‹œë„
    ERASE:   {fanout: 2, interleave: false}
  phase_overrides:
    "READ.CORE_BUSY.START": {fanout: 4, interleave: true}

```

2.3 Export(ATE) ê´€ë ¨

```yaml
export:
  tu_us: 0.01
  nop_symbol: NOP
  wait_as_nop: true
  drift_correction: true
  dout_grouping: "per_plane"     # or "plane_set"

```

3) ìŠ¤ì¼€ì¤„ëŸ¬/ì„ íƒ/ì‚¬ì „ê²€ì‚¬ ë³€ê²½ì 
3.1 Operation ë©”íƒ€(í•„ë“œ) í™•ì¥
- op.meta["plane_list"] = [0,2,3] (ISSUE ì‹œ ì „ë‹¬ìš©)
- op.meta["scope"] âˆˆ {PLANE_SET, DIE_WIDE, NONE}
- op.targets: List[Address]ëŠ” planeâ€‘set ì „ì²´ ì£¼ì†Œ(ëª¨ë“  planeì— ë™ì¼ page ë³´ì¥)

3.2 AddressManager: ë©€í‹°â€‘í”Œë ˆì¸ íƒ€ê¹ƒ ê³„íš(plan) API

fanoutì„ ì›í•˜ëŠ” ê°’ì—ì„œ ê°€ëŠ¥í•œ ê°’ìœ¼ë¡œ ìë™ ê°•ë“±(degrade)í•˜ë©° í˜ì´ì§€ ë™ê¸°í™”ë¥¼ ë§Œì¡±ì‹œí‚¤ëŠ” planeâ€‘set/ì£¼ì†Œë¥¼ ë°˜í™˜. ì‹¤íŒ¨í•˜ë©´ None.

```python
def plan_multipane(self, kind: OpKind, die:int, start_plane:int, desired_fanout:int, interleave:bool):
    # 1) í›„ë³´ plane ë§ ë§Œë“¤ê¸° (start_planeë¶€í„° ìµœëŒ€ desired_fanout)
    ring = self._plane_ring(start_plane, desired_fanout, interleave)

    # 2) READ: ëª¨ë“  í›„ë³´ planeë“¤ì—ì„œ "ê³µí†µìœ¼ë¡œ ì½ì„ ìˆ˜ ìˆëŠ” page"ë¥¼ ì°¾ìŒ
    #    PROGRAM: ëª¨ë“  í›„ë³´ planeì˜ "next_pgm_page"ê°€ ë™ì¼í•œ subset ì„ íƒ
    #    ERASE: block ë‹¨ìœ„ ì„ íƒ(í˜ì´ì§€ ë™ê¸°í™” ë¶ˆí•„ìš”)
    plane_set, page, blocks = self._find_aligned_subset(kind, die, ring)

    if not plane_set:
        return None  # degrade ì‹¤íŒ¨

    # 3) Address ë¦¬ìŠ¤íŠ¸ êµ¬ì„±(READ/PROGRAM: ë™ì¼ page, ERASE: ëŒ€ìƒ block)
    targets = ...
    scope = DIE_WIDE if kind in {PROGRAM, ERASE} else PLANE_SET
    return targets, plane_set, scope

```

_find_aligned_subsetì€ í˜ì´ì§€ ë™ê¸°í™”ë¥¼ ë§Œì¡±í•˜ëŠ” ìµœëŒ€ subsetì„ ê³ ë¥´ëŠ” íƒìš•(greedy) ì•Œê³ ë¦¬ì¦˜. ì•ˆ ë§ìœ¼ë©´ fanoutì„ 1ê¹Œì§€ ì¤„ì´ë©° ì‹œë„.

3.3 precheck() í™•ì¥ (ì‹œê°„/ì¶©ëŒ/ìŠ¤ì½”í”„)

```python
def precheck(self, kind, targets, start_hint, scope) -> bool:
    # ì‹œê°„ ê²¹ì¹¨: scope==DIE_WIDEë©´ dieì˜ ëª¨ë“  plane ì˜ˆì•½ê³¼ ë¹„êµ,
    # scope==PLANE_SETì´ë©´ targetsì˜ planeë“¤ê³¼ ë¹„êµ
    # ì¶©ëŒ ë£°: ê°™ì€ blockì— ERASEì™€ READ/PROGRAM ë™ì‹œ ê¸ˆì§€, PROGRAMâ†”READ ë™ì‹œ ê¸ˆì§€, ë“±

```

3.4 reserve() í™•ì¥

```python
def reserve(self, op, start, end):
    if op.meta["scope"]=="DIE_WIDE":
        for p in all_planes_of_die(op.targets[0].die):
            self._reserve_plane(die, p, start, end, block=None)  # CORE_BUSY ì ìœ 
    # bus=true êµ¬ê°„ì€ BusResourceì— ë³„ë„ ì˜ˆì•½(ì•„ë˜ Â§3.5)
    # plane-set scopeëŠ” targetsì˜ planeë§Œ

```

3.5 BusResource(ì „ì—­ ë²„ìŠ¤) ê²Œì´íŒ…
- op_specs.states[*].bus: true êµ¬ê°„ë§Œ ì „ì—­ ë‹¨ì¼ ìì›ìœ¼ë¡œ precheck/reserve.
- SR/RESETì€ busë§Œ ì‚¬ìš© â†’ ì–¸ì œë“  ë°œí–‰ ê°€ëŠ¥(ë²„ìŠ¤ë§Œ ìƒí˜¸ë°°íƒ€ë¡œ ë³´ì¥).

3.6 PolicyEngine.propose ë³€ê²½
- pick ì´í›„ ì„ íƒ ë‹¨ê³„ì—ì„œ plan_multipane(...) í˜¸ì¶œ â†’ targets, plane_set, scope ìˆ˜ë ¹
- ë¶ˆê°€ ì‹œ fanoutì„ ìë™ ë‚®ì¶° ì¬ì‹œë„ â†’ ê·¸ë˜ë„ ì•ˆ ë˜ë©´ ë‹¤ë¥¸ opë¡œ ë°±ì˜¤í”„

4) Obligation/Session í™•ì¥ (Sequential multiâ€‘plane)
4.1 Sequential multiâ€‘plane READ/PROGRAM ì„¸ì…˜
- SeqSession(kind, die, plane_set, block, next_page, end_page, window W)
- fill_window()ê°€ multiâ€‘plane READ(or PROGRAM) ì˜ë¬´ë¥¼ í˜ì´ì§€ ë‹¨ìœ„ë¡œ Wê°œ ì•ë‹¹ê²¨ ìƒì„±(ê° ì˜ë¬´ëŠ” í•˜ë‚˜ì˜ ì—°ì‚°ìœ¼ë¡œ planeâ€‘set ì „ì²´ë¥¼ ëª©í‘œ)
- READ ì»¤ë°‹ ì‹œ DOUT ì˜ë¬´ ìƒì„±:
  - export.dout_grouping == "per_plane" ì´ë©´ planeë³„ DOUT ì˜ë¬´ push
  - "plane_set"ì´ë©´ ë¬¶ìŒ DOUT ì˜ë¬´ push

ì´ë ‡ê²Œ í•˜ë©´ í˜ì´ì§€ ë™ê¸°í™” ìš”êµ¬ë¥¼ ì„¸ì…˜ì´ ì±…ì„ì§€ê³ , ì •ì±… ì˜¤í¼ì™€ ê³µì¡´í•˜ë©´ì„œë„ Host ìˆœì°¨ì„± ë³´ì¥(ìœˆë„ìš° Wë¡œ ì••ë ¥ ì œì–´).

5) Export(ATE) ë¹Œë” ì˜í–¥
- ê¸€ë¡œë²Œ íƒ€ì„ë¼ì¸ì€ bus=true êµ¬ê°„ë§Œ ì¶”ì¶œ â†’ ì‹œê°„ìˆœ ì •ë ¬ â†’ ê°­ì€ NOP ì‚½ì….
- ë©€í‹°â€‘í”Œë ˆì¸ ISSUE/DATA_OUTì€ í•˜ë‚˜ì˜ ì‹¬ë³¼ë¡œ ë‚´ë³´ë‚´ë˜, meta.plane_list(ë˜ëŠ” mask)ë¥¼ í¬í•¨:
- PROGRAM/ERASEì˜ CORE_BUSYëŠ” busë¥¼ ì“°ì§€ ì•Šìœ¼ë¯€ë¡œ WAIT/NOPë¡œ í‘œí˜„(ì„¤ì •ì— ë”°ë¼ WAIT ìœ ì§€ ë˜ëŠ” NOP ì••ì¶•).
- TU ìŠ¤ì¼€ì¼/ëˆ„ì ì˜¤ì°¨ ë³´ì •/ì—°ì† NOP ë³‘í•©ì€ ê¸°ì¡´ ì„¤ê³„ ê·¸ëŒ€ë¡œ.

6) ë¦¬ìŠ¤í¬ & ì™„í™”

| ë¦¬ìŠ¤í¬ | ë‚´ìš© | ì˜í–¥ | ì™„í™” |
| --- | --- | --- | --- |
| í˜ì´ì§€ ë™ê¸°í™” ì‹¤íŒ¨ | candidate planeë“¤ page ë¶ˆì¼ì¹˜ | propose ê±°ì ˆâ†‘ | plan_multipaneì´ fanout ìë™ ê°•ë“±, ì„¸ì…˜ ëª¨ë“œì—ì„œëŠ” ë‚´ë¶€ í¬ì¸í„° ë™ê¸°í™” |
| dieâ€‘wide ì ìœ ë¡œ ë³‘ë ¬ì„±â†“ | PROGRAM/ERASEê°€ die ì „ì²´ ë§‰ìŒ | ì²˜ë¦¬ëŸ‰ ì €í•˜ | ì •ì±… ê°€ì¤‘ì—ì„œ READ ìš°ì„ , PROGRAM/ERASEëŠ” ë¹„í˜¼ì¡ êµ¬ê°„/ë‹¤ë¥¸ dieì—ì„œ ìˆ˜í–‰ |
| ë²„ìŠ¤ í˜¼ì¡ | ë©€í‹°â€‘í”Œë ˆì¸ DOUT/ISSUEê°€ ê¸¸ì–´ì§ | ì˜ë¬´ ë°ë“œë¼ì¸ ìœ„í—˜ | BusResource ì„ ì  ê°€ì¤‘ + ìŠ¬ë™ ê¸°ë°˜ ë¶€ìŠ¤íŒ… |
| Export ê¸¸ì´ í­ì¦ | ë‹¤ìˆ˜ NOP/ì„¸ë°€ TU | íŒŒì¼ ë¹„ëŒ€ | TU ìë™ ì„ íƒ + NOP ë³‘í•© + wait_as_nop=false ì„ íƒì§€ |
| SR/RESET ë‚œì… íƒ€ì´ë° | CORE_BUSY ì¤‘ SR/RESET | ì˜¤í•´ì„ | â€œë²„ìŠ¤ë§Œ ìƒí˜¸ë°°íƒ€â€ë¥¼ ëª…í™•í™”, íƒ€ì„ë¼ì¸ì— SR/RESET ì‹¬ë³¼ ê·¸ëŒ€ë¡œ ë…¸ì¶œ |

7) êµ¬í˜„ ìŠ¤í…(ì¦ë¶„, ì‹¤íŒ¨ ìœ„í—˜ ë‚®ê²Œ)
Step 1 â€” ë°ì´í„° ëª¨ë¸ & precheck/ì˜ˆì•½ ìŠ¤ì½”í”„
- op_specs.*.scope, page_equal_required, states[*].bus ë°˜ì˜
- Operation.meta["scope"] ì±„ìš°ê¸°
- AddressManager.precheck/reserveê°€ scopeë³„ ê²€ì‚¬/ì˜ˆì•½ ìˆ˜í–‰

Step 2 â€” ë©€í‹°â€‘í”Œë ˆì¸ ì„ íƒê¸°
- plan_multipane(kind, die, start_plane, fanout, interleave) -> (targets, plane_set, scope) or None
- PolicyEngine.proposeì—ì„œ ìœ„ ì„ íƒê¸°ë¥¼ ì‚¬ìš©(ìë™ ê°•ë“± í¬í•¨)

Step 3 â€” BusResource ê²Œì´íŒ…
- states[*].bus==true êµ¬ê°„ë§Œ ë³„ë„ ì „ì—­ ìì›ìœ¼ë¡œ precheck/reserve
- earliest_start ê³„ì‚°ì— BusResource ë°˜ì˜(ISSUE/DATA_OUT ì•ë‹¹ê¹€/ì§€ì—°)

Step 4 â€” ì„¸ì…˜ & ì˜ë¬´(ì„ íƒ)
- SeqSession(READ/PROGRAM) + sliding window W, DOUT grouping ì˜µì…˜
- ObligationManagerì— on_host_req_seq*/on_commit ê²½ë¡œ ì¶”ê°€

Step 5 â€” Export ë¹Œë”
- bus=true êµ¬ê°„ ìˆ˜í™• â†’ NOP ì‚½ì… â†’ TU ìŠ¤ì¼€ì¼ â†’ ATE íŒ¨í„´ ë³€í™˜(ì‹¬ë³¼ ë§¤í•‘ í‘œ)

8) ì½”ë“œ ìŠ¤ì¼€ì¹˜(í•µì‹¬ ì¸í„°í˜ì´ìŠ¤)
8.1 scope/í˜ì´ì§€ ë™ê¸°í™” ì •ë³´

```python
from enum import Enum
class Scope(Enum): NONE=0; PLANE_SET=1; DIE_WIDE=2

# build_operation í›„:
op.meta["scope"] = Scope[self.cfg["op_specs"][op.kind.name]["scope"]]
op.meta["plane_list"] = sorted({a.plane for a in targets})

```

8.2 plan_multipane()

```python
def plan_multipane(self, kind, die, start_plane, desired_fanout, interleave):
    ring = self._plane_ring(start_plane, desired_fanout, interleave)
    # try largest â†’ smallest
    for f in range(desired_fanout, 0, -1):
        cand = ring[:f]
        ok, page, blocks = self._check_alignment(kind, die, cand)
        if not ok: continue
        targets = self._make_targets(kind, die, cand, page, blocks)
        scope = Scope.DIE_WIDE if kind in (OpKind.PROGRAM, OpKind.ERASE) else Scope.PLANE_SET
        return targets, cand, scope
    return None

```

8.3 precheck()/reserve() ìŠ¤ì½”í”„ ì²˜ë¦¬

```python
def precheck(self, kind, targets, start_hint, scope):
    planes = self._all_planes_of_die(targets[0].die) if scope==Scope.DIE_WIDE \
             else {(t.die,t.plane) for t in targets}
    # ì‹œê°„ ê²¹ì¹¨ ê²€ì‚¬(ì˜ˆì•½í‘œ)
    # block/page ì¶©ëŒ ë£° ê²€ì‚¬
    return True

def reserve(self, op, start, end):
    planes = self._all_planes_of_die(op.targets[0].die) if op.meta["scope"]==Scope.DIE_WIDE \
             else {(t.die,t.plane) for t in op.targets}
    for (d,p) in planes:
        self._reserve_plane(d,p,start,end)
    # bus=true ì„¸ê·¸ë¨¼íŠ¸ëŠ” BusResourceì—ë„ ë³„ë„ ì˜ˆì•½

```

8.4 PolicyEngine.proposeì—ì„œ ì‚¬ìš©

```python
fanout, interleave = get_phase_selection_override(cfg, hook.label, pick)
plan = self.addr.plan_multipane(kind, hook.die, hook.plane, fanout, interleave)
if not plan: 
    # ìë™ ê°•ë“± ëª¨ë‘ ì‹¤íŒ¨ â†’ ë‹¤ë¥¸ opë¡œ ë°±ì˜¤í”„
targets, plane_set, scope = plan
if not self.addr.precheck(kind, targets, earliest_start, scope): 
    return None
op = build_operation(kind, cfg["op_specs"][pick], targets)
op.meta["scope"] = scope.name
op.meta["plane_list"] = plane_set

```

9) ê²°ë¡ 
- í˜„ ì´ë²¤íŠ¸ ê¸°ë°˜ êµ¬ì¡°ë¥¼ ìœ ì§€í•˜ë©´ì„œ,

**(i) ì—°ì‚°ë³„ CORE_BUSY ì ìœ  ë²”ìœ„(scope)**ì™€ (ii) ë©€í‹°â€‘í”Œë ˆì¸ í˜ì´ì§€ ë™ê¸°í™”ë¥¼ ì„ íƒê¸°(plan_multipane) + ì‚¬ì „ê²€ì‚¬(precheck) + **ì˜ˆì•½(reserve)**ì— ë°˜ì˜í•˜ë©´,

ë©€í‹°â€‘í”Œë ˆì¸ READ/PROGRAM/ERASE, sequential multiâ€‘planeê¹Œì§€ ì¼ê´€ë˜ê²Œ ì§€ì› ê°€ëŠ¥.
- ExportëŠ” bus=true êµ¬ê°„ë§Œ ëª¨ì•„ ì „ì—­ ë‹¨ì¼ ì‹œí€€ìŠ¤ë¡œ ì§ë ¬í™”í•˜ê³ , NOP ì±„ì›€ + TU ìŠ¤ì¼€ì¼ë¡œ ATE íŒ¨í„´ ë³€í™˜ ìš”êµ¬ë¥¼ ê·¸ëŒ€ë¡œ ì¶©ì¡±.

ì›í•˜ë©´ ìœ„ ìŠ¤í™ëŒ€ë¡œ **ì‘ë™í•˜ëŠ” ìµœì†Œ íŒ¨ì¹˜(ì½”ë“œ)**ë¥¼ í˜„ì¬ í†µí•©ë³¸ì— ì´ì–´ë¶™ì—¬ ì¤„ê²Œ. (plan_multipane / scope-aware precheck & reserve / BusResource ìŠ¤í… / Export ë¹Œë” ì´ˆì•ˆ)

## ğŸ‘¤ User

_find_aligned_subset ì€ greedy ë°©ì‹ì€ ë¬¸ì œê°€ ìˆì–´. ë‹¤ì–‘í•œ ë™ì‘ì´ ë‚˜ì˜¤ê²Œë” í•˜ëŠ” ê²ƒì´ ëª©í‘œì•¼. ê·¸ë¦¬ê³  multi-plane ë™ì‘ì€, ATE pattern êµ¬í˜„ì‹œ í•˜ë‚˜ì˜ operation ìœ¼ë¡œ ì·¨ê¸‰í•´ì•¼ë¼. ë‚˜ì¤‘ì— GlobalTimelineBuilder ë¥¼ í†µí•´ì„œ ë³€í™˜í•˜ëŠ” ë™ì‘ì´ ê½¤ ë³µì¡í•´ ì§ˆìˆ˜ë„ ìˆê¸° ë•Œë¬¸ì—. â€œSIN_READâ€, â€œMUL_READâ€ ì´ëŸ°ì‹ìœ¼ë¡œ ë³„ê°œë¡œ êµ¬ë¶„í•´ì„œ ì²˜ë¦¬í•˜ëŠ” ê±´ ì–´ë–¤ ê±° ê°™ì•„? risk ë¥¼ í‰ê°€í•´ì¤˜

## ğŸ¤– Assistant

ì¢‹ì€ í¬ì¸íŠ¸ì•¼. ë©€í‹°â€‘í”Œë ˆì¸ ë™ì‘ì„ ATEì—ì„œë„ â€œí•˜ë‚˜ì˜ ì˜¤í¼ë ˆì´ì…˜â€ìœ¼ë¡œ ì·¨ê¸‰í•˜ë ¤ë©´, ë‚´ë¶€ í‘œí˜„ê³¼ ì¶œë ¥ ì‹¬ë³¼ ëª¨ë‘ì—ì„œ ë‹¨ì¼ ê°œì²´ì„±ì„ ìœ ì§€í•´ì•¼ í•´.  

ì—¬ê¸°ì„œ ì„ íƒì§€ê°€ ë‘˜ì´ê³ , ê°ê°ì˜ ë¦¬ìŠ¤í¬ë¥¼ ì •ë¦¬í•˜ë©´ ì•„ë˜ì™€ ê°™ì•„.

ì˜µì…˜ 1) OpKindë¥¼ ìª¼ê°œê¸°: SIN_READ, MUL_READ, SIN_PROGRAM, MUL_PROGRAM, SIN_ERASE, MUL_ERASE â€¦
ì˜ë„: ë©€í‹°/ì‹±ê¸€ì„ ë‹¤ë¥¸ ì—°ì‚° íƒ€ì…ìœ¼ë¡œ ëª…ì‹œí•œë‹¤. (ì •ì±…/phase ë¶„í¬, Export ì‹¬ë³¼ë„ ëª…í™•)
ì¥ì 
- ëª…ì‹œì„±â†‘: phase ì¡°ê±´ ë¶„í¬, ë¡œê¹…, ATE ë³€í™˜ ì‹œ â€œMUL_READâ€ ê°™ì€ ì‹¬ë³¼ì„ ê·¸ëŒ€ë¡œ ì‚¬ìš© â†’ ê°€ë…ì„±Â·ë¶„ì„ ìš©ì´.
- íŠœë‹ ë¶„ë¦¬ ìš©ì´: ì‹±ê¸€/ë©€í‹°ë¥¼ ì „í˜€ ë‹¤ë¥´ê²Œ ìƒ˜í”Œë§í•˜ê³  ì‹¶ì„ ë•Œ ì§ì ‘ ì œì–´ ê°€ëŠ¥.

ë¦¬ìŠ¤í¬
1. êµ¬ì„±(ì»¨í”¼ê·¸) í­ì¦
  - phase_conditional í‚¤ê°€ READ ê³„ì—´ì—ì„œ ë‘ ë°° ì´ìƒìœ¼ë¡œ ëŠ˜ê³ (START/MID/END Ã— SIN/MUL), PROGRAM/ERASEë„ ë™ì¼.
  - í›… ì¡°ê±´ ì¡°í•©ì´ ë§ì„ìˆ˜ë¡ ìŠ¤íŒŒìŠ¤í•´ì§€ê³  ìš´ì˜/íŠœë‹ ë‚œì´ë„â†‘.
2. ì¤‘ë³µ/í‘œë¥˜ ìœ„í—˜
  - op_specs(state/hook) ì •ì˜ê°€ SIN/MULë¡œ ì´ì¤‘í™” â†’ ì‹œê°„ì´ ì§€ë‚˜ë©´ ì‚¬ì–‘ì´ ì–´ê¸‹ë‚  ìˆ˜ ìˆìŒ(í•œìª½ë§Œ ìˆ˜ì •ë˜ëŠ” ë“œë¦¬í”„íŠ¸).
3. ì˜ë¬´/ì˜ì¡´ì„± ë¡œì§ ì¤‘ë³µ
  - READâ†’DOUT ì˜ë¬´, dieâ€‘wide CORE_BUSY ì²˜ë¦¬, precheck/ì˜ˆì•½ ìŠ¤ì½”í”„ ë“± ë‘ ê³„ì—´ ëª¨ë‘ì— ë°˜ë³µ êµ¬í˜„ í•„ìš”.
4. ì„ íƒ ì‹¤íŒ¨/ê°•ë“± í•¸ë“¤ë§ ë³µì¡
  - MUL_READë¥¼ ë½‘ì•˜ëŠ”ë° ì •ë ¬ ê°€ëŠ¥í•œ planeâ€‘setì„ ëª» ì°¾ìœ¼ë©´ SIN_READë¡œ degrade í•˜ëŠ” ë¶„ê¸° í•„ìš”.
  - ì´ë•Œ â€œì´ë¯¸ MULì„ ì„ íƒí–ˆë‹¤â€ëŠ” ì •ì±… ì˜ë¯¸ê°€ í”ë“¤ë¦¼.

ì¢…í•© ë¦¬ìŠ¤í¬: ì¤‘~ë†’ìŒ. ìš´ì˜/íŠœë‹ í…Œì´ë¸”ì´ ì»¤ì§€ê³ , êµ¬í˜„ ì¤‘ë³µê³¼ ë“œë¦¬í”„íŠ¸ ê´€ë¦¬ ë¹„ìš©ì´ í¼.

ì˜µì…˜ 2) ë‹¨ì¼ OpKind + â€˜ê°€ì‚°ì„±(arity)â€™ ë©”íƒ€: READ/PROGRAM/ERASEëŠ” ê·¸ëŒ€ë¡œ, op.meta.arityì™€ plane_listë¡œ ë©€í‹°/ì‹±ê¸€ êµ¬ë¶„
ì˜ë„: ë‚´ë¶€ëŠ” ë‹¨ì¼ ì—°ì‚° ëª¨ë¸ì„ ìœ ì§€(ì˜ë¬´/ì˜ì¡´ì„±/ìŠ¤ì¼€ì¤„ë§ ë¡œì§ ì¬ì‚¬ìš©), Exportì—ì„œ **ì‹¬ë³¼ë§Œ â€˜SIN_â€™/â€˜MUL_â€™**ë¡œ ë§¤í•‘.
ì¥ì 
- êµ¬í˜„Â·ìœ ì§€ë³´ìˆ˜ ì•ˆì •: precheck/ì˜ˆì•½/ì˜ë¬´/ìŠ¤ì½”í”„ ë¡œì§ì„ í•œ ë²ˆë§Œ ì‘ì„±. ë“œë¦¬í”„íŠ¸ ìœ„í—˜â†“.
- ì»¨í”¼ê·¸ ê´€ë¦¬ ìš©ì´: phase_conditionalì€ **ê¸°ì¡´ í‚¤(READ/PROGRAM/ERASE)**ë¡œ ìœ ì§€, ëŒ€ì‹  ë³„ë„ â€˜arity ë¶„í¬â€™(fanout ë¶„í¬)ë¥¼ ë‘¬ ì œì–´.
- degrade ë‹¨ìˆœ: ë©€í‹° ì •ë ¬ ì‹¤íŒ¨ ì‹œ ì•„ë¦¬ìŠ¤í‹°ë§Œ ì¤„ì´ë©´ ë¨(ì—¬ì „íˆ READ).

ë¦¬ìŠ¤í¬
1. ì •ì±… íŠœë‹ í‘œí˜„ë ¥ ì €í•˜?
  - â€œMUL_READë§Œ íŠ¹ë³„í•˜ê²Œâ€ ê°™ì€ ìš”êµ¬ë¥¼ í‘œí˜„í•˜ë ¤ë©´ ë³„ë„ arity ë¶„í¬ í…Œì´ë¸”ì´ í•„ìš”.
2. Export ê°€ì‹œì„±
  - ë¡œê·¸/ë¦¬í¬íŠ¸ì—ì„œ â€˜MUL_*â€™ë¥¼ ë³´ê³  ì‹¶ìœ¼ë©´ Export/ë¡œê¹…ì—ì„œ alias ë§¤í•‘ì„ í•´ì•¼ í•¨.

ì¢…í•© ë¦¬ìŠ¤í¬: ë‚®ìŒ. ë‚´ë¶€ ì¼ê´€ì„±ì´ ë†’ê³ , êµ¬ì„± í­ë°œì„ ë§‰ì„ ìˆ˜ ìˆìŒ. Export/ë¡œê¹… ë ˆì´ì–´ì—ì„œë§Œ alias ì²˜ë¦¬.

ì˜µì…˜ 3) í•˜ì´ë¸Œë¦¬ë“œ(ê¶Œì¥): ê°€ì§œ ì—°ì‚°ëª…(ì—ì¼ë¦¬ì–´ìŠ¤) ì§€ì›
- ì •ì±…/ë¶„í¬ì—ì„œëŠ” SIN_READ/MUL_READ í‚¤ë¥¼ ì¨ë„ ë˜ê²Œ í•˜ê³ , ë‚´ë¶€ì—ì„œëŠ” ì´ë¥¼ ì—ì¼ë¦¬ì–´ìŠ¤ â†’ ê¸°ë³¸ ì—°ì‚° + arityë¡œ ì¦‰ì‹œ í•´ì„.
  - ì˜ˆ: MUL_READ  â†’ {base:"READ",  arity:â‰¥2}

SIN_READ  â†’ {base:"READ",  arity:1}

MUL_PROGRAM â†’ {base:"PROGRAM", arity:â‰¥2, scope:DIE_WIDE}
- op_specs/ì˜ë¬´/precheck/ì˜ˆì•½/ìŠ¤ì½”í”„ ë¡œì§ì€ **ê¸°ë³¸ ì—°ì‚°(READ/PROGRAM/ERASE)**ë§Œ ëŒ€ìƒìœ¼ë¡œ ìœ ì§€.
- Export ì‹œì—ëŠ” op.meta.arity>1 â†’ "MUL_*" ì‹¬ë³¼, ì•„ë‹ˆë©´ "SIN_*".

ì¥ì 
- ì˜µì…˜ 1ì˜ ëª…ì‹œì„± + ì˜µì…˜ 2ì˜ ë‚´ë¶€ ë‹¨ìˆœì„±ì„ ëª¨ë‘ ì·¨ë“.
- ì •ì±… í…Œì´ë¸”ì—ì„œ íŠœë‹ ë¬¸ë²•ì´ ì§ê´€ì (MUL_READ í‚¤ ì§ì ‘ ê¸°ì…)ì¸ë°, ë‚´ë¶€ëŠ” ì¤‘ë³µ êµ¬í˜„ ì—†ìŒ.
- ì •ë ¬ ì‹¤íŒ¨ ì‹œ alias í•´ì„ ë‹¨ê³„ì—ì„œ ìì—°ìŠ¤ëŸ½ê²Œ arity ê°•ë“± ì¬ì‹œë„ â†’ ì •ì±… ì˜ë¯¸ ìœ ì§€.

ë¦¬ìŠ¤í¬
- ì—ì¼ë¦¬ì–´ìŠ¤ í•´ì„ ê³„ì¸µì˜ ë³µì¡ë„(ì‘ì§€ë§Œ ì¡´ì¬):
  - ì—ì¼ë¦¬ì–´ìŠ¤â†’ê¸°ë³¸ ì—°ì‚°, arity/fanout ë²”ìœ„, scope(DIE_WIDE/PLANE_SET), page_equal ê·œì¹™ ë§¤í•‘.
  - ì˜ëª»ëœ ë§¤í•‘ ì‹œ ì˜ë¯¸ ì˜¤ì—¼ â†’ í…ŒìŠ¤íŠ¸ ì¼€ì´ìŠ¤ í•„ìˆ˜(MULâ†’SIN ê°•ë“±, dieâ€‘wide ì˜ˆì•½ í™•ì¸ ë“±).

ì¢…í•© ë¦¬ìŠ¤í¬: ë‚®ìŒ~ì¤‘ê°„. ë¡œì»¬ ë³µì¡ë„ë§Œ ì¦ê°€í•˜ê³ , ì „ì²´ ì‹œìŠ¤í…œ ë³µì¡ë„ëŠ” ì–µì œ.

â€œgreedy _find_aligned_subset ë¬¸ì œâ€ì™€ì˜ ê´€ê³„
- ì˜µì…˜ 1(ìª¼ê°œê¸°)ëŠ” ì„ íƒ ì‹¤íŒ¨ ì‹œ ì˜ë¯¸ ìœ„ë°˜ ê°€ëŠ¥ì„±ì´ ì»¤ì„œ ë” ìœ„í—˜.
- ì˜µì…˜ 2/3ì—ì„œëŠ”, ìƒ˜í”Œë§â€‘ìš°ì„  ì „ëµ(ë¹„íƒìš•)ìœ¼ë¡œ ë‹¤ì–‘ì„± í™•ë³´:
  - 2â€‘íŒ¨ìŠ¤ ìƒ˜í”Œë§: (a) planeâ€‘set í›„ë³´ë¥¼ í™•ë¥ ì ìœ¼ë¡œ ë¨¼ì € ë½‘ê³ , (b) ê°€ëŠ¥í•œ pageë¥¼ ìƒ˜í”Œ â†’ ë¶ˆê°€ë©´ ë‹¤ë¥¸ planeâ€‘setìœ¼ë¡œ ì¬ì‹œë„(ìµœëŒ€ NíšŒ), ë§ˆì§€ë§‰ì— arity ê°•ë“±.
  - íŒ¬ì•„ì›ƒ ë¶„í¬: phase/ìƒí™©ë³„ë¡œ fanout í™•ë¥ ì„ ëª…ì‹œ(ì˜ˆ: READ.CORE_BUSY.STARTì—ì„œ 4â€‘plane í™•ë¥ â†‘).
  - ë‹¤ì–‘ì„± ë“œë¼ì´ë²„: ìµœê·¼ ì‚¬ìš©ëœ planeâ€‘set/í˜ì´ì§€ë¥¼ íšŒí”¼í•˜ëŠ” penaltyë¥¼ ê°€ì¤‘ì¹˜ì— ë°˜ì˜.

ì´ë ‡ê²Œ í•˜ë©´ greedyê°€ ì•„ë‹ˆì–´ë„ ë‹¤ì–‘í•œ ë©€í‹°â€‘í”Œë ˆì¸ íŒ¨í„´ì„ ì•ˆì •ì ìœ¼ë¡œ ë°œìƒ.

ATE/Export ì¸¡ë©´ ë¦¬ìŠ¤í¬ ë¹„êµ

| í•­ëª© | ì˜µì…˜ 1(ìª¼ê°œê¸°) | ì˜µì…˜ 2(arity ë©”íƒ€) | ì˜µì…˜ 3(ì—ì¼ë¦¬ì–´ìŠ¤) |
| --- | --- | --- | --- |
| ì‹¬ë³¼ ëª…í™•ì„± | ìµœê³  (MUL_* ì§ë°©) | ì¤‘ (ë§¤í•‘ í•„ìš”) | ë†’ìŒ (ë‚´ë¶€ ë§¤í•‘ í›„ ì‹¬ë³¼ ëª…í™•) |
| ë³€í™˜ ë¡œì§ ë‚œì´ë„ | ë‚®ìŒ | ë‚®ìŒ | ë‚®ìŒ |
| íƒ€ì„ë¼ì¸ ë‹¨ì¼í™” | ë™ì¼(ë²„ìŠ¤ êµ¬ê°„ë§Œ ì·¨í•©) | ë™ì¼ | ë™ì¼ |
| NOP/WAIT ì²˜ë¦¬ | ë™ì¼ | ë™ì¼ | ë™ì¼ |

ì…‹ ë‹¤ Export ë‚œì´ë„ëŠ” ë¹„ìŠ·í•˜ì§€ë§Œ, ì˜µì…˜ 3ì´ ì„¤ì •ì˜ ì§ê´€ê³¼ ë‚´ë¶€ ì¼ê´€ì„±ì„ ë™ì‹œì— ë§Œì¡±.

ê¶Œì¥ì•ˆ (ê²°ë¡ )
- **ì˜µì…˜ 3: â€œì—ì¼ë¦¬ì–´ìŠ¤ ê¸°ë°˜ ë‹¨ì¼ ëª¨ë¸â€**ë¡œ ê°€ì.
  - ì •ì±…/ë¶„í¬/ë¡œê·¸/Exportì—ì„œëŠ” SIN_READ/MUL_READ/MUL_PROGRAM/MUL_ERASE ë“±ì„ ê·¸ëŒ€ë¡œ ì“¸ ìˆ˜ ìˆê³ ,
  - ë‚´ë¶€ëŠ” ê¸°ë³¸ OpKind(READ/PROGRAM/ERASE) + meta.arity + meta.plane_list + scopeë¡œ ë‹¨ì¼ êµ¬í˜„ ìœ ì§€.
  - ì •ë ¬ ì‹¤íŒ¨/ê°•ë“±ì€ ì—ì¼ë¦¬ì–´ìŠ¤ í•´ì„(ì„ íƒê¸°)ì—ì„œ ì²˜ë¦¬í•˜ë˜, ì •ì±… ì˜ë¯¸ ë³´ì¡´ì„ ìœ„í•´ ê°•ë“± ë¡œê·¸ì™€ ì¹´ìš´í„°ë¥¼ í•„ìˆ˜ë¡œ ë‚¨ê¹€.

êµ¬í˜„ ë©”ëª¨ (ê°„ë‹¨ ìŠ¤í™)
- ì—ì¼ë¦¬ì–´ìŠ¤ í…Œì´ë¸”
- phase_conditionalëŠ” SIN_READ/MUL_READ í‚¤ë¥¼ í—ˆìš©.

â†’ PolicyEngineì—ì„œ ì—ì¼ë¦¬ì–´ìŠ¤ì´ë©´ í•´ì„â†’ê¸°ë³¸ op + fanout ëª©í‘œë¡œ ë³€í™˜.
- **ì„ íƒê¸°(plan_multipane)**ëŠ” ìƒ˜í”Œë§ ë°©ì‹(ë¹„íƒìš•) + ìµœëŒ€ ì‹œë„ N + ê°•ë“±.
- precheck/reserveëŠ” ì´ë¯¸ scope(PLANE_SET/DIE_WIDE)ë³„ë¡œ ë™ì‘(ì•ì„œ ì„¤ê³„).

ë¦¬ìŠ¤í¬ ìš”ì•½(ì—ì¼ë¦¬ì–´ìŠ¤ ë°©ì‹)
- êµ¬ì„± í­ì¦: ë‚®ìŒ â€” í…Œì´ë¸”ì€ ëŠ˜ì§€ë§Œ ì½”ë“œ ì¤‘ë³µ ì—†ìŒ, ë¶„í¬ ì¡°ì‘ë„ ì§ê´€ì .
- êµ¬í˜„ ì¤‘ë³µ/í‘œë¥˜: ë‚®ìŒ â€” ë‚´ë¶€ ë¡œì§ ì¬ì‚¬ìš©.
- ì„ íƒ ì‹¤íŒ¨/ê°•ë“±: ì¤‘ê°„ â€” ì—ì¼ë¦¬ì–´ìŠ¤ í•´ì„ë¶€ì— êµ­í•œ, ë¡œê·¸/ë©”íŠ¸ë¦­ë¡œ ê´€ë¦¬ ê°€ëŠ¥.
- Export ë³µì¡ë„: ë‚®ìŒ â€” arity>1ì´ë©´ MUL_* ì‹¬ë³¼ë¡œ ë‚´ë³´ë‚´ê¸°.

ìµœì¢… íŒë‹¨: ë„¤ ìš”êµ¬(ATEì—ì„œ ë©€í‹°â€‘í”Œë ˆì¸=â€œí•˜ë‚˜ì˜ ì˜¤í¼ë ˆì´ì…˜â€)ë¥¼ ì •ë©´ìœ¼ë¡œ ë§Œì¡±í•˜ë©´ì„œ, ì‹œìŠ¤í…œ ë³µì¡ë„ë¥¼ ìµœì†Œí™”í•˜ë ¤ë©´ **ì—ì¼ë¦¬ì–´ìŠ¤ ê¸°ë°˜ ë‹¨ì¼ ëª¨ë¸(ì˜µì…˜ 3)**ì´ ê°€ì¥ ì•ˆì „í•˜ê³ , íŠœë‹/í…ŒìŠ¤íŠ¸/ìœ ì§€ ì¸¡ë©´ì—ì„œ ë¦¬ìŠ¤í¬ê°€ ê°€ì¥ ë‚®ë‹¤.

ì›í•˜ë©´, ì§€ê¸ˆ í†µí•©ë³¸ì— ì—ì¼ë¦¬ì–´ìŠ¤ íŒŒì„œ + ë¹„íƒìš• ì„ íƒê¸° + ê°•ë“± ë¡œê¹…ì„ ë°”ë¡œ ë„£ì€ íŒ¨ì¹˜ ë²„ì „ìœ¼ë¡œ ì œê³µí• ê²Œ.

## ğŸ‘¤ User

ì¢‹ì•„. ì œê³µí•´ì¤˜

## ğŸ¤– Assistant

ì•„ë˜ëŠ” ì—ì¼ë¦¬ì–´ìŠ¤ ê¸°ë°˜ ë©€í‹°â€‘í”Œë ˆì¸ ì§€ì› + dieâ€‘wide CORE_BUSY ì ìœ  + BusResource ê²Œì´íŒ…ì„ í†µí•©í•œ ë‹¨ì¼ íŒŒì¼ì´ì—ìš”.  

í¬í•¨ ì‚¬í•­:
- Op ì—ì¼ë¦¬ì–´ìŠ¤: SIN_READ / MUL_READ / SIN_PROGRAM / MUL_PROGRAM / SIN_ERASE / MUL_ERASE

â†’ ë‚´ë¶€ì—ì„  ê¸°ë³¸ OpKind(READ/PROGRAM/ERASE) + meta.arity, meta.plane_list, meta.scope ë¡œ ì¼ì›í™”
- ë¹„íƒìš• ë©€í‹°â€‘í”Œë ˆì¸ ì„ íƒê¸°(plan_multipane): ëœë¤ ìƒ˜í”Œë§ + ìë™ ê°•ë“±(degrade), í˜ì´ì§€ ë™ê¸°í™” ì¡°ê±´ ì¤€ìˆ˜
- dieâ€‘wide CORE_BUSY: PROGRAM/ERASE ëŠ” die ì „ì²´ plane ì ìœ 
- BusResource(ì „ì—­ ë²„ìŠ¤) ê²Œì´íŒ…: states[*].bus=true êµ¬ê°„ì€ ì „ì—­ ìƒí˜¸ë°°íƒ€ ì˜ˆì•½/ê²€ì‚¬
- phaseâ€‘conditional ë¶„í¬ì—ì„œ MUL_* / SIN_* í‚¤ ì‚¬ìš© ê°€ëŠ¥(ë‚´ë¶€ì—ì„œ í•´ì„)
- precheck/reserveê°€ scope(PLANE_SET / DIE_WIDE) ì— ë§ê²Œ ë™ì‘
- ê¸°ì¡´ ê¸°ëŠ¥(phase í™•ë¥ , quantize, fanout/interleave override, obligation READâ†’DOUT ë“±) ìœ ì§€

íŒŒì¼ëª… ì˜ˆ: nandsim_p2_alias_mplane.py

```python
# nandsim_p2_alias_mplane.py
# - Alias-based multi-plane ops (SIN_*/MUL_* â†’ base op + arity)
# - Non-greedy multi-plane planner with degrade
# - DIE_WIDE CORE_BUSY for PROGRAM/ERASE
# - Global BusResource gating for bus=true state segments
# - Phase-conditional policy + backoff score policy
# - Quantized event time, obligation READâ†’DOUT
# Stdlib only.

from __future__ import annotations
import heapq, random
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple, Set

# ---------------------------- Simulation Resolution ----------------------------
SIM_RES_US = 0.01
def quantize(t: float) -> float:
    return round(t / SIM_RES_US) * SIM_RES_US

# ---------------------------- Config ----------------------------
CFG = {
    "rng_seed": 12345,
    "policy": {
        "queue_refill_period_us": 3.0,
        "run_until_us": 180.0,
        "planner_max_tries": 8,       # ë¹„íƒìš• ì‹œë„ íšŸìˆ˜
    },
    # phase-conditional: í›…(OP.STATE(.POS)) â†’ ë‹¤ìŒ op ë¶„í¬(ì—ì¼ë¦¬ì–´ìŠ¤ í‚¤ í—ˆìš©)
    "phase_conditional": {
        "READ.ISSUE":                {"MUL_PROGRAM": 0.20, "SIN_PROGRAM": 0.10, "SIN_READ": 0.35, "MUL_READ": 0.25, "SIN_ERASE": 0.10},
        "READ.CORE_BUSY.START":      {"MUL_READ": 0.60, "SIN_READ": 0.20, "SIN_PROGRAM": 0.10, "SIN_ERASE": 0.10},
        "READ.DATA_OUT.START":       {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.20, "SIN_ERASE": 0.10},
        "PROGRAM.ISSUE":             {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.15, "SIN_ERASE": 0.15},
        "PROGRAM.CORE_BUSY.END":     {"SIN_READ": 0.55, "MUL_READ": 0.25, "SIN_PROGRAM": 0.10, "SIN_ERASE": 0.10},
        "ERASE.ISSUE":               {"SIN_PROGRAM": 0.40, "MUL_PROGRAM": 0.20, "SIN_READ": 0.30, "MUL_READ": 0.10},
        "ERASE.CORE_BUSY.END":       {"SIN_READ": 0.60, "MUL_READ": 0.20, "SIN_PROGRAM": 0.15, "MUL_PROGRAM": 0.05},
        "DEFAULT":                   {"SIN_READ": 0.55, "SIN_PROGRAM": 0.30, "SIN_ERASE": 0.15},
    },
    # backoff weights (phase-conditional ì‹¤íŒ¨ ì‹œ ì‚¬ìš©)
    "weights": {
        "base": {"host": {"READ": 0.85, "PROGRAM": 0.10, "ERASE": 0.05, "SR": 0.00, "RESET": 0.00, "DOUT": 0.00}},
        "g_state": {"pgmable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.8},
                    "readable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.9}},
        "g_local": {"plane_busy_frac": {"low": 1.2, "mid": 1.0, "high": 0.9}},
        "g_phase": {
            "READ": {"START_NEAR": 1.2, "MID_NEAR": 0.9, "END_NEAR": 1.2},
            "PROGRAM": {"START_NEAR": 1.1, "MID_NEAR": 1.0, "END_NEAR": 0.9},
            "ERASE": {"START_NEAR": 0.9, "MID_NEAR": 1.1, "END_NEAR": 1.1},
        },
    },
    "selection": {
        "defaults": {
            "READ":    {"fanout": 1, "interleave": True},
            "PROGRAM": {"fanout": 2, "interleave": True},
            "ERASE":   {"fanout": 2, "interleave": False},
        },
        "phase_overrides": {
            "READ.CORE_BUSY.START": {"fanout": 4, "interleave": True},
        }
    },
    "op_specs": {
        "READ": {
            "scope": "PLANE_SET",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 8.0, "std": 1.5, "min": 2.0}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "normal", "mean": 2.0, "std": 0.4, "min": 0.5}},
            ],
        },
        "PROGRAM": {
            "scope": "DIE_WIDE",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 20.0, "std": 3.0, "min": 8.0}},
            ],
        },
        "ERASE": {
            "scope": "DIE_WIDE",
            "page_equal_required": False,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 40.0, "std": 5.0, "min": 15.0}},
            ],
        },
        "DOUT": {
            "scope": "NONE",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": False, "dist": {"kind": "fixed",  "value": 0.2}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "normal", "mean": 1.0, "std": 0.2, "min": 0.2}},
            ],
        },
    },
    "obligations": [
        {
            "issuer": "READ",
            "require": "DOUT",
            "window_us": {"kind": "normal", "mean": 6.0, "std": 1.5, "min": 1.0},
            "priority_boost": {"start_us_before_deadline": 2.5, "boost_factor": 2.0, "hard_slot": True},
        }
    ],
    "topology": {"dies": 1, "planes_per_die": 4, "blocks_per_plane": 8, "pages_per_block": 16},
    "export": {"tu_us": 0.01, "nop_symbol": "NOP", "wait_as_nop": True, "drift_correction": True},
}

# ---------------------------- Alias mapping ----------------------------
OP_ALIAS = {
    "SIN_READ":    {"base": "READ",    "fanout": ("eq", 1)},
    "MUL_READ":    {"base": "READ",    "fanout": ("ge", 2)},
    "SIN_PROGRAM": {"base": "PROGRAM", "fanout": ("eq", 1)},
    "MUL_PROGRAM": {"base": "PROGRAM", "fanout": ("ge", 2)},
    "SIN_ERASE":   {"base": "ERASE",   "fanout": ("eq", 1)},
    "MUL_ERASE":   {"base": "ERASE",   "fanout": ("ge", 2)},
}

# ---------------------------- Models ----------------------------
class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

class Scope(Enum):
    NONE=0; PLANE_SET=1; DIE_WIDE=2

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float
    bus: bool = False

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)  # scope, plane_list, arity, alias_used, etc.

# ---------------------------- Utility ----------------------------
def sample_dist(d: Dict[str, Any]) -> float:
    k = d["kind"]
    if k == "fixed":
        return float(d["value"])
    if k == "normal":
        m, s = d["mean"], d["std"]
        mn = d.get("min", 0.0)
        v = random.gauss(m, s)
        return max(v, mn)
    if k == "exp":
        lam = d["lambda"]
        return random.expovariate(lam)
    raise ValueError(f"unknown dist kind: {k}")

def parse_hook_key(label: str):
    parts = label.split(".")
    if len(parts) >= 3: return parts[0], parts[1], parts[2]
    if len(parts) == 2: return parts[0], parts[1], None
    return None, None, None

def get_phase_dist(cfg: Dict[str,Any], hook_label: str):
    op, state, pos = parse_hook_key(hook_label)
    pc = cfg.get("phase_conditional", {})
    candidates = []
    if op and state and pos: candidates.append(f"{op}.{state}.{pos}")
    if op and state:         candidates.append(f"{op}.{state}")
    candidates.append("DEFAULT")
    for key in candidates:
        dist = pc.get(key)
        if dist and sum(dist.values()) > 0:
            return dist, key
    return None, None

def roulette_pick(dist: Dict[str, float], allow: set) -> Optional[str]:
    items = [(name, p) for name, p in dist.items() if name in allow and p > 0.0]
    if not items: return None
    total = sum(p for _, p in items)
    r = random.random()*total
    acc=0.0
    pick = items[-1][0]
    for name, p in items:
        acc += p
        if r <= acc:
            pick = name; break
    return pick

def resolve_alias(name: str) -> Tuple[str, Optional[Tuple[str,int]]]:
    """returns (base_name, fanout_constraint or None)"""
    if name in OP_ALIAS:
        base = OP_ALIAS[name]["base"]
        return base, OP_ALIAS[name]["fanout"]
    return name, None

# ---------------------------- OpSpec & builders ----------------------------
def build_operation(kind: OpKind, cfg_op: Dict[str, Any], targets: List[Address]) -> Operation:
    states=[]
    for s in cfg_op["states"]:
        dur = sample_dist(s["dist"])
        states.append(StateSeg(name=s["name"], dur_us=dur, bus=bool(s.get("bus", False))))
    return Operation(kind=kind, targets=targets, states=states)

def get_op_duration(op: Operation) -> float:
    return sum(seg.dur_us for seg in op.states)

# ---------------------------- Address / Bus Managers ----------------------------
class AddressManager:
    def __init__(self, cfg: Dict[str, Any]):
        topo = cfg["topology"]
        self.cfg = cfg
        self.dies = topo["dies"]
        self.planes = topo["planes_per_die"]
        self.pages_per_block = topo["pages_per_block"]
        self.blocks_per_plane = topo["blocks_per_plane"]

        self.available: Dict[Tuple[int,int], float] = {(0,p): 0.0 for p in range(self.planes)}  # plane availability
        self.cursors: Dict[Tuple[int,int], List[int]] = {(0,p): [0,0,0] for p in range(self.planes)}  # [block, next_pgm_page, next_rd_page]
        self.programmed: Dict[Tuple[int,int], Set[Tuple[int,int]]] = {(0,p): set() for p in range(self.planes)}  # (block,page) programmed pages
        self.resv: Dict[Tuple[int,int], List[Tuple[float,float,Optional[int]]]] = {(0,p): [] for p in range(self.planes)}  # per-plane (start,end,block)

        # Global bus reservation (ISSUE/DATA_OUT etc)
        self.bus_resv: List[Tuple[float,float]] = []  # [(start,end)] sorted by insertion time

    # ---- observation ----
    def available_at(self, die:int, plane:int) -> float:
        return self.available[(die,plane)]

    def earliest_start_for_scope(self, die:int, scope: Scope, plane_set: Optional[List[int]]=None) -> float:
        if scope == Scope.DIE_WIDE:
            planes = list(range(self.planes))
        elif scope == Scope.PLANE_SET and plane_set is not None:
            planes = plane_set
        else:
            planes = [plane_set[0]] if plane_set else [0]
        return max(self.available[(die,p)] for p in planes)

    def observe_states(self, die:int, plane:int, now_us: float):
        prog = len(self.programmed[(die,plane)])
        pgmable_ratio  = "mid" if prog < 10 else "low"
        readable_ratio = "mid" if prog > 0 else "low"
        plane_busy_frac = "high" if self.available_at(die,plane) > now_us else "low"
        return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls": "host"},
                {"plane_busy_frac": plane_busy_frac})

    # ---- bus segments helpers ----
    def bus_segments_for_op(self, op: Operation) -> List[Tuple[float,float]]:
        """relative offsets from op start for bus=true states"""
        segs=[]
        t=0.0
        for s in op.states:
            s0, s1 = t, t + s.dur_us
            if s.bus: segs.append((s0, s1))
            t = s1
        return segs

    def bus_precheck(self, start_hint: float, segs: List[Tuple[float,float]]) -> bool:
        """Check global bus availability for absolute segments"""
        for (off0, off1) in segs:
            a0, a1 = quantize(start_hint + off0), quantize(start_hint + off1)
            for (s,e) in self.bus_resv:
                if not (a1 <= s or e <= a0):
                    return False
        return True

    def bus_reserve(self, start_time: float, segs: List[Tuple[float,float]]):
        for (off0, off1) in segs:
            a0, a1 = quantize(start_time + off0), quantize(start_time + off1)
            self.bus_resv.append((a0,a1))

    # ---- planner: non-greedy multi-plane selection with degrade ----
    def _random_plane_sets(self, fanout:int, tries:int, start_plane:int) -> List[List[int]]:
        P = list(range(self.planes))
        out=[]
        for _ in range(tries):
            # bias: include start_plane with higher chance
            cand = set(random.sample(P, min(fanout, len(P))))
            if start_plane not in cand and random.random()<0.6:
                cand.pop() if len(cand)>0 else None
                cand.add(start_plane)
            out.append(sorted(cand))
        # unique
        uniq=[]
        seen=set()
        for ps in out:
            key=tuple(ps)
            if key not in seen and len(ps)==fanout:
                uniq.append(ps); seen.add(key)
        return uniq

    def _pages_present(self, die:int, plane:int) -> Set[int]:
        return {p for (_,p) in self.programmed[(die,plane)]}

    def plan_multipane(self, kind: OpKind, die:int, start_plane:int, desired_fanout:int, interleave:bool) -> Optional[Tuple[List[Address], List[int], Scope]]:
        if desired_fanout < 1: desired_fanout = 1
        tries = self.cfg["policy"]["planner_max_tries"]
        # degrade loop
        for f in range(desired_fanout, 0, -1):
            # candidate plane-sets
            candidates = self._random_plane_sets(f, tries, start_plane)
            for plane_set in candidates:
                # alignment per kind
                if kind == OpKind.READ:
                    # page must be common across planes (block may differ)
                    commons = None
                    for pl in plane_set:
                        pages = self._pages_present(die, pl)
                        commons = pages if commons is None else (commons & pages)
                        if not commons:
                            break
                    if not commons:
                        continue
                    page = random.choice(sorted(list(commons)))
                    targets=[]
                    for pl in plane_set:
                        # choose any block that has page
                        blks = [b for (b,p) in self.programmed[(die,pl)] if p==page]
                        blk = blks[0] if blks else 0
                        targets.append(Address(die, pl, block=blk, page=page))
                    scope = Scope.PLANE_SET

                elif kind == OpKind.PROGRAM:
                    # next_pgm_page must match across planes
                    ok=True
                    nxt=[]
                    for pl in plane_set:
                        b, pgm_p, _ = self.cursors[(die,pl)]
                        nxt.append(pgm_p)
                    ok = len(set(nxt))==1
                    if not ok:
                        continue
                    page = nxt[0]
                    targets=[]
                    for pl in plane_set:
                        b, pgm_p, _ = self.cursors[(die,pl)]
                        targets.append(Address(die, pl, block=b, page=page))
                    scope = Scope.DIE_WIDE  # die-wide CORE_BUSY

                elif kind == OpKind.ERASE:
                    targets=[]
                    for pl in plane_set:
                        b = self.cursors[(die,pl)][0]
                        targets.append(Address(die, pl, block=b, page=None))
                    scope = Scope.DIE_WIDE  # die-wide CORE_BUSY

                else:
                    continue

                return targets, plane_set, scope
        return None

    # ---- precheck / reserve / commit ----
    def precheck(self, kind: OpKind, targets: List[Address], start_hint: float, scope: Scope) -> bool:
        """Time overlap + simple block/page conflict (scope-aware)."""
        start_hint = quantize(start_hint); end_hint = start_hint  # guard = 0
        die = targets[0].die
        # choose planes to check (scope)
        if scope == Scope.DIE_WIDE:
            planes = {(die,p) for p in range(self.planes)}
        else:
            planes = {(t.die, t.plane) for t in targets}
        # time overlap
        for (d,p) in planes:
            for (s,e,_) in self.resv[(d,p)]:
                if not (end_hint <= s or e <= start_hint):
                    return False
        # simple block/page conflict rules (placeholder; extend in next step)
        # e.g., forbid ERASE with READ/PROGRAM on same block overlapping window
        return True

    def reserve(self, op: Operation, start: float, end: float):
        """scope-aware plane reservation; also update available times."""
        die = op.targets[0].die
        start = quantize(start); end = quantize(end)
        if op.meta.get("scope") == "DIE_WIDE":
            planes = [(die,p) for p in range(self.planes)]
        else:
            planes = [(t.die, t.plane) for t in op.targets]
        for (d,p) in planes:
            self.available[(d,p)] = max(self.available[(d,p)], end)
            self.resv[(d,p)].append((start, end, None))

    def commit(self, op: Operation):
        # update address state for PROGRAM/ERASE
        # (READ does not change programmed set)
        for t in op.targets:
            key = (t.die, t.plane)
            if op.kind == OpKind.PROGRAM and t.page is not None:
                self.programmed[key].add((t.block, t.page))
                # advance cursor
                b, pgm_p, rd = self.cursors[(t.die, t.plane)]
                pgm_p = (pgm_p + 1)
                if pgm_p >= self.pages_per_block:
                    pgm_p = 0
                    b = (b+1) % self.blocks_per_plane
                self.cursors[(t.die, t.plane)] = [b, pgm_p, rd]
            elif op.kind == OpKind.ERASE:
                # clear all pages in block
                self.programmed[key] = {pp for pp in self.programmed[key] if pp[0] != t.block]

# ---------------------------- Obligation Manager ----------------------------
@dataclass(order=True)
class _ObHeapItem:
    deadline_us: float
    seq: int
    ob: "Obligation" = field(compare=False)

@dataclass
class Obligation:
    require: OpKind
    targets: List[Address]
    deadline_us: float
    boost_factor: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg_list: List[Dict[str,Any]]):
        self.specs = cfg_list
        self.heap: List[_ObHeapItem] = []
        self._seq = 0

    def on_commit(self, op: Operation, now_us: float):
        # READ ì¢…ë£Œ â†’ DOUT ì˜ë¬´ (op.targets ì „ì²´ë¥¼ ê·¸ëŒ€ë¡œ ì‚¬ìš© = plane-set ë‹¨ì¼ ì˜¤í¼ë ˆì´ì…˜)
        for spec in self.specs:
            if spec["issuer"] == op.kind.name:
                dt = sample_dist(spec["window_us"])
                ob = Obligation(
                    require = OpKind[spec["require"]],
                    targets = op.targets,  # ê·¸ëŒ€ë¡œ ì „ë‹¬ â†’ DOUTë„ plane-set í•˜ë‚˜ì˜ op
                    deadline_us = quantize(now_us + dt),
                    boost_factor = spec["priority_boost"]["boost_factor"],
                    hard_slot = spec["priority_boost"].get("hard_slot", False),
                )
                heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=self._seq, ob=ob))
                self._seq += 1
                first = op.targets[0]
                print(f"[{now_us:7.2f} us] OBLIG  created: {op.kind.name} -> {ob.require.name} by {ob.deadline_us:7.2f} us, target(d0,p{first.plane}) page={first.page}")

    def pop_urgent(self, now_us: float, die:int, plane:int,
                   horizon_us: float, earliest_start: float) -> Optional[Obligation]:
        if not self.heap: return None
        kept: List[_ObHeapItem] = []
        chosen: Optional[Obligation] = None
        now_us = quantize(now_us)
        earliest_start = quantize(earliest_start)
        while self.heap and not chosen:
            item = heapq.heappop(self.heap)
            ob = item.ob
            # obligation plane-set includes this plane?
            plane_list = {a.plane for a in ob.targets}
            same_die = (ob.targets[0].die == die)
            same_plane = plane in plane_list
            in_horizon = ((ob.deadline_us - now_us) <= max(horizon_us, 0.0)) or ob.hard_slot
            feasible_time = (earliest_start <= ob.deadline_us)
            if same_die and same_plane and in_horizon and feasible_time:
                chosen = ob; break
            kept.append(item)
        for it in kept:
            heapq.heappush(self.heap, it)
        return chosen

# ---------------------------- Policy Engine ----------------------------
class PolicyEngine:
    def __init__(self, cfg, addr_mgr: AddressManager, obl_mgr: ObligationManager):
        self.cfg = cfg
        self.addr = addr_mgr
        self.obl = obl_mgr
        self.stats = {"alias_degrade": 0}

    def _score(self, op_name: str, phase_label: str, global_state: Dict[str,str], local_state: Dict[str,str]) -> float:
        w = self.cfg["weights"]["base"]["host"].get(op_name, 0.0)
        w *= self.cfg["weights"]["g_state"]["pgmable_ratio"].get(global_state["pgmable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_state"]["readable_ratio"].get(global_state["readable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_local"]["plane_busy_frac"].get(local_state["plane_busy_frac"], 1.0)
        near = "MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w *= self.cfg["weights"]["g_phase"].get(op_name, {}).get(near, 1.0)
        return w

    def _fanout_from_alias(self, base_name: str, alias_constraint: Optional[Tuple[str,int]], hook_label: str) -> Tuple[int,bool]:
        # phase override or defaults
        fanout, interleave = get_phase_selection_override(self.cfg, hook_label, base_name)
        if alias_constraint:
            mode, val = alias_constraint
            if mode == "eq":
                fanout = val
            elif mode == "ge":
                fanout = max(fanout, val)
        fanout = max(1, fanout)
        return fanout, interleave

    def propose(self, now_us: float, hook: PhaseHook,
                global_state: Dict[str,str], local_state: Dict[str,str],
                earliest_start: float) -> Optional[Operation]:
        die, hook_plane = hook.die, hook.plane

        # 0) Obligation first
        ob = self.obl.pop_urgent(now_us, die, hook_plane, horizon_us=10.0, earliest_start=earliest_start)
        if ob:
            # Build op for bus check
            cfg_op = self.cfg["op_specs"][ob.require.name]
            op = build_operation(ob.require, cfg_op, ob.targets)
            # scope/meta
            op.meta["scope"] = self.cfg["op_specs"][op.kind.name]["scope"]
            op.meta["plane_list"] = sorted({a.plane for a in op.targets})
            op.meta["arity"] = len(op.meta["plane_list"])
            # earliest start for scope set
            scope = Scope[op.meta["scope"]]
            plane_set = op.meta["plane_list"]
            start_hint = self.addr.earliest_start_for_scope(die, scope, plane_set)
            if self.addr.precheck(op.kind, op.targets, start_hint, scope) and \
               self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op)):
                op.meta["source"]="obligation"; op.meta["phase_key_used"]="(obligation)"; return op
            # else: cannot service obligation now â†’ let scheduler try later (no force)

        # 1) Phase-conditional distribution (allow alias keys)
        allow = set(list(OP_ALIAS.keys()) + ["READ","PROGRAM","ERASE"])
        dist, used_key = get_phase_dist(self.cfg, hook.label)
        if dist:
            pick = roulette_pick(dist, allow)
            if pick:
                base_name, alias_const = resolve_alias(pick)
                try_kind = OpKind[base_name]
                fanout, interleave = self._fanout_from_alias(base_name, alias_const, hook.label)
                # multi-plane planning with degrade
                planned = self.addr.plan_multipane(try_kind, die, hook_plane, fanout, interleave)
                if not planned and fanout>1:
                    # degrade to single-plane
                    self.stats["alias_degrade"] += 1
                    planned = self.addr.plan_multipane(try_kind, die, hook_plane, 1, interleave)
                if planned:
                    targets, plane_set, scope = planned
                    cfg_op = self.cfg["op_specs"][base_name]
                    op = build_operation(try_kind, cfg_op, targets)
                    op.meta["scope"] = cfg_op["scope"]
                    op.meta["plane_list"] = plane_set
                    op.meta["arity"] = len(plane_set)
                    op.meta["alias_used"] = pick
                    op.meta["fanout_req"] = fanout
                    op.meta["interleave"] = interleave
                    # scope-aware start hint (across plane_set or die-wide)
                    start_hint = self.addr.earliest_start_for_scope(die, scope, plane_set)
                    if self.addr.precheck(try_kind, targets, start_hint, scope) and \
                       self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op)):
                        op.meta["source"]="policy.phase_conditional"; op.meta["phase_key_used"]=used_key
                        return op
                # dist ìˆì—ˆì§€ë§Œ ì‹¤íŒ¨ â†’ score backoffë¡œ

        # 2) Backoff: score policy (single-plane default)
        cand=[]
        for name in ["READ","PROGRAM","ERASE"]:
            s=self._score(name, hook.label, global_state, local_state)
            if s>0: cand.append((name,s))
        if not cand: return None
        total=sum(s for _,s in cand)
        r=random.random()*total; acc=0.0; pick=cand[-1][0]
        for name,s in cand:
            acc+=s
            if r<=acc: pick=name; break
        try_kind=OpKind[pick]
        # single-plane plan
        planned = self.addr.plan_multipane(try_kind, die, hook_plane, 1, True)
        if not planned: return None
        targets, plane_set, scope = planned
        cfg_op = self.cfg["op_specs"][pick]
        op = build_operation(try_kind, cfg_op, targets)
        op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=plane_set; op.meta["arity"]=len(plane_set)
        start_hint = self.addr.earliest_start_for_scope(die, scope, plane_set)
        if not (self.addr.precheck(try_kind, targets, start_hint, scope) and \
                self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op))):
            return None
        op.meta["source"]="policy.score_backoff"; op.meta["phase_key_used"]="(score_backoff)"
        return op

# ---------------------------- Scheduler (with Bus gating) ----------------------------
def _addr_str(a: Address)->str:
    return f"(d{a.die},p{a.plane},b{a.block},pg{a.page})"

class Scheduler:
    def __init__(self, cfg, addr: AddressManager, spe: PolicyEngine, obl: ObligationManager):
        self.cfg=cfg; self.addr=addr; self.SPE=spe; self.obl=obl
        self.now=0.0
        self.ev=[]  # (time, seq, type, payload)
        self._seq=0
        self.stat_propose_calls=0; self.stat_scheduled=0
        self._push(0.0, "QUEUE_REFILL", None)
        for plane in range(self.addr.planes):
            self._push(0.0, "PHASE_HOOK", PhaseHook(0.0, "BOOT.START", 0, plane))

    def _push(self, t: float, typ: str, payload: Any):
        heapq.heappush(self.ev, (quantize(t), self._seq, typ, payload)); self._seq+=1

    def _start_time_for_op(self, op: Operation) -> float:
        die = op.targets[0].die
        scope = Scope[op.meta.get("scope","PLANE_SET")]
        plane_set = [a.plane for a in op.targets]
        # plane availability
        t_planes = self.addr.earliest_start_for_scope(die, scope, plane_set)
        # and bus availability (shift to avoid conflicts if needed)
        segs = self.addr.bus_segments_for_op(op)
        t = max(self.now, t_planes)
        # (ê°„ë‹¨) ì¶©ëŒ ì‹œì—ëŠ” propose ë‹¨ê³„ì—ì„œ ì´ë¯¸ ê±¸ë €ë‹¤ê³  ê°€ì • â†’ t ê·¸ëŒ€ë¡œ
        return quantize(t)

    def _schedule_operation(self, op: Operation):
        start = self._start_time_for_op(op)
        dur = get_op_duration(op)
        end = quantize(start + dur)
        # reserve: scope-aware
        self.addr.reserve(op, start, end)
        # reserve bus
        self.addr.bus_reserve(start, self.addr.bus_segments_for_op(op))
        # events & hooks
        self._push(start, "OP_START", op)
        self._push(end,   "OP_END",   op)
        # phase hooks: per plane
        for t in op.targets:
            # Labelì€ op.kind ê¸°ë°˜; í›…ì€ bus ì—¬ë¶€ì™€ ë¬´ê´€í•˜ê²Œ ìƒì„±(ì •ì±… íŠ¸ë¦¬ê±° ìš©)
            hooks=[]
            cur = start
            for s in op.states:
                # START
                hooks.append(PhaseHook(cur, f"{op.kind.name}.{s.name}.START", t.die, t.plane))
                # MID (only for "CORE_BUSY" as example)
                if s.name=="CORE_BUSY":
                    hooks.append(PhaseHook(cur + s.dur_us*0.5, f"{op.kind.name}.{s.name}.MID", t.die, t.plane))
                # END
                hooks.append(PhaseHook(cur + s.dur_us, f"{op.kind.name}.{s.name}.END", t.die, t.plane))
                cur += s.dur_us
            for h in hooks:
                self._push(h.time_us, "PHASE_HOOK", h)

        first = op.targets[0]
        print(f"[{self.now:7.2f} us] SCHED  {op.kind.name:7s} arity={op.meta.get('arity')} scope={op.meta.get('scope')} start={start:7.2f} end={end:7.2f} 1st={_addr_str(first)} src={op.meta.get('source')} alias={op.meta.get('alias_used')}")

        self.stat_scheduled += 1

    def run_until(self, t_end: float):
        t_end = quantize(t_end)
        while self.ev and self.ev[0][0] <= t_end:
            self.now, _, typ, payload = heapq.heappop(self.ev)

            if typ=="QUEUE_REFILL":
                for plane in range(self.addr.planes):
                    self._push(self.now, "PHASE_HOOK", PhaseHook(self.now, "REFILL.NUDGE", 0, plane))
                self._push(self.now + self.cfg["policy"]["queue_refill_period_us"], "QUEUE_REFILL", None)

            elif typ=="PHASE_HOOK":
                hook: PhaseHook = payload
                earliest_start = self.addr.available_at(hook.die, hook.plane)
                global_state, local_state = self.addr.observe_states(hook.die, hook.plane, self.now)
                self.stat_propose_calls += 1
                op = self.SPE.propose(self.now, hook, global_state, local_state, earliest_start)
                if op:
                    self._schedule_operation(op)

            elif typ=="OP_START":
                op: Operation = payload
                first = op.targets[0]
                print(f"[{self.now:7.2f} us] START  {op.kind.name:7s} arity={op.meta.get('arity')} target={_addr_str(first)}")

            elif typ=="OP_END":
                op: Operation = payload
                first = op.targets[0]
                print(f"[{self.now:7.2f} us] END    {op.kind.name:7s} arity={op.meta.get('arity')} target={_addr_str(first)}")
                self.addr.commit(op)
                self.obl.on_commit(op, self.now)

        print(f"\n=== Stats ===")
        print(f"propose calls : {self.stat_propose_calls}")
        print(f"scheduled ops : {self.stat_scheduled}")
        if self.stat_propose_calls:
            rate = 100.0 * self.stat_scheduled / self.stat_propose_calls
            print(f"accept ratio  : {rate:.1f}%")
        print(f"alias degrade : {self.SPE.stats.get('alias_degrade',0)}")

# ---------------------------- Selection helpers (phase overrides) ----------------------------
def get_phase_selection_override(cfg: Dict[str,Any], hook_label: str, kind_name: str):
    op, state, pos = parse_hook_key(hook_label)
    po = cfg.get("selection", {}).get("phase_overrides", {})
    keys = []
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    for k in keys:
        val = po.get(k)
        if val:
            f = int(val.get("fanout", 1))
            iv = bool(val.get("interleave", True))
            return f, iv
    dflt = cfg.get("selection", {}).get("defaults", {}).get(kind_name, {"fanout":1,"interleave":True})
    return int(dflt.get("fanout",1)), bool(dflt.get("interleave", True))

# ---------------------------- Main ----------------------------
def main():
    random.seed(CFG["rng_seed"])
    addr = AddressManager(CFG)
    obl  = ObligationManager(CFG["obligations"])
    spe  = PolicyEngine(CFG, addr, obl)
    sch  = Scheduler(CFG, addr, spe, obl)
    print("=== NAND Sequence Generator (Alias + Multi-plane + DIE_WIDE + Bus) ===")
    sch.run_until(CFG["policy"]["run_until_us"])
    print("=== Done ===")

if __name__ == "__main__":
    main()

```

ë³€ê²½ í¬ì¸íŠ¸ ìš”ì•½
- ì—ì¼ë¦¬ì–´ìŠ¤ ì§€ì›: phase_conditional ë¶„í¬ì—ì„œ MUL_READ ê°™ì€ í‚¤ë¥¼ ì§ì ‘ ì‚¬ìš©í•´ë„ ë©ë‹ˆë‹¤. ë‚´ë¶€ì—ì„  resolve_aliasê°€ ê¸°ë³¸ ì—°ì‚° + fanout ì œì•½ìœ¼ë¡œ ë°”ê¿‰ë‹ˆë‹¤.
- ë¹„íƒìš• í”Œë˜ë„ˆ: plan_multipaneê°€ ëœë¤ planeâ€‘setì„ ì—¬ëŸ¬ ë²ˆ ì‹œë„í•˜ê³ , í˜ì´ì§€ ë™ê¸°í™”ê°€ ë¶ˆê°€í•˜ë©´ fanoutì„ 1ê¹Œì§€ ìë™ ê°•ë“±í•©ë‹ˆë‹¤. ê°•ë“± ê±´ìˆ˜ëŠ” alias degradeë¡œ í†µê³„ë¥¼ ì°ìŠµë‹ˆë‹¤.
- dieâ€‘wide CORE_BUSY: PROGRAM/ERASEëŠ” ì˜ˆì•½ ì‹œ dieì˜ ëª¨ë“  planeì— ëŒ€í•´ ì‹œê°„ ì ìœ ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
- ë²„ìŠ¤ ê²Œì´íŒ…: op_specs.states[*].busê°€ Trueì¸ êµ¬ê°„ì€ ì „ì—­ BusResourceë¡œ precheck/reserve. ISSUE/DATA_OUT ì¶©ëŒì„ ì‚¬ì „ ì°¨ë‹¨í•©ë‹ˆë‹¤.
- DOUT ì˜ë¬´: READê°€ ëë‚˜ë©´ planeâ€‘set ë‹¨ì¼ ì˜¤í¼ë ˆì´ì…˜ìœ¼ë¡œ DOUT ì˜ë¬´ë¥¼ ìƒì„±í•©ë‹ˆë‹¤(Exportì—ì„œ í•˜ë‚˜ì˜ MUL_DOUTìœ¼ë¡œ ì²˜ë¦¬í•˜ê¸° ì‰¬ì›€).

ì›í•˜ë©´ ì—¬ê¸°ì— **GlobalTimelineBuilder(ATE íŒ¨í„´ ë³€í™˜; NOP ì±„ì›€/ë‹¨ìœ„ ìŠ¤ì¼€ì¼/ë“œë¦¬í”„íŠ¸ ë³´ì •)**ë„ ë°”ë¡œ ë¶™ì—¬ì„œ ë‚´ì¤„ê²Œ.

## ğŸ‘¤ User

ìš°ì„ , ë™ì‘ë„ í•˜ë‚˜ ì¶”ê°€í•˜ê³  phase_conditional ê°’ë“¤ë„ ë³€ê²½í•˜ì. 
- SR ë™ì‘ ì¶”ê°€. ëª¨ë“  phase, ì¦‰ CORE_BUSY ì—ì„œë„ ë™ì‘ ê°€ëŠ¥
- ERASE.CORE_BUSY, PROGRAM.CORE_BUSY ì—ì„œ READ,PROGRAM,ERASE ëª¨ë‘ ë™ì‘ ë¶ˆê°€ëŠ¥
- MUL_READ.CORE_BUSY ì—ì„œëŠ” READ,ERASE,PROGRAM ëª¨ë‘ ë¶ˆê°€
- SIN_READ.CORE_BUSY ì—ì„œëŠ” MUL_READ ë¶ˆê°€. SIN_READ ê°€ëŠ¥. ERASE, PROGRAM ë¶ˆê°€
- DOUT ì‹œì—ëŠ” ë™ì‘ ëë‚ ë•Œê¹Œì§€ ëª¨ë“  ë™ì‘ ë¶ˆê°€
CFG ë¿ë§Œ ì•„ë‹ˆë¼, êµ¬í˜„ ë¡œì§ë„ ë³€ê²½í•´ì•¼ í•œë‹¤ë©´, risk ë¥¼ í‰ê°€í•´ì¤˜. CFG ë¥¼ í†µí•´ì„œ ì œì•½ ì‚¬í•­ë“¤ì„ êµ¬í˜„í•˜ëŠ” ê²ƒì„ ìš°ì„  ìˆœìœ„ë¡œ í•˜ì.

## ğŸ¤– Assistant

ì•„ë˜ëŠ” ìš”ì²­í•œ ì œì•½ì„ CFG ìœ„ì£¼ë¡œ ë°˜ì˜í•˜ê³ , í•„ìš”í•œ ìµœì†Œí•œì˜ **êµ¬í˜„ ë¡œì§(ëŸ°íƒ€ì„ ë°°íƒ€ ê·œì¹™)**ì„ ì¶”ê°€í•œ í†µí•©ë³¸ì´ì—ìš”.  

í¬í•¨ ì‚¬í•­:
- SR ë™ì‘ ì¶”ê°€(ëª¨ë“  phaseì—ì„œ ê°€ëŠ¥)
- phase_conditional ê°±ì‹ :
  - PROGRAM.CORE_BUSY, ERASE.CORE_BUSY â†’ SRë§Œ í—ˆìš©
  - MUL_READ.CORE_BUSY â†’ SRë§Œ í—ˆìš©
  - SIN_READ.CORE_BUSY â†’ SIN_READ ë˜ëŠ” SRë§Œ í—ˆìš©, MUL_READ/ERASE/PROGRAM ë¶ˆê°€
- DOUT ì§„í–‰ ì¤‘ì—” â€œì „ì—­ ì •ì§€(ALL ê¸ˆì§€)â€: ì–´ë–¤ ë™ì‘ë„ ë¶ˆê°€( SR í¬í•¨ )
- ëŸ°íƒ€ì„ ë°°íƒ€(ExclusionManager): CFGì˜ constraints.exclusionsë¥¼ ì½ì–´, ìŠ¤ì¼€ì¤„ ì‹œì ì— ì½”ì–´ ë°”ìœ êµ¬ê°„/ì¶œë ¥ êµ¬ê°„ì— ëŒ€í•œ ê¸ˆì§€ ìœˆë„ìš°ë¥¼ ë“±ë¡í•˜ê³ , ì œì•ˆ ì‹œì ì— í—ˆìš© ì—¬ë¶€ë¥¼ ì²´í¬
- í›… ë¼ë²¨ì´ READì˜ ê²½ìš° SIN_READ / MUL_READë¡œ ë¶„ê¸°(phase ì¡°ê±´ê³¼ ì •í™•íˆ ë§¤ì¹­)

íŒŒì¼ëª… ì˜ˆ: nandsim_p3_constraints.py

```python
# nandsim_p3_constraints.py
# - SR op added (any phase)
# - Phase-conditional distributions updated for CORE_BUSY rules
# - DOUT: global freeze (no ops allowed) via runtime exclusions
# - ExclusionManager: config-driven runtime blocking windows
# - Alias-based READ labels in hooks: SIN_READ / MUL_READ
# - Multi-plane planner + DIE_WIDE CORE_BUSY + Bus gating + Quantize

from __future__ import annotations
import heapq, random
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple, Set

SIM_RES_US = 0.01
def quantize(t: float) -> float:
    return round(t / SIM_RES_US) * SIM_RES_US

# ---------------------------- Config ----------------------------
CFG = {
    "rng_seed": 12345,
    "policy": {
        "queue_refill_period_us": 3.0,
        "run_until_us": 180.0,
        "planner_max_tries": 8,
    },
    # phase-conditional: í›…(OP.STATE(.POS)) â†’ ë‹¤ìŒ op ë¶„í¬
    #  - CORE_BUSY ì œì•½ ë°˜ì˜
    "phase_conditional": {
        # ê¸°ë³¸ ë¶„í¬(ì¼ë¶€ ì˜ˆì‹œ)
        "READ.ISSUE":                {"MUL_PROGRAM": 0.15, "SIN_PROGRAM": 0.10, "SIN_READ": 0.35, "MUL_READ": 0.25, "SIN_ERASE": 0.15, "SR": 0.00},
        "READ.CORE_BUSY.START":      {"MUL_READ": 0.50, "SIN_READ": 0.20, "SIN_PROGRAM": 0.10, "SIN_ERASE": 0.10, "SR": 0.10},
        "READ.DATA_OUT.START":       {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.15, "SIN_ERASE": 0.10, "SR": 0.05},
        "PROGRAM.ISSUE":             {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.15, "SIN_ERASE": 0.10, "SR": 0.05},
        "PROGRAM.CORE_BUSY.END":     {"SIN_READ": 0.55, "MUL_READ": 0.25, "SIN_PROGRAM": 0.10, "SIN_ERASE": 0.05, "SR": 0.05},
        "ERASE.ISSUE":               {"SIN_PROGRAM": 0.40, "MUL_PROGRAM": 0.20, "SIN_READ": 0.25, "MUL_READ": 0.10, "SR": 0.05},
        "ERASE.CORE_BUSY.END":       {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.10, "MUL_PROGRAM": 0.05, "SR": 0.15},

        # === ê·œì¹™ ë°˜ì˜: CORE_BUSY ì¤‘ í—ˆìš©/ê¸ˆì§€ ===
        # PROGRAM/ERASE ì˜ CORE_BUSY ì¤‘ì—ëŠ” READ/PROGRAM/ERASE ëª¨ë‘ ê¸ˆì§€ â†’ SRë§Œ í—ˆìš©
        "PROGRAM.CORE_BUSY":         {"SR": 1.0},
        "ERASE.CORE_BUSY":           {"SR": 1.0},
        # MUL_READ ì˜ CORE_BUSY ì¤‘ì—ëŠ” READ/PROGRAM/ERASE ëª¨ë‘ ê¸ˆì§€ â†’ SRë§Œ í—ˆìš©
        "MUL_READ.CORE_BUSY":        {"SR": 1.0},
        # SIN_READ ì˜ CORE_BUSY ì¤‘ì—ëŠ” SIN_READ/SRë§Œ í—ˆìš©, MUL_READ/PROGRAM/ERASE ê¸ˆì§€
        "SIN_READ.CORE_BUSY":        {"SIN_READ": 0.6, "SR": 0.4},

        "DEFAULT":                   {"SIN_READ": 0.55, "SIN_PROGRAM": 0.25, "SIN_ERASE": 0.10, "SR": 0.10},
    },

    "weights": {  # ë°±ì˜¤í”„ìš©
        "base": {"host": {"READ": 0.70, "PROGRAM": 0.15, "ERASE": 0.05, "SR": 0.10, "RESET": 0.00, "DOUT": 0.00}},
        "g_state": {"pgmable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.8},
                    "readable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.9}},
        "g_local": {"plane_busy_frac": {"low": 1.2, "mid": 1.0, "high": 0.9}},
        "g_phase": {
            "READ": {"START_NEAR": 1.2, "MID_NEAR": 0.9, "END_NEAR": 1.2},
            "PROGRAM": {"START_NEAR": 1.1, "MID_NEAR": 1.0, "END_NEAR": 0.9},
            "ERASE": {"START_NEAR": 0.9, "MID_NEAR": 1.1, "END_NEAR": 1.1},
            "SR": {"START_NEAR": 1.1, "MID_NEAR": 1.1, "END_NEAR": 1.1},
        },
    },

    "selection": {
        "defaults": {
            "READ":    {"fanout": 1, "interleave": True},
            "PROGRAM": {"fanout": 2, "interleave": True},
            "ERASE":   {"fanout": 2, "interleave": False},
            "SR":      {"fanout": 1, "interleave": True},
        },
        "phase_overrides": {
            "READ.CORE_BUSY.START": {"fanout": 4, "interleave": True},
        }
    },

    "op_specs": {
        "READ": {
            "scope": "PLANE_SET",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 8.0, "std": 1.5, "min": 2.0}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "normal", "mean": 2.0, "std": 0.4, "min": 0.5}},
            ],
        },
        "PROGRAM": {
            "scope": "DIE_WIDE",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 20.0, "std": 3.0, "min": 8.0}},
            ],
        },
        "ERASE": {
            "scope": "DIE_WIDE",
            "page_equal_required": False,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 40.0, "std": 5.0, "min": 15.0}},
            ],
        },
        "DOUT": {
            "scope": "NONE",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": False, "dist": {"kind": "fixed",  "value": 0.2}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "normal", "mean": 1.0, "std": 0.2, "min": 0.2}},
            ],
        },
        "SR": {
            "scope": "NONE",
            "page_equal_required": False,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.2}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "fixed",  "value": 0.3}},
            ],
        },
    },

    # ëŸ°íƒ€ì„ ë°°íƒ€ ê·œì¹™(ìŠ¤ì¼€ì¤„ ì‹œ ìœˆë„ìš° ë“±ë¡ â†’ ì œì•ˆ ì‹œ í—ˆìš© ê²€ì‚¬)
    "constraints": {
        "exclusions": [
            # PROGRAM CORE_BUSY ë™ì•ˆ: READ/PROGRAM/ERASE ê¸ˆì§€ (die ìŠ¤ì½”í”„)
            {"when": {"op": "PROGRAM", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},
            # ERASE CORE_BUSY ë™ì•ˆ: READ/PROGRAM/ERASE ê¸ˆì§€ (die ìŠ¤ì½”í”„)
            {"when": {"op": "ERASE", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},
            # MUL_READ CORE_BUSY ë™ì•ˆ: READ/PROGRAM/ERASE ê¸ˆì§€ (die ìŠ¤ì½”í”„)
            {"when": {"op": "READ", "alias": "MUL", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},
            # SIN_READ CORE_BUSY ë™ì•ˆ: MUL_READ/PROGRAM/ERASE ê¸ˆì§€(READ ë‹¨ì¼ì€ í—ˆìš©)
            {"when": {"op": "READ", "alias": "SIN", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["ALIAS:MUL_READ", "BASE:PROGRAM", "BASE:ERASE"]},
            # DOUT ì „ì²´ êµ¬ê°„ ë™ì•ˆ: ì „ì—­ ALL ê¸ˆì§€
            {"when": {"op": "DOUT", "states": ["*"]}, "scope": "GLOBAL",
             "blocks": ["ANY"]},
        ]
    },

    "obligations": [
        {
            "issuer": "READ",
            "require": "DOUT",
            "window_us": {"kind": "normal", "mean": 6.0, "std": 1.5, "min": 1.0},
            "priority_boost": {"start_us_before_deadline": 2.5, "boost_factor": 2.0, "hard_slot": True},
        }
    ],

    "topology": {"dies": 1, "planes_per_die": 4, "blocks_per_plane": 8, "pages_per_block": 16},
    "export": {"tu_us": 0.01, "nop_symbol": "NOP", "wait_as_nop": True, "drift_correction": True},
}

# ---------------------------- Alias mapping ----------------------------
OP_ALIAS = {
    "SIN_READ":    {"base": "READ",    "fanout": ("eq", 1)},
    "MUL_READ":    {"base": "READ",    "fanout": ("ge", 2)},
    "SIN_PROGRAM": {"base": "PROGRAM", "fanout": ("eq", 1)},
    "MUL_PROGRAM": {"base": "PROGRAM", "fanout": ("ge", 2)},
    "SIN_ERASE":   {"base": "ERASE",   "fanout": ("eq", 1)},
    "MUL_ERASE":   {"base": "ERASE",   "fanout": ("ge", 2)},
}

# ---------------------------- Models ----------------------------
class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

class Scope(Enum):
    NONE=0; PLANE_SET=1; DIE_WIDE=2

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float
    bus: bool = False

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)

# ---------------------------- Utils ----------------------------
def sample_dist(d: Dict[str, Any]) -> float:
    k = d["kind"]
    if k == "fixed": return float(d["value"])
    if k == "normal":
        m, s, mn = d["mean"], d["std"], d.get("min", 0.0)
        v = random.gauss(m, s); return max(v, mn)
    if k == "exp": return random.expovariate(d["lambda"])
    raise ValueError(f"unknown dist kind: {k}")

def parse_hook_key(label: str):
    parts = label.split(".")
    if len(parts) >= 3: return parts[0], parts[1], parts[2]
    if len(parts) == 2: return parts[0], parts[1], None
    return None, None, None

def get_phase_dist(cfg: Dict[str,Any], hook_label: str):
    op, state, pos = parse_hook_key(hook_label)
    pc = cfg.get("phase_conditional", {})
    keys=[]
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    keys.append("DEFAULT")
    for key in keys:
        dist = pc.get(key)
        if dist and sum(dist.values())>0: return dist, key
    return None, None

def roulette_pick(dist: Dict[str, float], allow: set) -> Optional[str]:
    items=[(n,p) for n,p in dist.items() if n in allow and p>0]
    if not items: return None
    tot=sum(p for _,p in items); r=random.random()*tot; acc=0.0; pick=items[-1][0]
    for n,p in items:
        acc+=p
        if r<=acc: pick=n; break
    return pick

def resolve_alias(name: str) -> Tuple[str, Optional[Tuple[str,int]]]:
    if name in OP_ALIAS: return OP_ALIAS[name]["base"], OP_ALIAS[name]["fanout"]
    return name, None

# ---------------------------- Builders ----------------------------
def build_operation(kind: OpKind, cfg_op: Dict[str, Any], targets: List[Address]) -> Operation:
    states=[]
    for s in cfg_op["states"]:
        states.append(StateSeg(name=s["name"], dur_us=sample_dist(s["dist"]), bus=bool(s.get("bus", False))))
    return Operation(kind=kind, targets=targets, states=states)

def get_op_duration(op: Operation) -> float:
    return sum(seg.dur_us for seg in op.states)

# ---------------------------- Address & Bus Managers ----------------------------
class AddressManager:
    def __init__(self, cfg: Dict[str, Any]):
        topo=cfg["topology"]; self.cfg=cfg
        self.dies=topo["dies"]; self.planes=topo["planes_per_die"]
        self.pages_per_block=topo["pages_per_block"]; self.blocks_per_plane=topo["blocks_per_plane"]
        self.available={(0,p):0.0 for p in range(self.planes)}
        self.cursors={(0,p):[0,0,0] for p in range(self.planes)}  # block, next_pgm, next_rd
        self.programmed={(0,p):set() for p in range(self.planes)}  # (block,page)
        self.resv={(0,p):[] for p in range(self.planes)}           # (start,end,block)
        self.bus_resv: List[Tuple[float,float]] = []

    def available_at(self, die:int, plane:int)->float: return self.available[(die,plane)]

    def earliest_start_for_scope(self, die:int, scope: Scope, plane_set: Optional[List[int]]=None)->float:
        if scope==Scope.DIE_WIDE: planes=list(range(self.planes))
        elif scope==Scope.PLANE_SET and plane_set is not None: planes=plane_set
        else: planes=[plane_set[0]] if plane_set else [0]
        return max(self.available[(die,p)] for p in planes)

    def observe_states(self, die:int, plane:int, now_us: float):
        prog=len(self.programmed[(die,plane)])
        pgmable_ratio="mid" if prog<10 else "low"
        readable_ratio="mid" if prog>0 else "low"
        plane_busy_frac="high" if self.available_at(die,plane)>now_us else "low"
        return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls":"host"},
                {"plane_busy_frac": plane_busy_frac})

    # bus segments (relative offsets)
    def bus_segments_for_op(self, op: Operation)->List[Tuple[float,float]]:
        segs=[]; t=0.0
        for s in op.states:
            if s.bus: segs.append((t, t+s.dur_us))
            t+=s.dur_us
        return segs

    def bus_precheck(self, start_hint: float, segs: List[Tuple[float,float]])->bool:
        for (off0,off1) in segs:
            a0, a1 = quantize(start_hint+off0), quantize(start_hint+off1)
            for (s,e) in self.bus_resv:
                if not (a1<=s or e<=a0): return False
        return True

    def bus_reserve(self, start_time: float, segs: List[Tuple[float,float]]):
        for (off0,off1) in segs:
            self.bus_resv.append((quantize(start_time+off0), quantize(start_time+off1)))

    # planner (non-greedy)
    def _random_plane_sets(self, fanout:int, tries:int, start_plane:int)->List[List[int]]:
        P=list(range(self.planes)); out=[]; 
        for _ in range(tries):
            cand=set(random.sample(P, min(fanout,len(P))))
            if start_plane not in cand and random.random()<0.6:
                if len(cand)>0: cand.pop()
                cand.add(start_plane)
            if len(cand)==fanout: out.append(sorted(cand))
        uniq=[]; seen=set()
        for ps in out:
            k=tuple(ps)
            if k not in seen: uniq.append(ps); seen.add(k)
        return uniq

    def _pages_present(self, die:int, plane:int)->Set[int]:
        return {p for (_,p) in self.programmed[(die,plane)]}

    def plan_multipane(self, kind: OpKind, die:int, start_plane:int, desired_fanout:int, interleave:bool)\
            -> Optional[Tuple[List[Address], List[int], Scope]]:
        if desired_fanout<1: desired_fanout=1
        tries=self.cfg["policy"]["planner_max_tries"]
        for f in range(desired_fanout, 0, -1):
            for plane_set in self._random_plane_sets(f, tries, start_plane):
                if kind==OpKind.READ:
                    commons=None
                    for pl in plane_set:
                        pages=self._pages_present(die,pl)
                        commons=pages if commons is None else (commons & pages)
                        if not commons: break
                    if not commons: continue
                    page=random.choice(sorted(list(commons)))
                    targets=[]
                    for pl in plane_set:
                        blks=[b for (b,p) in self.programmed[(die,pl)] if p==page]
                        blk=blks[0] if blks else 0
                        targets.append(Address(die,pl,blk,page))
                    scope=Scope.PLANE_SET

                elif kind==OpKind.PROGRAM:
                    nxt=[]
                    for pl in plane_set:
                        b, pgm_p, _ = self.cursors[(die,pl)]
                        nxt.append(pgm_p)
                    if len(set(nxt))!=1: continue
                    page=nxt[0]; targets=[]
                    for pl in plane_set:
                        b, pgm_p, _ = self.cursors[(die,pl)]
                        targets.append(Address(die,pl,b,page))
                    scope=Scope.DIE_WIDE

                elif kind==OpKind.ERASE:
                    targets=[]
                    for pl in plane_set:
                        b=self.cursors[(die,pl)][0]
                        targets.append(Address(die,pl,b,None))
                    scope=Scope.DIE_WIDE

                elif kind==OpKind.SR:
                    targets=[Address(die,start_plane,0,None)]
                    scope=Scope.NONE

                else:
                    continue
                return targets, plane_set, scope
        return None

    def precheck_planescope(self, kind: OpKind, targets: List[Address], start_hint: float, scope: Scope)->bool:
        start_hint=quantize(start_hint); end_hint=start_hint
        die=targets[0].die
        if scope==Scope.DIE_WIDE: planes={(die,p) for p in range(self.planes)}
        elif scope==Scope.PLANE_SET: planes={(t.die,t.plane) for t in targets}
        else: planes={(targets[0].die, targets[0].plane)}
        for (d,p) in planes:
            for (s,e,_) in self.resv[(d,p)]:
                if not (end_hint<=s or e<=start_hint): return False
        return True

    def reserve_planescope(self, op: Operation, start: float, end: float):
        die=op.targets[0].die; start=quantize(start); end=quantize(end)
        if op.meta.get("scope")=="DIE_WIDE":
            planes=[(die,p) for p in range(self.planes)]
        elif op.meta.get("scope")=="PLANE_SET":
            planes=[(t.die,t.plane) for t in op.targets]
        else:
            planes=[(op.targets[0].die, op.targets[0].plane)]
        for (d,p) in planes:
            self.available[(d,p)]=max(self.available[(d,p)], end)
            self.resv[(d,p)].append((start,end,None))

    def commit(self, op: Operation):
        for t in op.targets:
            key=(t.die,t.plane)
            if op.kind==OpKind.PROGRAM and t.page is not None:
                self.programmed[key].add((t.block,t.page))
                b, pgm_p, rd = self.cursors[(t.die,t.plane)]
                pgm_p+=1
                if pgm_p>=self.pages_per_block:
                    pgm_p=0; b=(b+1)%self.blocks_per_plane
                self.cursors[(t.die,t.plane)]=[b,pgm_p,rd]
            elif op.kind==OpKind.ERASE:
                self.programmed[key]={pp for pp in self.programmed[key] if pp[0]!=t.block}

# ---------------------------- Exclusion Manager (runtime blocking) ----------------------------
@dataclass
class ExclWindow:
    start: float; end: float
    scope: str              # "GLOBAL" or "DIE"
    die: Optional[int]
    tokens: Set[str]        # e.g., {"ANY"}, {"BASE:READ"}, {"ALIAS:MUL_READ"}

class ExclusionManager:
    def __init__(self, cfg: Dict[str,Any]):
        self.cfg = cfg
        self.global_windows: List[ExclWindow] = []
        self.die_windows: Dict[int, List[ExclWindow]] = {}

    def _state_windows(self, op: Operation, start: float, states: List[str]) -> List[Tuple[float,float]]:
        wins=[]; t=start
        segs=[]
        for s in op.states:
            segs.append((s.name, t, t+s.dur_us)); t+=s.dur_us
        if states==["*"]:
            return [(segs[0][1], segs[-1][2])]
        want=set(states)
        for name, s0, s1 in segs:
            if name in want: wins.append((s0,s1))
        return wins

    def _token_blocks(self, tok: str, op: Operation) -> bool:
        if tok=="ANY": return True
        if tok.startswith("BASE:"):
            base=tok.split(":")[1]
            return op.kind.name==base
        if tok.startswith("ALIAS:"):
            alias=tok.split(":")[1]
            if alias=="MUL_READ": return (op.kind==OpKind.READ and op.meta.get("arity",1)>1)
            if alias=="SIN_READ": return (op.kind==OpKind.READ and op.meta.get("arity",1)==1)
        return False

    def allowed(self, op: Operation, start: float, end: float) -> bool:
        # check global
        for w in self.global_windows:
            if not (end<=w.start or w.end<=start):
                if any(self._token_blocks(tok, op) for tok in w.tokens):
                    return False
        # check die
        die=op.targets[0].die
        for w in self.die_windows.get(die, []):
            if not (end<=w.start or w.end<=start):
                if any(self._token_blocks(tok, op) for tok in w.tokens):
                    return False
        return True

    def register(self, op: Operation, start: float):
        rules = self.cfg.get("constraints",{}).get("exclusions",[])
        die = op.targets[0].die
        for r in rules:
            when=r["when"]; if_op=when.get("op")
            if if_op != op.kind.name: 
                # alias match for READ(SIN/MUL)
                if not (op.kind==OpKind.READ and if_op=="READ"): 
                    continue
            alias_need = when.get("alias")
            if alias_need=="MUL" and not (op.meta.get("arity",1)>1): 
                continue
            if alias_need=="SIN" and not (op.meta.get("arity",1)==1): 
                continue
            states = when.get("states", ["*"])
            windows = self._state_windows(op, start, states)
            scope=r.get("scope","GLOBAL"); tokens=set(r.get("blocks",[]))
            for (s0,s1) in windows:
                w=ExclWindow(start=quantize(s0), end=quantize(s1), scope=scope, die=(die if scope=="DIE" else None), tokens=tokens)
                if scope=="GLOBAL":
                    self.global_windows.append(w)
                else:
                    self.die_windows.setdefault(die,[]).append(w)

# ---------------------------- Obligation Manager ----------------------------
@dataclass(order=True)
class _ObHeapItem:
    deadline_us: float
    seq: int
    ob: "Obligation" = field(compare=False)

@dataclass
class Obligation:
    require: OpKind
    targets: List[Address]
    deadline_us: float
    boost_factor: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg_list: List[Dict[str,Any]]):
        self.specs = cfg_list
        self.heap: List[_ObHeapItem] = []; self._seq=0

    def on_commit(self, op: Operation, now_us: float):
        for spec in self.specs:
            if spec["issuer"] == op.kind.name:
                dt=sample_dist(spec["window_us"])
                ob=Obligation(require=OpKind[spec["require"]], targets=op.targets,
                              deadline_us=quantize(now_us+dt),
                              boost_factor=spec["priority_boost"]["boost_factor"],
                              hard_slot=spec["priority_boost"].get("hard_slot", False))
                heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=self._seq, ob=ob))
                self._seq+=1
                first=op.targets[0]
                print(f"[{now_us:7.2f} us] OBLIG  created: {op.kind.name} -> {ob.require.name} by {ob.deadline_us:7.2f} us, target(d{first.die},p{first.plane})")

    def pop_urgent(self, now_us: float, die:int, plane:int, horizon_us: float, earliest_start: float) -> Optional[Obligation]:
        if not self.heap: return None
        kept=[]; chosen=None
        now_us=quantize(now_us); earliest_start=quantize(earliest_start)
        while self.heap and not chosen:
            item=heapq.heappop(self.heap); ob=item.ob
            plane_list={a.plane for a in ob.targets}
            same_die=(ob.targets[0].die==die); same_plane=(plane in plane_list)
            in_horizon=((ob.deadline_us-now_us)<=max(horizon_us,0.0)) or ob.hard_slot
            feasible=(earliest_start<=ob.deadline_us)
            if same_die and same_plane and in_horizon and feasible: chosen=ob; break
            kept.append(item)
        for it in kept: heapq.heappush(self.heap, it)
        return chosen

# ---------------------------- Policy Engine ----------------------------
class PolicyEngine:
    def __init__(self, cfg, addr: AddressManager, obl: ObligationManager, excl: ExclusionManager):
        self.cfg=cfg; self.addr=addr; self.obl=obl; self.excl=excl
        self.stats={"alias_degrade":0}

    def _score(self, op_name: str, phase_label: str, g: Dict[str,str], l: Dict[str,str]) -> float:
        w=self.cfg["weights"]["base"]["host"].get(op_name,0.0)
        w*=self.cfg["weights"]["g_state"]["pgmable_ratio"].get(g["pgmable_ratio"],1.0)
        w*=self.cfg["weights"]["g_state"]["readable_ratio"].get(g["readable_ratio"],1.0)
        w*=self.cfg["weights"]["g_local"]["plane_busy_frac"].get(l["plane_busy_frac"],1.0)
        near="MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w*=self.cfg["weights"]["g_phase"].get(op_name,{}).get(near,1.0)
        return w

    def _fanout_from_alias(self, base_name: str, alias_constraint: Optional[Tuple[str,int]], hook_label: str)->Tuple[int,bool]:
        fanout, interleave = get_phase_selection_override(self.cfg, hook_label, base_name)
        if alias_constraint:
            mode,val=alias_constraint
            if mode=="eq": fanout=val
            elif mode=="ge": fanout=max(fanout,val)
        return max(1,fanout), interleave

    def _exclusion_ok(self, op: Operation, die:int, plane_set: List[int], start_hint: float) -> bool:
        scope = Scope[op.meta["scope"]]
        # scope-aware earliest start (already computed outside; but ensure not earlier than plane availability)
        start = self.addr.earliest_start_for_scope(die, scope, plane_set)
        dur = get_op_duration(op); end=quantize(start+dur)
        return self.excl.allowed(op, start, end)

    def propose(self, now_us: float, hook: PhaseHook, g: Dict[str,str], l: Dict[str,str], earliest_start: float) -> Optional[Operation]:
        die, hook_plane = hook.die, hook.plane

        # 0) obligation ìš°ì„ 
        ob=self.obl.pop_urgent(now_us, die, hook_plane, horizon_us=10.0, earliest_start=earliest_start)
        if ob:
            cfg_op=self.cfg["op_specs"][ob.require.name]; op=build_operation(ob.require, cfg_op, ob.targets)
            op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=sorted({a.plane for a in ob.targets}); op.meta["arity"]=len(op.meta["plane_list"])
            # gating check: plane, bus, exclusion
            scope=Scope[op.meta["scope"]]; plane_set=op.meta["plane_list"]
            start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
            if self.addr.precheck_planescope(op.kind, op.targets, start_hint, scope)\
               and self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op))\
               and self._exclusion_ok(op, die, plane_set, start_hint):
                op.meta["source"]="obligation"; op.meta["phase_key_used"]="(obligation)"; return op

        # 1) phase-conditional (alias í‚¤ í—ˆìš© + SR í¬í•¨)
        allow=set(list(OP_ALIAS.keys())+["READ","PROGRAM","ERASE","SR"])
        dist, used_key = get_phase_dist(self.cfg, hook.label)
        if dist:
            pick=roulette_pick(dist, allow)
            if pick:
                base, alias_const = resolve_alias(pick)
                kind=OpKind[base]
                # SRì€ ë‹¨ì¼ í”Œë ˆì¸
                if kind==OpKind.SR:
                    plan=self.addr.plan_multipane(kind, die, hook_plane, 1, True)
                else:
                    fanout, interleave=self._fanout_from_alias(base, alias_const, hook.label)
                    plan=self.addr.plan_multipane(kind, die, hook_plane, fanout, interleave)
                    if not plan and fanout>1:
                        self.stats["alias_degrade"]+=1
                        plan=self.addr.plan_multipane(kind, die, hook_plane, 1, interleave)
                if plan:
                    targets, plane_set, scope=plan
                    cfg_op=self.cfg["op_specs"][base]; op=build_operation(kind, cfg_op, targets)
                    op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=plane_set; op.meta["arity"]=len(plane_set); op.meta["alias_used"]=pick
                    start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
                    if self.addr.precheck_planescope(kind, targets, start_hint, scope)\
                       and self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op))\
                       and self._exclusion_ok(op, die, plane_set, start_hint):
                        op.meta["source"]="policy.phase_conditional"; op.meta["phase_key_used"]=used_key; return op
            # ì‹¤íŒ¨ ì‹œ ë°±ì˜¤í”„

        # 2) backoff (READ/PROGRAM/ERASE/SR)
        cand=[]
        for name in ["READ","PROGRAM","ERASE","SR"]:
            s=self._score(name, hook.label, g, l)
            if s>0: cand.append((name,s))
        if not cand: return None
        tot=sum(s for _,s in cand); r=random.random()*tot; acc=0.0; pick=cand[-1][0]
        for name,s in cand:
            acc+=s
            if r<=acc: pick=name; break
        kind=OpKind[pick]
        if kind==OpKind.SR:
            plan=self.addr.plan_multipane(kind, die, hook_plane, 1, True)
        else:
            fanout, interleave=get_phase_selection_override(self.cfg, hook.label, pick)
            plan=self.addr.plan_multipane(kind, die, hook_plane, fanout, interleave)
        if not plan: return None
        targets, plane_set, scope=plan
        cfg_op=self.cfg["op_specs"][pick]; op=build_operation(kind, cfg_op, targets)
        op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=plane_set; op.meta["arity"]=len(plane_set)
        start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
        if not (self.addr.precheck_planescope(kind, targets, start_hint, scope)\
                and self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op))\
                and self._exclusion_ok(op, die, plane_set, start_hint)):
            return None
        op.meta["source"]="policy.score_backoff"; op.meta["phase_key_used"]="(score_backoff)"; return op

# ---------------------------- Scheduler ----------------------------
def _addr_str(a: Address)->str: return f"(d{a.die},p{a.plane},b{a.block},pg{a.page})"

class Scheduler:
    def __init__(self, cfg, addr: AddressManager, spe: PolicyEngine, obl: ObligationManager, excl: ExclusionManager):
        self.cfg=cfg; self.addr=addr; self.SPE=spe; self.obl=obl; self.excl=excl
        self.now=0.0; self.ev=[]; self._seq=0
        self.stat_propose_calls=0; self.stat_scheduled=0
        self._push(0.0, "QUEUE_REFILL", None)
        for plane in range(self.addr.planes):
            self._push(0.0, "PHASE_HOOK", PhaseHook(0.0, "BOOT.START", 0, plane))

    def _push(self, t: float, typ: str, payload: Any):
        heapq.heappush(self.ev, (quantize(t), self._seq, typ, payload)); self._seq+=1

    def _start_time_for_op(self, op: Operation) -> float:
        die=op.targets[0].die
        scope=Scope[op.meta.get("scope","PLANE_SET")]
        plane_set=[a.plane for a in op.targets]
        t_planes=self.addr.earliest_start_for_scope(die, scope, plane_set)
        return quantize(max(self.now, t_planes))

    def _label_for_read(self, op: Operation)->str:
        if op.kind!=OpKind.READ: return op.kind.name
        return "MUL_READ" if op.meta.get("arity",1)>1 else "SIN_READ"

    def _schedule_operation(self, op: Operation):
        start=self._start_time_for_op(op); dur=get_op_duration(op); end=quantize(start+dur)
        # plane scope reserve + bus reserve + exclusion windows register
        self.addr.reserve_planescope(op, start, end)
        self.addr.bus_reserve(start, self.addr.bus_segments_for_op(op))
        self.excl.register(op, start)

        # events
        self._push(start, "OP_START", op); self._push(end, "OP_END", op)

        # phase hooks (ë¼ë²¨: READëŠ” SIN_READ/MUL_READ)
        label_op=self._label_for_read(op)
        for t in op.targets:
            cur=start
            for s in op.states:
                self._push(cur,               "PHASE_HOOK", PhaseHook(cur,               f"{label_op}.{s.name}.START", t.die, t.plane))
                if s.name=="CORE_BUSY": 
                    self._push(cur + s.dur_us*0.5, "PHASE_HOOK", PhaseHook(cur + s.dur_us*0.5, f"{label_op}.{s.name}.MID",   t.die, t.plane))
                self._push(cur + s.dur_us,    "PHASE_HOOK", PhaseHook(cur + s.dur_us,    f"{label_op}.{s.name}.END",   t.die, t.plane))
                cur += s.dur_us

        first=op.targets[0]
        print(f"[{self.now:7.2f} us] SCHED  {op.kind.name:7s} arity={op.meta.get('arity')} scope={op.meta.get('scope')} start={start:7.2f} end={end:7.2f} 1st={_addr_str(first)} src={op.meta.get('source')} alias={op.meta.get('alias_used')}")

        self.stat_scheduled+=1

    def run_until(self, t_end: float):
        t_end=quantize(t_end)
        while self.ev and self.ev[0][0] <= t_end:
            self.now, _, typ, payload = heapq.heappop(self.ev)

            if typ=="QUEUE_REFILL":
                for plane in range(self.addr.planes):
                    self._push(self.now, "PHASE_HOOK", PhaseHook(self.now, "REFILL.NUDGE", 0, plane))
                self._push(self.now + self.cfg["policy"]["queue_refill_period_us"], "QUEUE_REFILL", None)

            elif typ=="PHASE_HOOK":
                hook: PhaseHook = payload
                earliest_start=self.addr.available_at(hook.die, hook.plane)
                g,l=self.addr.observe_states(hook.die, hook.plane, self.now)
                self.stat_propose_calls+=1
                op=self.SPE.propose(self.now, hook, g, l, earliest_start)
                if op: self._schedule_operation(op)

            elif typ=="OP_START":
                op: Operation=payload; first=op.targets[0]
                print(f"[{self.now:7.2f} us] START  {op.kind.name:7s} arity={op.meta.get('arity')} target={_addr_str(first)}")

            elif typ=="OP_END":
                op: Operation=payload; first=op.targets[0]
                print(f"[{self.now:7.2f} us] END    {op.kind.name:7s} arity={op.meta.get('arity')} target={_addr_str(first)}")
                self.addr.commit(op); self.obl.on_commit(op, self.now)

        print(f"\n=== Stats ===")
        print(f"propose calls : {self.stat_propose_calls}")
        print(f"scheduled ops : {self.stat_scheduled}")
        if self.stat_propose_calls:
            print(f"accept ratio  : {100.0*self.stat_scheduled/self.stat_propose_calls:.1f}%")
        print(f"(note) runtime exclusions: GLOBAL={len(self.excl.global_windows)}, DIE={sum(len(v) for v in self.excl.die_windows.values())}")

# ---------------------------- Selection overrides ----------------------------
def get_phase_selection_override(cfg: Dict[str,Any], hook_label: str, kind_name: str):
    op, state, pos = parse_hook_key(hook_label)
    po=cfg.get("selection",{}).get("phase_overrides",{})
    keys=[]
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    for k in keys:
        val=po.get(k)
        if val:
            return int(val.get("fanout",1)), bool(val.get("interleave",True))
    dflt=cfg.get("selection",{}).get("defaults",{}).get(kind_name,{"fanout":1,"interleave":True})
    return int(dflt.get("fanout",1)), bool(dflt.get("interleave",True))

# ---------------------------- Main ----------------------------
def main():
    random.seed(CFG["rng_seed"])
    addr=AddressManager(CFG); excl=ExclusionManager(CFG)
    obl=ObligationManager(CFG["obligations"])
    spe=PolicyEngine(CFG, addr, obl, excl)
    sch=Scheduler(CFG, addr, spe, obl, excl)
    print("=== NAND Sequence Generator (P3: SR + CORE_BUSY constraints + DOUT freeze) ===")
    sch.run_until(CFG["policy"]["run_until_us"])
    print("=== Done ===")

if __name__=="__main__":
    main()

```

ì™œ ì´ë ‡ê²Œ ë°”ê¿¨ëŠ”ê°€? (ìš”êµ¬ì‚¬í•­ â†” êµ¬í˜„ ëŒ€ì‘)
1. SR ì¶”ê°€ & CORE_BUSYì—ì„œë„ í—ˆìš©
  - op_specs.SR ì¶”ê°€(ë²„ìŠ¤ ì‚¬ìš©), phase_conditional ì „ êµ¬ê°„ì—ì„œ SR í™•ë¥  ë„£ì–´ë‘ê³ , íŠ¹íˆ CORE_BUSY ì œí•œ êµ¬ê°„ì„ SR ìœ„ì£¼ë¡œ ì„¤ì •.
2. PROGRAM/ERASEì˜ CORE_BUSY ì¤‘ READ/PROGRAM/ERASE ê¸ˆì§€
  - CFG/phase: PROGRAM.CORE_BUSY, ERASE.CORE_BUSY í‚¤ì—ì„œ SRë§Œ í—ˆìš©(ë¶„í¬ 1.0)
  - ëŸ°íƒ€ì„: constraints.exclusionsë¡œ CORE_BUSY êµ¬ê°„ì„ die ìŠ¤ì½”í”„ ë°°íƒ€ ìœˆë„ìš°ë¡œ ë“±ë¡ â†’ ì œì•ˆ ì‹œ ì–´ë–¤ í›…ì´ ì˜¤ë”ë¼ë„ ë™ì¼ ê·œì¹™ ê°•ì œ
3. MUL_READ.CORE_BUSYì—ì„œ READ/ERASE/PROGRAM ê¸ˆì§€
  - í›„í¬ ë¼ë²¨ì´ MUL_READë¡œ í‘œê¸°ë˜ë„ë¡ ë³€ê²½ â†’ phase_conditional["MUL_READ.CORE_BUSY"] ì ìš©
  - ëŸ°íƒ€ì„: alias:MUL ì¡°ê±´ì˜ ë°°íƒ€ ê·œì¹™ìœ¼ë¡œ ë™ì¼ ê°•ì œ
4. SIN_READ.CORE_BUSYì—ì„œ SIN_READë§Œ í—ˆìš©(ë©€í‹° ë¶ˆê°€), ERASE/PROGRAM ë¶ˆê°€
  - CFG: SIN_READ.CORE_BUSY: {SIN_READ, SR}
  - ëŸ°íƒ€ì„: alias:SIN ê·œì¹™ì´ MUL_READë§Œ ì°¨ë‹¨í•˜ë„ë¡ í† í°(ALIAS:MUL_READ) ì‚¬ìš©
5. DOUT ì¤‘ ì „ì—­ ì •ì§€(ALL ë¶ˆê°€)
  - ëŸ°íƒ€ì„: op=DOUT, states=["*"], scope=GLOBAL, blocks=["ANY"]
  - DOUTì˜ ì „ì²´ êµ¬ê°„(start~end)ì— ëŒ€í•´ ì–´ë–¤ ì—°ì‚°ë„ ì˜ˆì•½ ë¶ˆê°€(SR í¬í•¨)

ë¦¬ìŠ¤í¬ í‰ê°€
- í›… ë¼ë²¨ ë³€ê²½(READ â†’ SIN_READ/MUL_READ)
  - ë¦¬ìŠ¤í¬: ê¸°ì¡´ phase_conditional í‚¤ì™€ì˜ í˜¸í™˜ì„±.
  - ì™„í™”: DEFAULTì™€ READ.* í‚¤ê°€ ê³„ì† ì¡´ì¬í•˜ë©´ ë°±ì˜¤í”„ ë™ì‘. ì´ë²ˆ ë²„ì „ì€ ìƒˆ í‚¤ë¥¼ ë„£ì—ˆê³ , ê¸°ì¡´ í‚¤ì™€ ë³‘í–‰ ê°€ëŠ¥.
- ëŸ°íƒ€ì„ ë°°íƒ€(ExclusionManager) ì¶”ê°€
  - ë¦¬ìŠ¤í¬: false reject/accept ì‹œ íƒ€ì„ë¼ì¸ ì •í•©ì„± í”ë“¤ë¦¼.
  - ì™„í™”: ë°°íƒ€ ìœˆë„ìš°ëŠ” ìŠ¤ì¼€ì¤„ ì„±ê³µ ì‹œì ì—ë§Œ ë“±ë¡í•˜ë¯€ë¡œ, ì´ë¯¸ ì˜ˆì•½ëœ ë™ì‘ê³¼ ëª¨ìˆœë˜ì§€ ì•ŠìŒ. ì‚¬ì „ê²€ì‚¬(planescope/bus)ì™€ ë™ì¼ ë‹¨ê³„ì—ì„œ í•¨ê»˜ ê²€ì‚¬.
- DOUT ê¸€ë¡œë²Œ í”„ë¦¬ì¦ˆ
  - ë¦¬ìŠ¤í¬: Throughput ê°ì†Œ ê°€ëŠ¥.
  - ì™„í™”: ìš”êµ¬ì‚¬í•­ì´ â€œì „ì—­ ê¸ˆì§€â€ì´ë¯€ë¡œ ì¶©ì¡±ì„ ìš°ì„ . í•„ìš”í•˜ë©´ scope: DIEë¡œ ì™„í™” ê°€ëŠ¥(ë‹¤ì´ë¥¼ ì—¬ëŸ¬ ê°œ ì“°ëŠ” ê²½ìš°).
- SR ë²„ìŠ¤ ì¶©ëŒ
  - ë¦¬ìŠ¤í¬: SRë„ ë²„ìŠ¤ ì‚¬ìš©ì´ë¯€ë¡œ ISSUE/DATA_OUTê³¼ ì¶©ëŒ â†’ bus_precheckê°€ ë§‰ìŒ(ì˜ë„í•œ ë™ì‘).

ë‹¤ìŒ ë‹¨ê³„ ì œì•ˆ (ì„ íƒ)
- ë©”íŠ¸ë¦­: ë°°íƒ€ ê·œì¹™ ë°œë™ íšŸìˆ˜/ì‚¬ìœ (í† í° ê¸°ì¤€), alias degrade count, DOUT freezeë¡œ ì¸í•œ ì œì•ˆ ê±°ì ˆë¥ .
- Export(GlobalTimelineBuilder): DOUT í”„ë¦¬ì¦ˆ/CORE_BUSY ë°°íƒ€ êµ¬ê°„ì€ NOP/WAIT ì‚½ì…ê³¼ ì˜ ë§ìŠµë‹ˆë‹¤(ì´ì „ ì„¤ê³„ì™€ í˜¸í™˜).

í•„ìš”í•˜ë©´ ì´ ë²„ì „ì— **GlobalTimelineBuilder(ATE ë³€í™˜ê¸° ì´ˆì•ˆ)**ê¹Œì§€ ë°”ë¡œ ë¬¶ì–´ì„œ ë“œë¦´ê²Œìš”.

## ğŸ‘¤ User

address_manager.py
Python
ì•„ë˜ëŠ” í…ŒìŠ¤íŠ¸ ê²°ê³¼ì•¼
=== NAND Sequence Generator (P3: SR + CORE_BUSY constraints + DOUT freeze) ===
[ 0.00 us] SCHED SR arity=1 scope=NONE start= 0.00 end= 0.50 1st=(d0,p0,b0,pgNone) src=policy.score_backoff alias=None
[ 0.00 us] SCHED PROGRAM arity=1 scope=DIE_WIDE start= 0.50 end= 20.13 1st=(d0,p0,b0,pg0) src=policy.phase_conditional alias=SIN_PROGRAM
[ 0.00 us] START SR arity=1 target=(d0,p0,b0,pgNone)
[ 0.00 us] SCHED PROGRAM arity=2 scope=DIE_WIDE start= 20.13 end= 39.71 1st=(d0,p0,b0,pg0) src=policy.score_backoff alias=None
â€”-
program ì´ ëœ (d0,p0,b0,pg0) ì— ì¤‘ë³µìœ¼ë¡œ program ë˜ëŠ” ì˜¤ë¥˜ê°€ ìˆì–´. addressmanager ê°€ block ë§ˆë‹¤ ë§ˆì§€ë§‰ program page ë¥¼ ê¸°ë¡í•˜ê³  ìˆì–´ì•¼ í•˜ê³ , ì—¬ê¸°ì„œ ë°œìƒí•˜ëŠ” read block ì˜ ì¡°ê±´ì´ ê²°ì •ë¼. read ëŠ” program ëœ page ê¹Œì§€ë§Œ read ê°€ëŠ¥í•˜ê³ , program ì´ í•œë²ˆë„ ë˜ì§€ ì•Šì€ block ì€ ì½ì„ ìˆ˜ê°€ ì—†ì–´.

ë‚´ê°€ ì²¨ë¶€í•œ íŒŒì¼ì€ ì´ëŸ° ì œì•½ ì‚¬í•­ë“¤ì„ ë°˜ì˜í•´ì„œ ë§Œë“  address_manager.py íŒŒì¼ì´ì•¼. ì´ íŒŒì¼ì„ ì½ê³  êµ¬í˜„ ë‚´ìš©ì„ íŒŒì•…í•´ì„œ, í˜„ì¬ì˜ nandsim ì— ë°˜ì˜í•  ìˆ˜ ìˆë„ë¡ í•´.
ìš°ì„  ë¦¬ë·°í•œ ë‚´ìš©ì„ ë°”íƒ•ìœ¼ë¡œ êµ¬í˜„ ê³„íšì„ ì œì‹œí•´ë´

## ğŸ¤– Assistant

ì¢‹ì•„. ì¤‘ë³µ PROGRAM(page=0) ìŠ¤ì¼€ì¤„ë§ ë²„ê·¸ì˜ ì›ì¸ì€ â€œì»¤ë°‹ ì „ ì˜ˆì•½ëœ PROGRAMì´ ì£¼ì†Œ ìƒíƒœì— ë°˜ì˜ë˜ì§€ ì•Šì•„ì„œâ€ ê°™ì€ í˜ì´ì§€ê°€ ë‹¤ì‹œ ì„ íƒëœ ê²ƒì— ìˆì–´.  

ì˜¬ë ¤ì¤€ address_manager.pyëŠ” ìŠ¤í…ì´ì§€ë§Œ(ì¸í„°í˜ì´ìŠ¤ í˜•íƒœ), ì´ë¥¼ ìƒíƒœ ëª¨ë¸+ë¯¸ë˜ì˜ˆì•½(Future State) ê°œë…ìœ¼ë¡œ ì±„ì›Œ ë„£ìœ¼ë©´ ë¬¸ì œë¥¼ ê¹”ë”íˆ í•´ê²°í•  ìˆ˜ ìˆì–´. ì•„ë˜ì— êµ¬í˜„ ê³„íšì„ ì •ë¦¬í–ˆì–´. (í˜„ nandsim_p3_constraints ê¸°ì¤€)

0) ìš”ì•½ (í•µì‹¬ ë³€í™”)
- Block ë‹¨ìœ„ ìƒíƒœ(Committed / Future) 2ë ˆì¼ë¡œ ê´€ë¦¬
  - committed: ì§€ê¸ˆê¹Œì§€ â€œì‹¤ì œ ì™„ë£Œëœâ€ PROGRAM/ERASE ê²°ê³¼
  - future: ìŠ¤ì¼€ì¤„ ì‹œì ì— ë¯¸ë¦¬ ë°˜ì˜ë˜ëŠ” ìƒíƒœ(ì˜ˆì•½ëœ PROGRAM/ERASE í¬í•¨) â†’ ì¤‘ë³µ PROGRAM ë°©ì§€
- ì˜ˆì•½ ì‹œì (reserve) í›… ê°•í™”
  - PROGRAM/ERASE ì˜ˆì•½ ì‹œ, futureë¥¼ ì¦‰ì‹œ ì—…ë°ì´íŠ¸(í˜ì´ì§€/ERASE ë°˜ì˜)
  - READ ì„ íƒ ì‹œ, committed ê¸°ì¤€ìœ¼ë¡œë§Œ ì½ì„ ìˆ˜ ìˆëŠ” í˜ì´ì§€ë¥¼ ì„ íƒ(ë³´ìˆ˜ì )
- precheck ê°•í™”
  - PROGRAM: ì˜ˆì•½ ì‹œì ì˜ futureê°€ ì •í™•íˆ ë‹¤ìŒ í˜ì´ì§€ì¸ì§€ ê²€ì‚¬
  - READ: ì˜ˆì•½ ì‹œì ì˜ committedì—ì„œ ì‹¤ì œë¡œ ì½ì„ ìˆ˜ ìˆëŠ”ì§€ ê²€ì‚¬
- ë©€í‹°-í”Œë ˆì¸ planì€ futureë¥¼ ë³´ë©° ì •ë ¬, READëŠ” committedë§Œ ì‚¬ìš©
- commit ì‹œì ì— committedë¥¼ futureì— ë§ì¶° ê°±ì‹  (ë™ê¸°í™”)

ì´ë ‡ê²Œ í•˜ë©´ **(d0,p0,b0,pg0)**ë¥¼ í•œ ë²ˆ ì˜ˆì•½í•œ ë’¤ ë‹¤ìŒ ì˜ˆì•½ë¶€í„°ëŠ” ìë™ìœ¼ë¡œ **pg1, pg2â€¦**ë¡œ ë‚˜ì•„ê°€ë©°, ì»¤ë°‹ ì „ì—ë„ ì¤‘ë³µ ì„ íƒì´ ì ˆëŒ€ ì•ˆ ë¨.

1) ë°ì´í„° ëª¨ë¸ (AddressManager v2)

í˜„ì¬ AddressManager ë‚´ë¶€ êµ¬ì¡°ë¥¼ ì•„ë˜ì™€ ê°™ì´ êµì²´/ì¶”ê°€

1.1 ìƒíƒœ í…Œì´ë¸”
- addr_state_committed[(die, plane, block)] : int
  - ì˜ë¯¸: -3=bad, -2=initial(not erased), -1=ERASED, 0..pages-1=â€œë§ˆì§€ë§‰ìœ¼ë¡œ PROGRAMëœ pageâ€
- addr_state_future[(die, plane, block)] : int
  - ì˜ë¯¸: committedë¥¼ ë³µì œ í›„ ì˜ˆì•½ì„ ë°˜ì˜í•œ ê°’ (ì˜ˆì•½ëœ PROGRAM ë°˜ì˜, ì˜ˆì•½ëœ ERASEëŠ” -1ë¡œ ë¦¬ì…‹)
- programmed_committed[(die, plane)] : Set[(block, page)]
  - READ í”Œë˜ë‹ì„ ìœ„í•´ ì»¤ë°‹ëœ í˜ì´ì§€ ì…‹ ìœ ì§€(ê¸°ì¡´ programmed ìœ ì§€/ì´ê´€)
- (ì˜µì…˜) pending_ops_index[(die, plane, block)] : List[(op_kind, page, start, end)]
  - í•„ìš” ì‹œ ì‹œê°„ ì˜ì¡´ ì²´í¬ì— ì‚¬ìš©. ì´ˆê¸°ì—” ìƒëµ ê°€ëŠ¥(â€œREADëŠ” committedë§Œâ€ ì •ì±…ì´ë©´ ë¶ˆí•„ìš”).

1.2 ì»¤ì„œ
- next_pgm_future[(die, plane, block)] = addr_state_future + 1
  - PROGRAM íƒ€ê¹ƒ í˜ì´ì§€ëŠ” ë°˜ë“œì‹œ ì´ ê°’ì´ì–´ì•¼ í•¨
- (ì»¤ë°‹ ì»¤ì„œëŠ” addr_state_committed + 1ë¡œ í•´ì„)

2) API/ë©”ì„œë“œë³„ ì±…ì„ (ìŠ¤í… ì¸í„°í˜ì´ìŠ¤ ì¶©ì¡±)

ì˜¬ë ¤ì¤€ ìŠ¤í… ì‹œê·¸ë‹ˆì²˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ, í˜„ nandsim ë©”ì„œë“œë¥¼ ë§¤ì¹­/í™•ì¥

- available_at(die, plane) -> float
  - ê¸°ì¡´ê³¼ ë™ì¼
- select(kind, die, plane, fanout=1, interleave=True) -> List[Address]
  - READ: programmed_committedì—ì„œ ì„ íƒ(ì»¤ë°‹ëœ í˜ì´ì§€ ë²”ìœ„ ë‚´)
  - PROGRAM: addr_state_future ê¸°ë°˜ìœ¼ë¡œ ë™ì¼ page ì •ë ¬ëœ plane-set ë°˜í™˜
  - ERASE: ë¸”ë¡ ì„ íƒ. (die-wide ì ìœ ëŠ” scopeì—ì„œ ì²˜ë¦¬)
  - SR: ë‹¨ì¼ plane/die
  - ë‚´ë¶€ì ìœ¼ë¡œ plan_multipane(kind, ...) í˜¸ì¶œ (í˜„ì¬ êµ¬í˜„ ë³´ê°•)
- precheck(kind, targets, start_hint, scope) -> bool (í˜„ í•¨ìˆ˜ ìœ ì§€)
  - ì‹œê°„ ê²¹ì¹¨ + ì£¼ì†Œ ê·œì¹™ ê²€ì‚¬
    - PROGRAM: ê° (die,plane,block)ì— ëŒ€í•´ target.page == addr_state_future + 1 ìš”êµ¬
    - READ: target.page <= addr_state_committed ìš”êµ¬ (ì»¤ë°‹ëœ ë²”ìœ„ë§Œ í—ˆìš©)
    - ERASE: ì œí•œ ì—†ìŒ(ë‹¨, die-wideë¡œ ì‹œê°„ ê²¹ì¹¨ì€ ë‹¤ë¥¸ ë ˆì´ì–´ì—ì„œ ì°¨ë‹¨)
- reserve(op, start, end) â†’ ë‘ ë‹¨ê³„ë¡œ ë¶„ë¦¬ ê¶Œì¥
  1. reserve_planescope(op, start, end) (ê¸°ì¡´ ì‹œê°„ ì˜ˆì•½/available ê°±ì‹ )
  2. register_future(op, start, end) (í•µì‹¬: future/ì»¤ì„œ ê°±ì‹ )
    - PROGRAM: addr_state_future = target.page
    - ERASE:   addr_state_future = -1
    - READ/DOUT/SR: ìƒíƒœ ë³€í™” ì—†ìŒ
  - (í˜„ êµ¬ì¡°ì—ëŠ” Scheduler._schedule_operationì—ì„œ addr.reserve_planescopeì™€ addr.register_futureë¥¼ í˜¸ì¶œí•˜ë„ë¡ 1ì¤„ ì¶”ê°€)
- commit(op)
  - PROGRAM: addr_state_committed = max(committed, target.page), programmed_committed.add((block, page))
  - ERASE:   addr_state_committed = -1, programmed_committedì—ì„œ í•´ë‹¹ block í˜ì´ì§€ë“¤ ì œê±°
  - READ/DOUT/SR: ìƒíƒœ ë³€í™” ì—†ìŒ
- observe_states(die, plane, now)
  - pgmable_ratio: plane ë‚´ ë¸”ë¡ ì¤‘ addr_state_future < pages_per_block-1 ë¹„ì¤‘
  - readable_ratio: plane ë‚´ ë¸”ë¡ ì¤‘ addr_state_committed >= 0 ë¹„ì¤‘
  - (ê¸°ì¡´ ë²„í‚· ë¬¸ìì—´ "low/mid/high" ìœ ì§€)

í•µì‹¬ í¬ì¸íŠ¸: ì¤‘ë³µ PROGRAM ë°©ì§€ëŠ” register_futureì—ì„œ í•´ê²°. ì´í›„ ì–´ë–¤ ìŠ¤ì¼€ì¤„ë„ ê°™ì€ í˜ì´ì§€ë¥¼ ë‹¤ì‹œ ê³ ë¥¼ ìˆ˜ ì—†ìŒ.

3) ê¸°ì¡´ ì½”ë“œì— ë“¤ì–´ê°ˆ ë³€ê²½ í¬ì¸íŠ¸
3.1 AddressManager ì´ˆê¸°í™”
- ê¸°ì¡´ programmed/cursorsë¥¼ ëŒ€ì²´/ë³´ê°•
  - addr_state_committed/addr_state_futureë¥¼ -1(ERASED) ë˜ëŠ” **-2(initial)**ë¡œ ì´ˆê¸°í™”
  - programmed_committedëŠ” ë¹ˆ set
  - available, resv, bus_resvëŠ” ê·¸ëŒ€ë¡œ

3.2 plan_multipane(READ/PROGRAM/ERASE) ë³´ê°•
- READ
  - programmed_committed[(die, pl)]ì—ì„œ page ê³µí†µ êµì§‘í•©ì„ êµ¬í•˜ëŠ” í˜„ì¬ ë¡œì§ ìœ ì§€
  - (ì„ íƒëœ block/pageë¡œ Address êµ¬ì„±)
- PROGRAM
  - ê° planeì˜ (die, pl, block)ì— ëŒ€í•´ next_pgm_future == addr_state_future + 1
  - plane-set ê°„ ë™ì¼ pageë¥¼ ì´ ê°’ìœ¼ë¡œ ë¶€ì—¬
  - Address êµ¬ì„± í›„ ë°˜í™˜
- ERASE
  - plane-setë³„ block ì„ íƒ, Address êµ¬ì„±

ì£¼ì˜: PROGRAM ê³„íš ì‹œ **cursorsê°€ ì•„ë‹ˆë¼ addr_state_future**ë¥¼ ì‚¬ìš©í•´ì•¼ í•¨.

3.3 precheck ê°•í™” (ì£¼ì†Œ ê·œì¹™)

```python
def precheck_planescope(kind, targets, start_hint, scope):
    # ... ê¸°ì¡´ ì‹œê°„ ê²¹ì¹¨ ê²€ì‚¬ ...
    for t in targets:
        s_comm = addr_state_committed[(t.die, t.plane, t.block)]
        s_fut  = addr_state_future[(t.die, t.plane, t.block)]
        if kind==OpKind.PROGRAM:
            if t.page is None: return False
            if t.page != s_fut + 1: return False     # ì •í™•íˆ ë‹¤ìŒ í˜ì´ì§€ì—¬ì•¼ í•¨
            if t.page >= pages_per_block: return False
        elif kind==OpKind.READ:
            if t.page is None or s_comm < 0 or t.page > s_comm: return False
        elif kind==OpKind.ERASE:
            pass
        # SR/RESET: ì£¼ì†Œ ì œì•½ ì—†ìŒ
    return True

```

3.4 ì˜ˆì•½ ì‹œì ì˜ future ë°˜ì˜

```python
def register_future(self, op: Operation, start: float, end: float):
    for t in op.targets:
        key = (t.die, t.plane, t.block)
        if op.kind == OpKind.PROGRAM and t.page is not None:
            self.addr_state_future[key] = max(self.addr_state_future[key], t.page)
        elif op.kind == OpKind.ERASE:
            self.addr_state_future[key] = -1

```

- Scheduler._schedule_operationì—ì„œ reserve_planescopeì™€ bus_reserve ë’¤ì— í•œ ì¤„ ì¶”ê°€:
  - self.addr.register_future(op, start, end)

3.5 ì»¤ë°‹ ì‹œì  ë™ê¸°í™”

```python
def commit(self, op: Operation):
    for t in op.targets:
        key = (t.die, t.plane, t.block)
        if op.kind == OpKind.PROGRAM and t.page is not None:
            # ì»¤ë°‹ í™•ì •
            self.addr_state_committed[key] = max(self.addr_state_committed[key], t.page)
            self.programmed_committed[(t.die, t.plane)].add((t.block, t.page))
        elif op.kind == OpKind.ERASE:
            self.addr_state_committed[key] = -1
            self.programmed_committed[(t.die, t.plane)] = {
                pp for pp in self.programmed_committed[(t.die, t.plane)] if pp[0] != t.block
            }

```

4) phase / ì œì•½ê³¼ì˜ ìƒí˜¸ì‘ìš©
- SR / CORE_BUSY / DOUT freeze:
  - ì´ë¯¸ ExclusionManagerë¡œ ì‹œê°„ ë°°íƒ€ì™€ phase_conditional ì œí•œì´ ì ìš©ë˜ì–´ ìˆìŒ â†’ ì£¼ì†Œ ë ˆë²¨ ì œì•½ê³¼ ë…ë¦½
- die-wide CORE_BUSY(PROGRAM/ERASE):
  - ì‹œê°„ ë ˆë²¨ì—ì„œ ëª¨ë“  plane ì˜ˆì•½ì´ ë§‰íˆë¯€ë¡œ ì£¼ì†Œ ë ˆë²¨ ë¡œì§ê³¼ ì¶©ëŒ ì—†ìŒ
- ë©€í‹°-í”Œë ˆì¸ PROGRAM:
  - addr_state_futureê°€ ë™ì¼ pageë¥¼ ë³´ì¥í•˜ëŠ”ì§€ ê²€ì‚¬/ì„ íƒ â†’ ì •í•©ì„± ìœ ì§€

5) í…ŒìŠ¤íŠ¸ ê³„íš (í•„ìˆ˜ ì¼€ì´ìŠ¤)
1. ì¤‘ë³µ PROGRAM ë°©ì§€
  - p0, page0 PROGRAM ì˜ˆì•½ í›„ â†’ ë‹¤ìŒ PROGRAM ì˜ˆì•½ì´ page1ì„ íƒ€ëŠ”ì§€ í™•ì¸
  - ë©€í‹°-í”Œë ˆì¸ ì˜ˆì•½ í›„ì—ë„ ê° planeì—ì„œ ì—°ì† í˜ì´ì§€ê°€ ì„ íƒë˜ëŠ”ì§€ í™•ì¸
2. READ ê°€ì‹œì„±
  - í”„ë¡œê·¸ë¨ ì „ ë¸”ë¡ì€ READ ë¶ˆê°€
  - page0 í”„ë¡œê·¸ë¨ ì»¤ë°‹ ì „ READ(page0) ì˜ˆì•½ ì‹œë„ â†’ ê±°ì ˆ(committedë§Œ í—ˆìš©)
  - ì»¤ë°‹ í›„ READ(page0) â†’ í—ˆìš©
3. ERASE ë°˜ì˜
  - blockì— page0..2 ì»¤ë°‹ í›„ ERASE ì˜ˆì•½ â†’ ì˜ˆì•½ ì§í›„ future=-1
  - ERASE ì»¤ë°‹ ì „ PROGRAM ì˜ˆì•½ ì‹œë„: ì‹œê°„ìƒ ê²¹ì¹˜ì§€ ì•Šë”ë¼ë„ precheckì—ì„œ ë‹¤ìŒ í˜ì´ì§€ ê·œì¹™ì— ë”°ë¼ ì •ìƒ ìˆ˜í–‰(ERASE ì´í›„ëŠ” page0ë¡œ ì‹œì‘)
4. ë©€í‹°-í”Œë ˆì¸ ì •ë ¬
  - PROGRAM: plane-set ëª¨ë‘ next_pgm_future ë™ì¼ì„± ê²€ì‚¬
  - READ: plane-setì— ëŒ€í•´ ì»¤ë°‹ í˜ì´ì§€ êµì§‘í•©ìœ¼ë¡œ page ì„ íƒ
5. ì„±ëŠ¥/ìˆ˜ë½ë¥  íšŒê·€
  - random seed ê³ ì •ì—ì„œ accept ratio ê³¼ë„ í•˜ë½ì´ ì—†ëŠ”ì§€ í™•ì¸

6) ë³€ê²½ ìš°ì„ ìˆœìœ„
- P0 (í•«í”½ìŠ¤)
  1. addr_state_committed/future ë„ì… ë° ì´ˆê¸°í™”
  2. plan_multipane(PROGRAM)ì´ future ê¸°ë°˜ìœ¼ë¡œ íƒ€ê¹ƒ page ì‚°ì¶œ
  3. register_future(op) í˜¸ì¶œ ì¶”ê°€(ìŠ¤ì¼€ì¤„ ì§í›„)
  4. precheckì— PROGRAM/READ ì£¼ì†Œ ê·œì¹™ ì¶”ê°€
- P1

5) commit()ì—ì„œ committed/programmed_committed ë™ê¸°í™”

6) READëŠ” programmed_committed(ì»¤ë°‹)ì—ì„œë§Œ ì„ íƒí•˜ë„ë¡ ê³ ì •
- P2

7) observe_states ë²„í‚· ì •í™•í™”(planeë³„ pgmable/readable ê³„ì‚°)

8) (ì˜µì…˜) pending_ops_indexë¡œ ì‹œê°„ì˜ì¡´ READ í™•ëŒ€(â€œì‹œì‘ ì‹œì  ì´ì „ì— ì»¤ë°‹ë  í˜ì´ì§€â€ í—ˆìš©)

7) ë¦¬ìŠ¤í¬ & ì™„í™”
- ìŠ¤ì¼€ì¤„-ì»¤ë°‹ ì‹œì°¨ì— ë”°ë¥¸ ê°€ì‹œì„±
  - READê°€ â€œì˜ˆì•½ëœ PROGRAM ê²°ê³¼â€ë¥¼ ì•ì„œ ì½ìœ¼ë ¤ëŠ” ì¼€ì´ìŠ¤ë¥¼ ë§‰ê¸° ìœ„í•´, P0/P1ì—ì„œëŠ” committedë§Œ í—ˆìš©.
  - ì¶”í›„ P2ì—ì„œ pending_ops_indexë¥¼ í†µí•´ â€œread start ì´ì „ì— ì»¤ë°‹ë  PROGRAMâ€ë§Œ ê°€ì‹œí™”í•˜ëŠ” í™•ì¥ ê³ ë ¤.
- ìƒíƒœ ë¶ˆì¼ì¹˜ ìœ„í—˜
  - ì˜ˆì•½ì—ì„œ futureë¥¼ ê°±ì‹ , ì»¤ë°‹ì—ì„œ committedë¥¼ ê°±ì‹ í•˜ë¯€ë¡œ ë‘ ë ˆì¼ì´ ì–´ê¸‹ë‚  ìˆ˜ ìˆìŒ.
  - ë¶ˆë³€ì¡°ê±´: í•­ìƒ addr_state_committed â‰¤ addr_state_future ìœ ì§€. ì´ ì¡°ê±´ ê²€ì¦ assertion ì¶”ê°€.
- ë©€í‹°-í”Œë ˆì¸/ERASEì™€ì˜ ì—£ì§€ ì¼€ì´ìŠ¤
  - die-wide CORE_BUSYëŠ” ì‹œê°„/ìì› ë ˆë²¨ì—ì„œ ê²©ë¦¬ë˜ë¯€ë¡œ ì£¼ì†Œ ì¶©ëŒ ë‚®ìŒ.
  - ERASE ì˜ˆì•½ í›„ PROGRAM ì˜ˆì•½ì´ ê°™ì€ blockì— ë“¤ì–´ê°€ëŠ” ê²½ìš° â†’ future=-1ì´ë¯€ë¡œ PROGRAMì€ page0ë¶€í„° ìë™ ì¬ì‹œì‘(ì˜ë„ëŒ€ë¡œ).

8) nandsimì— ì‹¤ì œë¡œ ë„£ì„ ë³€ê²½ì (ê°„ë‹¨ Diff ê°€ì´ë“œ)
- AddressManager.__init__
  - addr_state_committed, addr_state_future, programmed_committed ì¶”ê°€
- AddressManager.plan_multipane
  - PROGRAM: ì»¤ì„œ ì¶œì²˜ë¥¼ cursorsâ†’addr_state_future+1ë¡œ ë³€ê²½
  - READ: programmed_committed ê¸°ë°˜ page êµì§‘í•©
- AddressManager.precheck_planescope
  - PROGRAM/READ ì£¼ì†Œ ê·œì¹™ ì¶”ê°€
- AddressManager.register_future (ì‹ ê·œ)
  - PROGRAM/ERASE ì˜ˆì•½ ë°˜ì˜
- AddressManager.commit
  - committed/future ë™ê¸°í™” + programmed_committed ì—…ë°ì´íŠ¸
- Scheduler._schedule_operation
  - reserve_planescope/bus_reserve ë’¤ì— addr.register_future(op, start, end) ì¶”ê°€

ì›í•˜ë©´ ìœ„ ê³„íšì„ ë°”ë¡œ ì ìš©í•œ íŒ¨ì¹˜ ì½”ë“œë„ ì œê³µí•  ìˆ˜ ìˆì–´. ìš°ì„  ì´ ê³„íšìœ¼ë¡œ ì§„í–‰í•´ë„ ë ì§€ í™•ì¸í•´ì¤˜.

## ğŸ‘¤ User

ì¢‹ì•„. ì§„í–‰í•´

## ğŸ¤– Assistant

ì¢‹ì•„. ì¤‘ë³µ PROGRAM(page=0) ì¬ì„ íƒ ë²„ê·¸ë¥¼ ê·¼ë³¸ì ìœ¼ë¡œ ë§‰ê³ , READ ê°€ì‹œì„±(â€œí”„ë¡œê·¸ë¨ëœ í˜ì´ì§€ë§Œ ì½ê¸°â€)ì„ ë§Œì¡±í•˜ë„ë¡ AddressManagerë¥¼ ìƒíƒœ 2ë ˆì¼(Committed/Future) êµ¬ì¡°ë¡œ ë°”ê¾¼ í†µí•© íŒ¨ì¹˜ë¥¼ ë°”ë¡œ ì œê³µí• ê²Œ.
ì•„ë˜ íŒŒì¼ í•˜ë‚˜ë¡œ êµì²´í•˜ë©´ ë™ì‘í•´. ì£¼ìš” ë³€ê²½ì ì€ ë©”ì‹œì§€ ë§ˆì§€ë§‰ì— ìš”ì•½í–ˆì–´.

ì™„ì „ êµì²´ íŒŒì¼ â€” nandsim_p4_addrstate.py

```python
# nandsim_p4_addrstate.py
# - AddressManager v2: per-(die,plane,block) state with committed/future rails
# - PROGRAM duplicates prevented via future reservation (register_future)
# - READ visibility: only committed pages are readable
# - Multi-plane planner updated to use future/committed rails
# - Keeps P3 features: SR, phase constraints, DOUT global freeze, alias-based MUL/SIN, DIE_WIDE CORE_BUSY, Bus gating
# Stdlib only.

from __future__ import annotations
import heapq, random
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple, Set

SIM_RES_US = 0.01
def quantize(t: float) -> float:
    return round(t / SIM_RES_US) * SIM_RES_US

# ---------------------------- Config ----------------------------
CFG = {
    "rng_seed": 12345,
    "policy": {
        "queue_refill_period_us": 3.0,
        "run_until_us": 180.0,
        "planner_max_tries": 8,
    },
    # phase-conditional: í›…(OP.STATE(.POS)) â†’ ë‹¤ìŒ op ë¶„í¬
    "phase_conditional": {
        "READ.ISSUE":                {"MUL_PROGRAM": 0.15, "SIN_PROGRAM": 0.10, "SIN_READ": 0.35, "MUL_READ": 0.25, "SIN_ERASE": 0.15, "SR": 0.00},
        "READ.CORE_BUSY.START":      {"MUL_READ": 0.50, "SIN_READ": 0.20, "SIN_PROGRAM": 0.10, "SIN_ERASE": 0.10, "SR": 0.10},
        "READ.DATA_OUT.START":       {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.15, "SIN_ERASE": 0.10, "SR": 0.05},

        "PROGRAM.ISSUE":             {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.15, "SIN_ERASE": 0.10, "SR": 0.05},
        "PROGRAM.CORE_BUSY":         {"SR": 1.0},   # CORE_BUSY ë™ì•ˆ SRë§Œ í—ˆìš©
        "PROGRAM.CORE_BUSY.END":     {"SIN_READ": 0.55, "MUL_READ": 0.25, "SIN_PROGRAM": 0.10, "SIN_ERASE": 0.05, "SR": 0.05},

        "ERASE.ISSUE":               {"SIN_PROGRAM": 0.40, "MUL_PROGRAM": 0.20, "SIN_READ": 0.25, "MUL_READ": 0.10, "SR": 0.05},
        "ERASE.CORE_BUSY":           {"SR": 1.0},   # CORE_BUSY ë™ì•ˆ SRë§Œ í—ˆìš©
        "ERASE.CORE_BUSY.END":       {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.10, "MUL_PROGRAM": 0.05, "SR": 0.15},

        "MUL_READ.CORE_BUSY":        {"SR": 1.0},   # ë©€í‹°ë¦¬ë“œ CORE_BUSY ë™ì•ˆ SRë§Œ í—ˆìš©
        "SIN_READ.CORE_BUSY":        {"SIN_READ": 0.6, "SR": 0.4},  # ë‹¨ì¼ë¦¬ë“œ CORE_BUSY ë™ì•ˆ MUL/PGM/ERASE ê¸ˆì§€

        "DEFAULT":                   {"SIN_READ": 0.55, "SIN_PROGRAM": 0.25, "SIN_ERASE": 0.10, "SR": 0.10},
    },

    "weights": {  # ë°±ì˜¤í”„ìš©
        "base": {"host": {"READ": 0.70, "PROGRAM": 0.15, "ERASE": 0.05, "SR": 0.10, "RESET": 0.00, "DOUT": 0.00}},
        "g_state": {"pgmable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.8},
                    "readable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.9}},
        "g_local": {"plane_busy_frac": {"low": 1.2, "mid": 1.0, "high": 0.9}},
        "g_phase": {
            "READ": {"START_NEAR": 1.2, "MID_NEAR": 0.9, "END_NEAR": 1.2},
            "PROGRAM": {"START_NEAR": 1.1, "MID_NEAR": 1.0, "END_NEAR": 0.9},
            "ERASE": {"START_NEAR": 0.9, "MID_NEAR": 1.1, "END_NEAR": 1.1},
            "SR": {"START_NEAR": 1.1, "MID_NEAR": 1.1, "END_NEAR": 1.1},
        },
    },

    "selection": {
        "defaults": {
            "READ":    {"fanout": 1, "interleave": True},
            "PROGRAM": {"fanout": 2, "interleave": True},
            "ERASE":   {"fanout": 2, "interleave": False},
            "SR":      {"fanout": 1, "interleave": True},
        },
        "phase_overrides": {
            "READ.CORE_BUSY.START": {"fanout": 4, "interleave": True},
        }
    },

    "op_specs": {
        "READ": {
            "scope": "PLANE_SET",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 8.0, "std": 1.5, "min": 2.0}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "normal", "mean": 2.0, "std": 0.4, "min": 0.5}},
            ],
        },
        "PROGRAM": {
            "scope": "DIE_WIDE",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 20.0, "std": 3.0, "min": 8.0}},
            ],
        },
        "ERASE": {
            "scope": "DIE_WIDE",
            "page_equal_required": False,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 40.0, "std": 5.0, "min": 15.0}},
            ],
        },
        "DOUT": {
            "scope": "NONE",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": False, "dist": {"kind": "fixed",  "value": 0.2}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "normal", "mean": 1.0, "std": 0.2, "min": 0.2}},
            ],
        },
        "SR": {
            "scope": "NONE",
            "page_equal_required": False,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.2}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "fixed",  "value": 0.3}},
            ],
        },
    },

    # ëŸ°íƒ€ì„ ë°°íƒ€ ê·œì¹™(ìŠ¤ì¼€ì¤„ ì‹œ ìœˆë„ìš° ë“±ë¡ â†’ ì œì•ˆ ì‹œ í—ˆìš© ê²€ì‚¬)
    "constraints": {
        "exclusions": [
            {"when": {"op": "PROGRAM", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},
            {"when": {"op": "ERASE", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},
            {"when": {"op": "READ", "alias": "MUL", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},
            {"when": {"op": "READ", "alias": "SIN", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["ALIAS:SIN_READ", "ALIAS:MUL_READ", "BASE:PROGRAM", "BASE:ERASE"]}, # SINì€ READ í—ˆìš©(í•œì •); runtime checkì—ì„œ í† í°ë§¤ì¹­ ì²˜ë¦¬
            {"when": {"op": "DOUT", "states": ["*"]}, "scope": "GLOBAL", "blocks": ["ANY"]},
        ]
    },

    "obligations": [
        {
            "issuer": "READ",
            "require": "DOUT",
            "window_us": {"kind": "normal", "mean": 6.0, "std": 1.5, "min": 1.0},
            "priority_boost": {"start_us_before_deadline": 2.5, "boost_factor": 2.0, "hard_slot": True},
        }
    ],

    "topology": {"dies": 1, "planes_per_die": 4, "blocks_per_plane": 8, "pages_per_block": 16},

    "export": {"tu_us": 0.01, "nop_symbol": "NOP", "wait_as_nop": True, "drift_correction": True},

    # AddressManager ì´ˆê¸° block ìƒíƒœ (-1 = ERASED; -2 = initial)
    "address_init_state": -1
}

# ---------------------------- Alias mapping ----------------------------
OP_ALIAS = {
    "SIN_READ":    {"base": "READ",    "fanout": ("eq", 1)},
    "MUL_READ":    {"base": "READ",    "fanout": ("ge", 2)},
    "SIN_PROGRAM": {"base": "PROGRAM", "fanout": ("eq", 1)},
    "MUL_PROGRAM": {"base": "PROGRAM", "fanout": ("ge", 2)},
    "SIN_ERASE":   {"base": "ERASE",   "fanout": ("eq", 1)},
    "MUL_ERASE":   {"base": "ERASE",   "fanout": ("ge", 2)},
}

# ---------------------------- Models ----------------------------
class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

class Scope(Enum):
    NONE=0; PLANE_SET=1; DIE_WIDE=2

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float
    bus: bool = False

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)

# ---------------------------- Utils ----------------------------
def sample_dist(d: Dict[str, Any]) -> float:
    k = d["kind"]
    if k == "fixed": return float(d["value"])
    if k == "normal":
        m, s, mn = d["mean"], d["std"], d.get("min", 0.0)
        v = random.gauss(m, s); return max(v, mn)
    if k == "exp": return random.expovariate(d["lambda"])
    raise ValueError(f"unknown dist kind: {k}")

def parse_hook_key(label: str):
    parts = label.split(".")
    if len(parts) >= 3: return parts[0], parts[1], parts[2]
    if len(parts) == 2: return parts[0], parts[1], None
    return None, None, None

def get_phase_dist(cfg: Dict[str,Any], hook_label: str):
    op, state, pos = parse_hook_key(hook_label)
    pc = cfg.get("phase_conditional", {})
    keys=[]
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    keys.append("DEFAULT")
    for key in keys:
        dist = pc.get(key)
        if dist and sum(dist.values())>0: return dist, key
    return None, None

def roulette_pick(dist: Dict[str, float], allow: set) -> Optional[str]:
    items=[(n,p) for n,p in dist.items() if n in allow and p>0]
    if not items: return None
    tot=sum(p for _,p in items); r=random.random()*tot; acc=0.0; pick=items[-1][0]
    for n,p in items:
        acc+=p
        if r<=acc: pick=n; break
    return pick

def resolve_alias(name: str) -> Tuple[str, Optional[Tuple[str,int]]]:
    if name in OP_ALIAS: return OP_ALIAS[name]["base"], OP_ALIAS[name]["fanout"]
    return name, None

# ---------------------------- Builders ----------------------------
def build_operation(kind: OpKind, cfg_op: Dict[str, Any], targets: List[Address]) -> Operation:
    states=[]
    for s in cfg_op["states"]:
        states.append(StateSeg(name=s["name"], dur_us=sample_dist(s["dist"]), bus=bool(s.get("bus", False))))
    return Operation(kind=kind, targets=targets, states=states)

def get_op_duration(op: Operation) -> float:
    return sum(seg.dur_us for seg in op.states)

# ---------------------------- Address & Bus Managers ----------------------------
class AddressManager:
    """
    v2 ìƒíƒœ ëª¨ë¸:
    - addr_state_committed[(d,p,b)] : int  # ë§ˆì§€ë§‰ ì»¤ë°‹ëœ program page (-1=ERASED, -2=initial)
    - addr_state_future[(d,p,b)]    : int  # ì˜ˆì•½ ë°˜ì˜ëœ ë¯¸ë˜ ìƒíƒœ (commit ì´ì „ì— ê°±ì‹ )
    - programmed_committed[(d,p)] : Set[(block,page)]  # READ ê°€ì‹œì„± ì†ŒìŠ¤
    - write_head[(d,p)] : int  # programì— ì‚¬ìš©í•  ê¸°ë³¸ block í›„ë³´
    """
    def __init__(self, cfg: Dict[str, Any]):
        topo=cfg["topology"]; self.cfg=cfg
        self.dies=topo["dies"]; self.planes=topo["planes_per_die"]
        self.pages_per_block=topo["pages_per_block"]; self.blocks_per_plane=topo["blocks_per_plane"]
        self.available={(0,p):0.0 for p in range(self.planes)}          # per-plane time availability
        self.resv={(0,p):[] for p in range(self.planes)}                # (start,end,block)
        self.bus_resv: List[Tuple[float,float]] = []

        init_state = int(cfg.get("address_init_state", -1))             # default ERASED
        # state rails
        self.addr_state_committed: Dict[Tuple[int,int,int], int] = {}
        self.addr_state_future:    Dict[Tuple[int,int,int], int] = {}
        self.programmed_committed: Dict[Tuple[int,int], Set[Tuple[int,int]]] = {(0,p): set() for p in range(self.planes)}
        self.write_head: Dict[Tuple[int,int], int] = {}

        for p in range(self.planes):
            self.write_head[(0,p)] = 0
            for b in range(self.blocks_per_plane):
                key=(0,p,b)
                self.addr_state_committed[key] = init_state
                self.addr_state_future[key]    = init_state

    # ---------- observation ----------
    def available_at(self, die:int, plane:int)->float: return self.available[(die,plane)]

    def earliest_start_for_scope(self, die:int, scope: Scope, plane_set: Optional[List[int]]=None)->float:
        if scope==Scope.DIE_WIDE: planes=list(range(self.planes))
        elif scope==Scope.PLANE_SET and plane_set is not None: planes=plane_set
        else: planes=[plane_set[0]] if plane_set else [0]
        return max(self.available[(die,p)] for p in planes)

    def observe_states(self, die:int, plane:int, now_us: float):
        # plane-level ratios for policy: pgmable/readable
        pgmable_blocks=0; readable_blocks=0
        for b in range(self.blocks_per_plane):
            fut=self.addr_state_future[(die,plane,b)]
            com=self.addr_state_committed[(die,plane,b)]
            if fut < self.pages_per_block-1: pgmable_blocks += 1
            if com >= 0: readable_blocks += 1
        total=self.blocks_per_plane or 1
        def bucket(x): 
            r=x/total
            return "low" if r<0.34 else ("mid" if r<0.67 else "high")
        pgmable_ratio=bucket(pgmable_blocks)
        readable_ratio=bucket(readable_blocks)
        plane_busy_frac="high" if self.available_at(die,plane)>now_us else "low"
        return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls":"host"},
                {"plane_busy_frac": plane_busy_frac})

    # ---------- bus segments (relative offsets) ----------
    def bus_segments_for_op(self, op: Operation)->List[Tuple[float,float]]:
        segs=[]; t=0.0
        for s in op.states:
            if s.bus: segs.append((t, t+s.dur_us))
            t+=s.dur_us
        return segs

    def bus_precheck(self, start_hint: float, segs: List[Tuple[float,float]])->bool:
        for (off0,off1) in segs:
            a0, a1 = quantize(start_hint+off0), quantize(start_hint+off1)
            for (s,e) in self.bus_resv:
                if not (a1<=s or e<=a0): return False
        return True

    def bus_reserve(self, start_time: float, segs: List[Tuple[float,float]]):
        for (off0,off1) in segs:
            self.bus_resv.append((quantize(start_time+off0), quantize(start_time+off1)))

    # ---------- helpers for PROGRAM planning ----------
    def _next_page_in_block_future(self, die:int, plane:int, block:int)->int:
        """returns next page to program in this block (>=0), or pages_per_block if full"""
        last = self.addr_state_future[(die,plane,block)]
        return (last + 1) if last < self.pages_per_block-1 else self.pages_per_block

    def _find_block_for_page_future(self, die:int, plane:int, target_page:int)->Optional[int]:
        """find a block whose next page equals target_page (i.e., future == target_page-1)"""
        for b in range(self.blocks_per_plane):
            if self._next_page_in_block_future(die, plane, b) == target_page:
                return b
        return None

    def _first_erased_block(self, die:int, plane:int)->Optional[int]:
        for b in range(self.blocks_per_plane):
            if self.addr_state_future[(die,plane,b)] == -1:
                return b
        return None

    # ---------- planner (non-greedy; uses future/committed rails) ----------
    def _random_plane_sets(self, fanout:int, tries:int, start_plane:int)->List[List[int]]:
        P=list(range(self.planes)); out=[]
        for _ in range(tries):
            cand=set(random.sample(P, min(fanout,len(P))))
            if start_plane not in cand and random.random()<0.6:
                if len(cand)>0: cand.pop()
                cand.add(start_plane)
            if len(cand)==fanout:
                key=tuple(sorted(cand))
                if key not in out: out.append(key)
        return [list(ps) for ps in dict.fromkeys(out)]

    def _committed_pages(self, die:int, plane:int)->Set[int]:
        return {p for (b,p) in self.programmed_committed[(die,plane)]}

    def plan_multipane(self, kind: OpKind, die:int, start_plane:int, desired_fanout:int, interleave:bool)\
            -> Optional[Tuple[List[Address], List[int], Scope]]:
        if desired_fanout<1: desired_fanout=1
        tries=self.cfg["policy"]["planner_max_tries"]
        # degrade loop: try fanout f from desired->1
        for f in range(desired_fanout, 0, -1):
            for plane_set in self._random_plane_sets(f, tries, start_plane):
                if kind==OpKind.READ:
                    # Intersection of committed pages across planes
                    commons=None
                    for pl in plane_set:
                        pages=self._committed_pages(die,pl)
                        commons=pages if commons is None else (commons & pages)
                        if not commons: break
                    if not commons: 
                        continue
                    page=random.choice(sorted(list(commons)))
                    targets=[]
                    for pl in plane_set:
                        # pick any block that contains (block,page)
                        blks=[b for (b,p) in self.programmed_committed[(die,pl)] if p==page]
                        if not blks: 
                            targets=[]; break
                        targets.append(Address(die,pl,blks[0],page))
                    if not targets: 
                        continue
                    scope=Scope.PLANE_SET
                    return targets, plane_set, scope

                elif kind==OpKind.PROGRAM:
                    # try to align next page across planes.
                    # candidate pages: (a) most common next-page of write_head blocks, (b) 0 if all have erased blocks
                    nxts=[]
                    for pl in plane_set:
                        b_head=self.write_head[(die,pl)]
                        nxt = self._next_page_in_block_future(die,pl,b_head)
                        if nxt>=self.pages_per_block: nxt = None  # head block full
                        nxts.append(nxt)
                    candidates=[]
                    # (a) mode among non-None
                    vals=[x for x in nxts if x is not None]
                    if vals:
                        # simple mode by frequency
                        freq={}
                        for v in vals: freq[v]=freq.get(v,0)+1
                        mode_val=max(freq.items(), key=lambda x:x[1])[0]
                        candidates.append(mode_val)
                    # (b) zero if all planes can find erased block
                    if all(self._first_erased_block(die,pl) is not None for pl in plane_set):
                        if 0 not in candidates: candidates.append(0)
                    if not candidates: 
                        continue

                    chosen=None
                    for page in candidates:
                        tlist=[]
                        ok=True
                        for pl in plane_set:
                            # if head matches target page, use it; else find any block with that next page
                            b_head=self.write_head[(die,pl)]
                            if self._next_page_in_block_future(die,pl,b_head)==page:
                                b=b_head
                            else:
                                b=self._find_block_for_page_future(die,pl,page)
                                if b is None:
                                    ok=False; break
                            tlist.append(Address(die,pl,b,page))
                        if ok:
                            chosen=(tlist, page); break
                    if not chosen:
                        continue
                    targets, _ = chosen
                    scope=Scope.DIE_WIDE
                    return targets, plane_set, scope

                elif kind==OpKind.ERASE:
                    targets=[]
                    for pl in plane_set:
                        # erase write_head block preferentially if not erased
                        b=self.write_head[(die,pl)]
                        # pick a non-erased block if possible, else any block
                        if self.addr_state_future[(die,pl,b)] == -1:
                            # find some non-erased block
                            found=None
                            for bb in range(self.blocks_per_plane):
                                if self.addr_state_future[(die,pl,bb)] >= 0: 
                                    found=bb; break
                            if found is not None: b=found
                        targets.append(Address(die,pl,b,None))
                    scope=Scope.DIE_WIDE
                    return targets, plane_set, scope

                elif kind==OpKind.SR:
                    return [Address(die,plane_set[0],0,None)], plane_set[:1], Scope.NONE

        return None

    # ---------- precheck / reserve / future registration / commit ----------
    def precheck_planescope(self, kind: OpKind, targets: List[Address], start_hint: float, scope: Scope)->bool:
        start_hint=quantize(start_hint); end_hint=start_hint
        die=targets[0].die
        if scope==Scope.DIE_WIDE: planes={(die,p) for p in range(self.planes)}
        elif scope==Scope.PLANE_SET: planes={(t.die,t.plane) for t in targets}
        else: planes={(targets[0].die, targets[0].plane)}
        # time overlap
        for (d,p) in planes:
            for (s,e,_) in self.resv[(d,p)]:
                if not (end_hint<=s or e<=start_hint): 
                    return False
        # address rules
        for t in targets:
            com=self.addr_state_committed[(t.die,t.plane,t.block)]
            fut=self.addr_state_future[(t.die,t.plane,t.block)]
            if kind==OpKind.PROGRAM:
                if t.page is None: return False
                # must be exactly next page in FUTURE rail
                if t.page != fut + 1: return False
                if t.page >= self.pages_per_block: return False
            elif kind==OpKind.READ:
                if t.page is None or com < 0 or t.page > com: return False
            elif kind==OpKind.ERASE:
                pass
        return True

    def reserve_planescope(self, op: Operation, start: float, end: float):
        die=op.targets[0].die; start=quantize(start); end=quantize(end)
        if op.meta.get("scope")=="DIE_WIDE":
            planes=[(die,p) for p in range(self.planes)]
        elif op.meta.get("scope")=="PLANE_SET":
            planes=[(t.die,t.plane) for t in op.targets]
        else:
            planes=[(op.targets[0].die, op.targets[0].plane)]
        for (d,p) in planes:
            self.available[(d,p)]=max(self.available[(d,p)], end)
            self.resv[(d,p)].append((start,end,None))

    def register_future(self, op: Operation, start: float, end: float):
        """ì˜ˆì•½ ì„±ê³µ ì§í›„ í˜¸ì¶œ: future railì„ ì¦‰ì‹œ ê°±ì‹ í•˜ì—¬ ì¤‘ë³µ PROGRAM ë°©ì§€"""
        for t in op.targets:
            key=(t.die,t.plane,t.block)
            if op.kind==OpKind.PROGRAM and t.page is not None:
                # advance future
                self.addr_state_future[key] = max(self.addr_state_future[key], t.page)
                # update write head if block is full
                nextp = self._next_page_in_block_future(t.die,t.plane,t.block)
                if nextp >= self.pages_per_block:
                    # move write head to an erased block if available
                    er = self._first_erased_block(t.die,t.plane)
                    if er is not None:
                        self.write_head[(t.die,t.plane)] = er
            elif op.kind==OpKind.ERASE:
                # reset to ERASED
                self.addr_state_future[key] = -1
                # prefer erased block as write head
                self.write_head[(t.die,t.plane)] = t.block

    def commit(self, op: Operation):
        for t in op.targets:
            key=(t.die,t.plane,t.block)
            if op.kind==OpKind.PROGRAM and t.page is not None:
                self.addr_state_committed[key] = max(self.addr_state_committed[key], t.page)
                self.programmed_committed[(t.die,t.plane)].add((t.block,t.page))
            elif op.kind==OpKind.ERASE:
                self.addr_state_committed[key] = -1
                # remove all committed pages of this block
                self.programmed_committed[(t.die,t.plane)] = {
                    pp for pp in self.programmed_committed[(t.die,t.plane)] if pp[0] != t.block
                }
        # invariant: committed <= future
        # (lightweight check; can be turned into assert in debug)
        # for k in self.addr_state_committed:
        #     if self.addr_state_committed[k] > self.addr_state_future[k]:
        #         raise RuntimeError("state rail violated")

# ---------------------------- Exclusion Manager (runtime blocking) ----------------------------
@dataclass
class ExclWindow:
    start: float; end: float
    scope: str
    die: Optional[int]
    tokens: Set[str]        # {"ANY"}, {"BASE:READ"}, {"ALIAS:MUL_READ"} ...

class ExclusionManager:
    def __init__(self, cfg: Dict[str,Any]):
        self.cfg = cfg
        self.global_windows: List[ExclWindow] = []
        self.die_windows: Dict[int, List[ExclWindow]] = {}

    def _state_windows(self, op: Operation, start: float, states: List[str]) -> List[Tuple[float,float]]:
        wins=[]; t=start
        segs=[]
        for s in op.states:
            segs.append((s.name, t, t+s.dur_us)); t+=s.dur_us
        if states==["*"]:
            return [(segs[0][1], segs[-1][2])]
        want=set(states)
        for name, s0, s1 in segs:
            if name in want: wins.append((s0,s1))
        return wins

    def _token_blocks(self, tok: str, op: Operation) -> bool:
        if tok=="ANY": return True
        if tok.startswith("BASE:"):
            base=tok.split(":")[1]
            return op.kind.name==base
        if tok.startswith("ALIAS:"):
            alias=tok.split(":")[1]
            if alias=="MUL_READ": return (op.kind==OpKind.READ and op.meta.get("arity",1)>1)
            if alias=="SIN_READ": return (op.kind==OpKind.READ and op.meta.get("arity",1)==1)
        return False

    def allowed(self, op: Operation, start: float, end: float) -> bool:
        for w in self.global_windows:
            if not (end<=w.start or w.end<=start):
                if any(self._token_blocks(tok, op) for tok in w.tokens):
                    return False
        die=op.targets[0].die
        for w in self.die_windows.get(die, []):
            if not (end<=w.start or w.end<=start):
                if any(self._token_blocks(tok, op) for tok in w.tokens):
                    return False
        return True

    def register(self, op: Operation, start: float):
        rules = self.cfg.get("constraints",{}).get("exclusions",[])
        die = op.targets[0].die
        for r in rules:
            when=r["when"]; if_op=when.get("op")
            if if_op != op.kind.name:
                if not (op.kind==OpKind.READ and if_op=="READ"): 
                    continue
            alias_need = when.get("alias")
            if alias_need=="MUL" and not (op.meta.get("arity",1)>1): 
                continue
            if alias_need=="SIN" and not (op.meta.get("arity",1)==1): 
                continue
            states = when.get("states", ["*"])
            windows = self._state_windows(op, start, states)
            scope=r.get("scope","GLOBAL"); tokens=set(r.get("blocks",[]))
            for (s0,s1) in windows:
                w=ExclWindow(start=quantize(s0), end=quantize(s1), scope=scope, die=(die if scope=="DIE" else None), tokens=tokens)
                if scope=="GLOBAL":
                    self.global_windows.append(w)
                else:
                    self.die_windows.setdefault(die,[]).append(w)

# ---------------------------- Obligation Manager ----------------------------
@dataclass(order=True)
class _ObHeapItem:
    deadline_us: float
    seq: int
    ob: "Obligation" = field(compare=False)

@dataclass
class Obligation:
    require: OpKind
    targets: List[Address]
    deadline_us: float
    boost_factor: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg_list: List[Dict[str,Any]]):
        self.specs = cfg_list
        self.heap: List[_ObHeapItem] = []; self._seq=0

    def on_commit(self, op: Operation, now_us: float):
        for spec in self.specs:
            if spec["issuer"] == op.kind.name:
                dt=sample_dist(spec["window_us"])
                ob=Obligation(require=OpKind[spec["require"]], targets=op.targets,
                              deadline_us=quantize(now_us+dt),
                              boost_factor=spec["priority_boost"]["boost_factor"],
                              hard_slot=spec["priority_boost"].get("hard_slot", False))
                heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=self._seq, ob=ob))
                self._seq+=1
                first=op.targets[0]
                print(f"[{now_us:7.2f} us] OBLIG  created: {op.kind.name} -> {ob.require.name} by {ob.deadline_us:7.2f} us, target(d{first.die},p{first.plane})")

    def pop_urgent(self, now_us: float, die:int, plane:int, horizon_us: float, earliest_start: float) -> Optional[Obligation]:
        if not self.heap: return None
        kept=[]; chosen=None
        now_us=quantize(now_us); earliest_start=quantize(earliest_start)
        while self.heap and not chosen:
            item=heapq.heappop(self.heap); ob=item.ob
            plane_list={a.plane for a in ob.targets}
            same_die=(ob.targets[0].die==die); same_plane=(plane in plane_list)
            in_horizon=((ob.deadline_us-now_us)<=max(horizon_us,0.0)) or ob.hard_slot
            feasible=(earliest_start<=ob.deadline_us)
            if same_die and same_plane and in_horizon and feasible: chosen=ob; break
            kept.append(item)
        for it in kept: heapq.heappush(self.heap, it)
        return chosen

# ---------------------------- Policy Engine ----------------------------
class PolicyEngine:
    def __init__(self, cfg, addr: AddressManager, obl: ObligationManager, excl: ExclusionManager):
        self.cfg=cfg; self.addr=addr; self.obl=obl; self.excl=excl
        self.stats={"alias_degrade":0}

    def _score(self, op_name: str, phase_label: str, g: Dict[str,str], l: Dict[str,str]) -> float:
        w=self.cfg["weights"]["base"]["host"].get(op_name,0.0)
        w*=self.cfg["weights"]["g_state"]["pgmable_ratio"].get(g["pgmable_ratio"],1.0)
        w*=self.cfg["weights"]["g_state"]["readable_ratio"].get(g["readable_ratio"],1.0)
        w*=self.cfg["weights"]["g_local"]["plane_busy_frac"].get(l["plane_busy_frac"],1.0)
        near="MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w*=self.cfg["weights"]["g_phase"].get(op_name,{}).get(near,1.0)
        return w

    def _fanout_from_alias(self, base_name: str, alias_constraint: Optional[Tuple[str,int]], hook_label: str)->Tuple[int,bool]:
        fanout, interleave = get_phase_selection_override(self.cfg, hook_label, base_name)
        if alias_constraint:
            mode,val=alias_constraint
            if mode=="eq": fanout=val
            elif mode=="ge": fanout=max(fanout,val)
        return max(1,fanout), interleave

    def _exclusion_ok(self, op: Operation, die:int, plane_set: List[int], start_hint: float) -> bool:
        scope = Scope[op.meta["scope"]]
        start = self.addr.earliest_start_for_scope(die, scope, plane_set)
        dur = get_op_duration(op); end=quantize(start+dur)
        return self.excl.allowed(op, start, end)

    def propose(self, now_us: float, hook: PhaseHook, g: Dict[str,str], l: Dict[str,str], earliest_start: float) -> Optional[Operation]:
        die, hook_plane = hook.die, hook.plane

        # 0) obligation ìš°ì„ 
        ob=self.obl.pop_urgent(now_us, die, hook_plane, horizon_us=10.0, earliest_start=earliest_start)
        if ob:
            cfg_op=self.cfg["op_specs"][ob.require.name]; op=build_operation(ob.require, cfg_op, ob.targets)
            op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=sorted({a.plane for a in ob.targets}); op.meta["arity"]=len(op.meta["plane_list"])
            scope=Scope[op.meta["scope"]]; plane_set=op.meta["plane_list"]
            start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
            if self.addr.precheck_planescope(op.kind, op.targets, start_hint, scope)\
               and self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op))\
               and self._exclusion_ok(op, die, plane_set, start_hint):
                op.meta["source"]="obligation"; op.meta["phase_key_used"]="(obligation)"; return op

        # 1) phase-conditional (alias + SR)
        allow=set(list(OP_ALIAS.keys())+["READ","PROGRAM","ERASE","SR"])
        dist, used_key = get_phase_dist(self.cfg, hook.label)
        if dist:
            pick=roulette_pick(dist, allow)
            if pick:
                base, alias_const = resolve_alias(pick)
                kind=OpKind[base]
                if kind==OpKind.SR:
                    plan=self.addr.plan_multipane(kind, die, hook_plane, 1, True)
                else:
                    fanout, interleave=self._fanout_from_alias(base, alias_const, hook.label)
                    plan=self.addr.plan_multipane(kind, die, hook_plane, fanout, interleave)
                    if not plan and fanout>1:
                        self.stats["alias_degrade"]+=1
                        plan=self.addr.plan_multipane(kind, die, hook_plane, 1, interleave)
                if plan:
                    targets, plane_set, scope=plan
                    cfg_op=self.cfg["op_specs"][base]; op=build_operation(kind, cfg_op, targets)
                    op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=plane_set; op.meta["arity"]=len(plane_set); op.meta["alias_used"]=pick
                    start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
                    if self.addr.precheck_planescope(kind, targets, start_hint, scope)\
                       and self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op))\
                       and self._exclusion_ok(op, die, plane_set, start_hint):
                        op.meta["source"]="policy.phase_conditional"; op.meta["phase_key_used"]=used_key; return op
            # ì‹¤íŒ¨ ì‹œ ë°±ì˜¤í”„

        # 2) backoff
        cand=[]
        for name in ["READ","PROGRAM","ERASE","SR"]:
            s=self._score(name, hook.label, g, l)
            if s>0: cand.append((name,s))
        if not cand: return None
        tot=sum(s for _,s in cand); r=random.random()*tot; acc=0.0; pick=cand[-1][0]
        for name,s in cand:
            acc+=s
            if r<=acc: pick=name; break
        kind=OpKind[pick]
        if kind==OpKind.SR:
            plan=self.addr.plan_multipane(kind, die, hook_plane, 1, True)
        else:
            fanout, interleave=get_phase_selection_override(self.cfg, hook.label, pick)
            plan=self.addr.plan_multipane(kind, die, hook_plane, fanout, interleave)
        if not plan: return None
        targets, plane_set, scope=plan
        cfg_op=self.cfg["op_specs"][pick]; op=build_operation(kind, cfg_op, targets)
        op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=plane_set; op.meta["arity"]=len(plane_set)
        start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
        if not (self.addr.precheck_planescope(kind, targets, start_hint, scope)\
                and self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op))\
                and self._exclusion_ok(op, die, plane_set, start_hint)):
            return None
        op.meta["source"]="policy.score_backoff"; op.meta["phase_key_used"]="(score_backoff)"; return op

# ---------------------------- Scheduler ----------------------------
def _addr_str(a: Address)->str: return f"(d{a.die},p{a.plane},b{a.block},pg{a.page})"

class Scheduler:
    def __init__(self, cfg, addr: AddressManager, spe: PolicyEngine, obl: ObligationManager, excl: ExclusionManager):
        self.cfg=cfg; self.addr=addr; self.SPE=spe; self.obl=obl; self.excl=excl
        self.now=0.0; self.ev=[]; self._seq=0
        self.stat_propose_calls=0; self.stat_scheduled=0
        self._push(0.0, "QUEUE_REFILL", None)
        for plane in range(self.addr.planes):
            self._push(0.0, "PHASE_HOOK", PhaseHook(0.0, "BOOT.START", 0, plane))

    def _push(self, t: float, typ: str, payload: Any):
        heapq.heappush(self.ev, (quantize(t), self._seq, typ, payload)); self._seq+=1

    def _start_time_for_op(self, op: Operation) -> float:
        die=op.targets[0].die
        scope=Scope[op.meta.get("scope","PLANE_SET")]
        plane_set=[a.plane for a in op.targets]
        t_planes=self.addr.earliest_start_for_scope(die, scope, plane_set)
        return quantize(max(self.now, t_planes))

    def _label_for_read(self, op: Operation)->str:
        if op.kind!=OpKind.READ: return op.kind.name
        return "MUL_READ" if op.meta.get("arity",1)>1 else "SIN_READ"

    def _schedule_operation(self, op: Operation):
        start=self._start_time_for_op(op); dur=get_op_duration(op); end=quantize(start+dur)
        # plane scope reserve + bus reserve + exclusion windows register + future update
        self.addr.reserve_planescope(op, start, end)
        self.addr.bus_reserve(start, self.addr.bus_segments_for_op(op))
        self.excl.register(op, start)
        self.addr.register_future(op, start, end)

        # events
        self._push(start, "OP_START", op); self._push(end, "OP_END", op)

        # phase hooks (READëŠ” SIN_READ/MUL_READ ë¼ë²¨ë¡œ)
        label_op=self._label_for_read(op)
        for t in op.targets:
            cur=start
            for s in op.states:
                self._push(cur,               "PHASE_HOOK", PhaseHook(cur,               f"{label_op}.{s.name}.START", t.die, t.plane))
                if s.name=="CORE_BUSY": 
                    self._push(cur + s.dur_us*0.5, "PHASE_HOOK", PhaseHook(cur + s.dur_us*0.5, f"{label_op}.{s.name}.MID",   t.die, t.plane))
                self._push(cur + s.dur_us,    "PHASE_HOOK", PhaseHook(cur + s.dur_us,    f"{label_op}.{s.name}.END",   t.die, t.plane))
                cur += s.dur_us

        first=op.targets[0]
        print(f"[{self.now:7.2f} us] SCHED  {op.kind.name:7s} arity={op.meta.get('arity')} scope={op.meta.get('scope')} start={start:7.2f} end={end:7.2f} 1st={_addr_str(first)} src={op.meta.get('source')} alias={op.meta.get('alias_used')}")

        self.stat_scheduled+=1

    def run_until(self, t_end: float):
        t_end=quantize(t_end)
        while self.ev and self.ev[0][0] <= t_end:
            self.now, _, typ, payload = heapq.heappop(self.ev)

            if typ=="QUEUE_REFILL":
                for plane in range(self.addr.planes):
                    self._push(self.now, "PHASE_HOOK", PhaseHook(self.now, "REFILL.NUDGE", 0, plane))
                self._push(self.now + self.cfg["policy"]["queue_refill_period_us"], "QUEUE_REFILL", None)

            elif typ=="PHASE_HOOK":
                hook: PhaseHook = payload
                earliest_start=self.addr.available_at(hook.die, hook.plane)
                g,l=self.addr.observe_states(hook.die, hook.plane, self.now)
                self.stat_propose_calls+=1
                op=self.SPE.propose(self.now, hook, g, l, earliest_start)
                if op: self._schedule_operation(op)

            elif typ=="OP_START":
                op: Operation=payload; first=op.targets[0]
                print(f"[{self.now:7.2f} us] START  {op.kind.name:7s} arity={op.meta.get('arity')} target={_addr_str(first)}")

            elif typ=="OP_END":
                op: Operation=payload; first=op.targets[0]
                print(f"[{self.now:7.2f} us] END    {op.kind.name:7s} arity={op.meta.get('arity')} target={_addr_str(first)}")
                self.addr.commit(op); self.obl.on_commit(op, self.now)

        print(f"\n=== Stats ===")
        print(f"propose calls : {self.stat_propose_calls}")
        print(f"scheduled ops : {self.stat_scheduled}")
        if self.stat_propose_calls:
            print(f"accept ratio  : {100.0*self.stat_scheduled/self.stat_propose_calls:.1f}%")

# ---------------------------- Selection overrides ----------------------------
def get_phase_selection_override(cfg: Dict[str,Any], hook_label: str, kind_name: str):
    op, state, pos = parse_hook_key(hook_label)
    po=cfg.get("selection",{}).get("phase_overrides",{})
    keys=[]
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    for k in keys:
        val=po.get(k)
        if val:
            return int(val.get("fanout",1)), bool(val.get("interleave",True))
    dflt=cfg.get("selection",{}).get("defaults",{}).get(kind_name,{"fanout":1,"interleave":True})
    return int(dflt.get("fanout",1)), bool(dflt.get("interleave",True))

# ---------------------------- Main ----------------------------
def main():
    random.seed(CFG["rng_seed"])
    addr=AddressManager(CFG); excl=ExclusionManager(CFG)
    obl=ObligationManager(CFG["obligations"])
    spe=PolicyEngine(CFG, addr, obl, excl)
    sch=Scheduler(CFG, addr, spe, obl, excl)
    print("=== NAND Sequence Generator (P4: addr-state rails + no-dup PROGRAM + committed-only READ) ===")
    sch.run_until(CFG["policy"]["run_until_us"])
    print("=== Done ===")

if __name__=="__main__":
    main()

```

í•µì‹¬ ë³€ê²½ ìš”ì•½
1. ìƒíƒœ 2ë ˆì¼ ë„ì… (Committed/Future)
  - addr_state_committed[(d,p,b)]: ì»¤ë°‹ ì™„ë£Œëœ ë§ˆì§€ë§‰ page (âˆ’1=ERASED, âˆ’2=initial).
  - addr_state_future[(d,p,b)]: ì˜ˆì•½ì„ ì¦‰ì‹œ ë°˜ì˜í•œ ë¯¸ë˜ ìƒíƒœ.
  - programmed_committed[(d,p)]: READ ê°€ì‹œì„± ì†ŒìŠ¤ â€” ì»¤ë°‹ëœ pageë§Œ í¬í•¨.
2. ì˜ˆì•½ ì§í›„ Future ë°˜ì˜ (register_future)
  - PROGRAM ì˜ˆì•½ â†’ í•´ë‹¹ blockì˜ futureë¥¼ target.pageë¡œ ì¦‰ì‹œ ê°±ì‹  â‡’ ì¤‘ë³µ PROGRAM ë¶ˆê°€.
  - ERASE ì˜ˆì•½ â†’ í•´ë‹¹ block future=-1.
3. precheck ì£¼ì†Œ ê·œì¹™ ê°•í™”
  - PROGRAM: target.page == future + 1 (ì •í™•íˆ ë‹¤ìŒ í˜ì´ì§€).
  - READ: target.page <= committed (ì»¤ë°‹ëœ í˜ì´ì§€ë§Œ ì½ê¸°).
4. ë©€í‹°â€‘í”Œë ˆì¸ í”Œë˜ë„ˆ ê°±ì‹ 
  - READ: planeâ€‘setì˜ committed pages êµì§‘í•©ì—ì„œ page ì„ íƒ.
  - PROGRAM: í›„ë³´ pageë¥¼ **(a) mode of next pages, (b) 0(ëª¨ë‘ ì§€ìš´ ë¸”ë¡ ì¡´ì¬ ì‹œ)**ë¡œ ì‹œë„ â†’ ê° planeì— í•´ë‹¹ next pageê°€ ê°€ëŠ¥í•œ blockì„ ì°¾ëŠ”ë‹¤ â†’ ì‹¤íŒ¨ ì‹œ fanout ê°•ë“±.
5. WRITE í—¤ë“œ ê´€ë¦¬
  - write_head[(d,p)]ë¡œ ê¸°ë³¸ PROGRAM ë¸”ë¡ í¬ì¸í„° ìœ ì§€; blockì´ ì°¼ìœ¼ë©´ erased blockìœ¼ë¡œ ìë™ ì „ì§„.
6. ê´€ì¸¡ê°’(observe_states) ì •í•©í™”
  - pgmable_ratio: future ê¸°ì¤€ ì—¬ìœ  page ìˆëŠ” block ë¹„ìœ¨,
  - readable_ratio: committed ê¸°ì¤€ ì½ê¸° ê°€ëŠ¥í•œ block ë¹„ìœ¨.
7. ìŠ¤ì¼€ì¤„ëŸ¬ì— í•œ ì¤„ ì¶”ê°€
  - ì˜ˆì•½ ì§í›„ addr.register_future(op, start, end) í˜¸ì¶œ.

ê¸°ëŒ€ íš¨ê³¼
- (ì¬í˜„ëœ) ì¤‘ë³µ PROGRAM(pg0 â†’ ë˜ pg0) ì¦‰ì‹œ ë°©ì§€.
- READëŠ” í”„ë¡œê·¸ë¨ëœ í˜ì´ì§€ë§Œ ìŠ¤ì¼€ì¤„ ê°€ëŠ¥(â€œblank blockì€ read ë¶ˆê°€â€).
- ë©€í‹°â€‘í”Œë ˆì¸ PROGRAM ì •ë ¬ì€ ë¯¸ë˜ ìƒíƒœë¥¼ ê¸°ì¤€ìœ¼ë¡œ ì•ˆì •í™”, ë¶ˆê°€ ì‹œ ìë™ ê°•ë“±(í†µê³„ë¡œ ì¶”ì  ê°€ëŠ¥).

ì›í•˜ë©´ ì´ ë²„ì „ì— **GlobalTimelineBuilder(ATE íŒ¨í„´ ë³€í™˜; NOP ì±„ì›€/ë‹¨ìœ„ ìŠ¤ì¼€ì¼)**ë„ ë°”ë¡œ ì–¹ì–´ì¤„ê²Œ.

## ğŸ‘¤ User

ìš°ì„  ì§€ê¸ˆ êµ¬ì¡°ì—ì„œ, stats ì„ ì¶”ê°€í•˜ì.
- obligation ì„±ê³µë¥ 
ê·¸ë¦¬ê³ , block ê³¼ page ì˜ ê°œë…ì„ ì¬ì •ì˜ í•˜ì. plane ì€ block%4 ì´ê³ , topology ì—ì„œ blocks_per_plane ì´ë€ ê°œë…ì€ ì—†ì• ì.
ê·¸ë¦¬ê³ , í˜„ì¬ êµ¬ì¡°ì—ì„œ policy ì— ì˜í•œ operation ì¶”ê°€ê°€ í­ë°œí•˜ëŠ” ê²½í–¥ì´ ìˆì–´. ê·¸ ë•Œë¬¸ì—, obligation ì¸ DOUT ì´ ìˆ˜í–‰ì´ ì „í˜€ ë˜ì§€ ì•Šì•„. ì´ ë¬¸ì œëŠ” ë‚´ ìƒê°ì— policy ì œì•ˆ ì‹œì—, earliest_start ë¥¼ ì‚¬ìš©í•˜ê¸° ë•Œë¬¸ì—, í•˜ë‚˜ì˜ operation ì´ ë§Œë“¤ì–´ì§€ë©´ì„œ 3ê°œì”© í›…ì´ ë§Œë“¤ì–´ ì§€ë©´ì„œ, ëª¨ë‘ ì˜ˆì•½ë˜ë²„ë¦¬ëŠ”ê±°ì•¼. ì´ê±¸ í•´ê²°í•  ë°©ë²•ì€ phase-conditional ì„ ì‚¬ìš©í•´ì„œ operation ì œì•ˆì„ í•  ë•Œ, í˜„ì¬ ì‹œê°ì—ì„œì˜ phase~ phase + delta ì •ë„ë¡œ ì•„ì£¼ ê°€ê¹Œìš´ ë¯¸ë˜ì•ˆì— operation ì„ ì¶”ê°€ ê°€ëŠ¥í•  ë•Œ ì„ íƒì´ ë˜ë„ë¡ í•˜ëŠ”ê±°ì•¼. ê·¸ëŸ¬ë©´ CORE_BUSY ì¤‘ê°„ì— policy operation ì´ í­ë°œì ìœ¼ë¡œ ì¶”ê°€ë˜ì§€ ì•Šê³ , SR ê³¼ ê°™ì€ operation ë§Œ ì¶”ê°€ê°€ ë˜ëŠ”ê±°ì•¼. ê·¸ê²Œ ìì—°ìŠ¤ëŸ¬ìš´ ìƒí™©ì´ì•¼. ì´ ê´€ì ì„ ê³ ë ¤í•´ì„œ êµ¬í˜„ ê³„íšì„ ì œì‹œ í›„, risk í‰ê°€ ë° ì§„í–‰í•˜ë„ë¡ í•˜ì.

## ğŸ¤– Assistant

ì¢‹ì•„. ìš”ì²­í•œ **3ê°€ì§€ ë³€ê²½(í†µê³„Â·ë¸”ë¡/í˜ì´ì§€ ì¬ì •ì˜Â·í­ë°œ ì–µì œ)**ì„ í˜„ì¬ êµ¬ì¡°ì— â€œìµœì†Œ ì¹¨ìŠµâ€ìœ¼ë¡œ ë…¹ì´ëŠ” êµ¬í˜„ ê³„íš + í•µì‹¬ íŒ¨ì¹˜ ìŠ¤ì¼€ì¹˜ + ë¦¬ìŠ¤í¬ í‰ê°€ë¥¼ í•œ ë²ˆì— ì •ë¦¬í–ˆì–´.  

(ì½”ë“œëŠ” ì§€ê¸ˆ ë„ˆì˜ P3/P4 ê³„ì—´ í†µí•©ë³¸ ê¸°ì¤€ìœ¼ë¡œ ì„¤ëª…í•œë‹¤.)

1) í†µê³„ ì¶”ê°€: Obligation ì„±ê³µë¥ 
ì •ì˜
- created: READ ì»¤ë°‹ìœ¼ë¡œ DOUT ì˜ë¬´ê°€ ìƒì„±ëœ íšŸìˆ˜
- assigned: ì˜ë¬´ê°€ ì‹¤ì œ ì˜¤í¼ë ˆì´ì…˜ìœ¼ë¡œ ìŠ¤ì¼€ì¤„ ë˜ì—ˆë‹¤(ì˜ˆì•½ ì„±ê³µ)
- fulfilled: í•´ë‹¹ ì˜¤í¼ë ˆì´ì…˜ì´ ì»¤ë°‹ë¨
- fulfilled_in_time: ì»¤ë°‹ ì‹œê° â‰¤ ì˜ë¬´ deadline
- expired: deadline ê²½ê³¼ ì‹œì ê¹Œì§€ ìŠ¤ì¼€ì¤„/ì»¤ë°‹ì´ ì•ˆ ë¨

ì„±ê³µë¥  = fulfilled_in_time / created

ë³€ê²½ í¬ì¸íŠ¸
- ObligationManager
  - í•„ë“œ: self.stats = {"created":0, "assigned":0, "fulfilled":0, "fulfilled_in_time":0, "expired":0}
  - on_commit(READ)ì—ì„œ created += 1 (ê¸°ì¡´ ìƒì„± ë¡œì§ ìœ ì§€)
  - pop_urgent(...)ê°€ ë°˜í™˜í•œ obligationì„ op.meta["obligation"] = obë¡œ ë¶€ì°©
  - mark_assigned(ob) / mark_fulfilled(ob, now) / expire_due(now) ë©”ì„œë“œ ì¶”ê°€
    - expire_due(now): ì´ë²¤íŠ¸ ë£¨í”„ì—ì„œ ì£¼ê¸°ì ìœ¼ë¡œ í˜¸ì¶œí•´ deadline <= now í•­ëª©ì„ ë§Œë£Œ ì²˜ë¦¬
- Scheduler._schedule_operation(op):
  - if "obligation" in op.meta: obl.mark_assigned(op.meta["obligation"])
- Schedulerì˜ OP_END ì²˜ë¦¬:
  - if "obligation" in op.meta: obl.mark_fulfilled(op.meta["obligation"], now)
- Scheduler.run_until ë£¨í”„ì—ì„œ ì´ë²¤íŠ¸ ì²˜ë¦¬ ì „í›„ì— obl.expire_due(self.now) í˜¸ì¶œ
- ì¢…ë£Œ ì‹œ í†µê³„ ì¶œë ¥:
  - obligation success: {fulfilled_in_time}/{created} ({ratio:.1f}%)

2) ë¸”ë¡/í˜ì´ì§€ ì¬ì •ì˜
ìš”êµ¬ì‚¬í•­ ë°˜ì˜
- plane = (block % planes)
- topologyì—ì„œ blocks_per_plane ì œê±° â†’ **blocks (die ì „ì²´ ë¸”ë¡ ìˆ˜)**ë¡œ ì¼ì›í™”

ë°ì´í„° ëª¨ë¸ ë³€ê²½ (AddressManager)
- í† í´ë¡œì§€:
- ìƒíƒœ ë ˆì¼(ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ë˜ key ë³€ê²½):
  - addr_state_committed[(die, block)] : int  (-3/-2/-1/0..)
  - addr_state_future[(die, block)]    : int
  - programmed_committed[(die)] : Set[(block, page)] (planeë³„ë¡œëŠ” í•„í„°ë¡œ êµ¬ë¶„)
  - write_head[(die, plane)] : int  (í•´ë‹¹ planeì— ì†í•˜ëŠ” block ì¸ë±ìŠ¤. ì´ˆê¸°ê°’ = plane, ë˜ëŠ” plane ëª¨ë“ˆ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ” ì²« ë¸”ë¡)

ì£¼ìš” ë£¨í”„ ë³€ê²½: â€œplane ë‹¨ìœ„ ë¸”ë¡ ì—´ëŒâ€ì´ í•„ìš”í•  ë•Œ  

for b in range(blocks): if b % planes == plane: ...

API/ë¡œì§ ì˜í–¥
- Address: ì—¬ì „íˆ (die, plane, block, page) ë³´ì¡´. ë‹¨, ì¼ê´€ì„± assert
  - ì˜ˆì•½/í”„ë¦¬ì²´í¬/ì»¤ë°‹ ì‹œ assert plane == (block % planes)
- observe_states(die, plane):
  - planeì˜ ë¸”ë¡ ì§‘í•© B_p = { b | 0<=b<blocks, b%planes==plane }ì— ëŒ€í•´
    - pgmable_blocks: addr_state_future[(die,b)] < pages_per_block-1
    - readable_blocks: addr_state_committed[(die,b)] >= 0
- READ í”Œë˜ë‹:
  - programmed_committed[die]ì—ì„œ b%planes==planeì¸ í•­ëª©ë§Œ í•„í„° í›„ í˜ì´ì§€ êµì§‘í•©
- PROGRAM í”Œë˜ë‹:
  - ê° planeì˜ write_head[(die,plane)]ë¥¼ ì‹œì‘ì ìœ¼ë¡œ, ëª©í‘œ í˜ì´ì§€ pageì— ëŒ€í•´
    - addr_state_future[(die, b)] == page-1ì„ ë§Œì¡±í•˜ëŠ” b (b%planes==plane)ì„ íƒìƒ‰
- ERASE:
  - write_head ìš°ì„ , ì—†ìœ¼ë©´ planeì— ì†í•˜ëŠ” ì„ì˜ì˜ non-erased block
- ì»¤ë°‹/ì˜ˆì•½(future) ê°±ì‹ :
  - í‚¤ (die, block) ê¸°ë°˜ìœ¼ë¡œ ì—…ë°ì´íŠ¸
  - programmed_committed[(die)]ì— (block,page) ì €ì¥/ì œê±°
  - write_headëŠ” ë¸”ë¡ full/erase ì‹œ ì ì ˆíˆ ë‹¤ìŒ í›„ë³´ë¡œ ì´ë™(ì¡°ê±´: b%planes==plane)

3) Policy í­ë°œ ì–µì œ (Nearâ€‘Future Admission Gating)
ë¬¸ì œ ì›ì¸
- propose ì‹œ earliest_startê°€ í˜„ì¬ í›… ì‹œê°ë³´ë‹¤ ë©€ë¦¬ ìˆì–´ë„ ìŠ¤ì¼€ì¤„ ìŠ¹ì¸ì´ ë‚˜ë©´ì„œ,

í•˜ë‚˜ì˜ OP ì˜ˆì•½ì´ **ì—¬ëŸ¬ í›…(START/MID/END)**ë¥¼ ë§Œë“¤ì–´ í›„ì† ì œì•ˆì´ ë” ë©€ë¦¬ ì˜ˆì•½ë˜ëŠ” ì—°ì‡„ í­ë°œ ë°œìƒ.

â†’ ê²°ê³¼ì ìœ¼ë¡œ DOUT ì˜ë¬´ê°€ ë¼ì–´ë“¤ ì—¬ì§€ê°€ ì‚¬ë¼ì§.

í•´ê²° ê°œë…
- â€œì•„ì£¼ ê°€ê¹Œìš´ ë¯¸ë˜(Î”)â€ ì•ˆì—ì„œ ì‹œì‘ ê°€ëŠ¥í•œ ê²ƒë§Œ policyê°€ ìŠ¹ì¸
- Î”ëŠ” phaseë³„/ì—°ì‚°ë³„ë¡œ íŠœë‹ ê°€ëŠ¥ (CORE_BUSY ì¤‘ì—” ë§¤ìš° ì‘ê²Œ â†’ SR ìœ„ì£¼ë§Œ í†µê³¼)
- Obligationì€ ì˜ˆì™¸(deadline ê¸°ë°˜): Î” ë¬´ì‹œí•˜ê±°ë‚˜ ë³„ë„ Î”_obligation

CFG ì¶”ê°€ (ì˜ˆì‹œ)

```yaml
admission:
  default_delta_us: 0.30
  phase_overrides:
    CORE_BUSY: 0.05
    ISSUE:     0.10
    DATA_OUT:  0.05
    BOOT:      0.30
    REFILL:    0.10
  op_overrides:
    SR: 0.30
  obligation_bypass: true

```

êµ¬í˜„(PolicyEngine)
- get_admission_delta(cfg, hook.label, op_kind) ìœ í‹¸ ì¶”ê°€:
  - í›… ë¼ë²¨ì—ì„œ state ì¶”ì¶œ â†’ phase_overrides ìš°ì„ , ì—†ìœ¼ë©´ op_overrides[op_kind], ì—†ìœ¼ë©´ default
- proposeì—ì„œ plan + precheck + bus_precheck í†µê³¼ í›„:
  - start_hint = addr.earliest_start_for_scope(...)
  - Admission check: start_hint <= now_us + deltaì¸ì§€ ê²€ì‚¬
    - ì•„ë‹ˆë¼ë©´ reject (ë‹¤ë¥¸ í›„ë³´ í˜¹ì€ None)
- Obligation ê²½ë¡œ:
  - obligation_bypass == trueì´ë©´ Î” ê²€ì‚¬ë¥¼ ê±´ë„ˆëœ€
  - (ì„ íƒ) bypass=falseë©´ Î”ë¥¼ min(delta, ob.deadline - now_us)ë¡œ ì œí•œ

ì´ë ‡ê²Œ í•˜ë©´ CORE_BUSY ì¤‘ì—ëŠ” SRì²˜ëŸ¼ ì¦‰ì‹œ ë°œí–‰ ê°€ëŠ¥í•œ ê²½ëŸ‰ ì—°ì‚°ë§Œ ë“¤ì–´ì˜¤ê³ , DOUTì´ ë¹ˆí‹ˆì„ ì–»ëŠ”ë‹¤.

4) í•µì‹¬ íŒ¨ì¹˜ ìŠ¤ì¼€ì¹˜
4.1 ObligationManager í†µê³„/ë¼ì´í”„ì‚¬ì´í´

```python
@dataclass
class Obligation:
    id: int
    require: OpKind
    targets: List[Address]
    deadline_us: float
    hard_slot: bool

class ObligationManager:
    def __init__(...):
        self.stats = {"created":0,"assigned":0,"fulfilled":0,"fulfilled_in_time":0,"expired":0}
        self._seq = 0
        self.heap = []
        self.assigned: Dict[int, Obligation] = {}

    def on_commit(self, op, now):
        if op.kind.name == "READ":
            self._seq += 1
            ob = Obligation(id=self._seq, require=OpKind.DOUT, targets=op.targets,
                            deadline_us=quantize(now + sample_dist(spec["window_us"])),
                            hard_slot=spec["priority_boost"].get("hard_slot", False))
            heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=ob.id, ob=ob))
            self.stats["created"] += 1
            return

    def pop_urgent(...)->Optional[Obligation]:
        # ê¸°ì¡´ ë¡œì§ ìœ ì§€(ë°˜í™˜ ì‹œ heapì—ì„œ ì œê±°)
        ...

    def mark_assigned(self, ob: Obligation):
        self.assigned[ob.id] = ob
        self.stats["assigned"] += 1

    def mark_fulfilled(self, ob: Obligation, now: float):
        if ob.id in self.assigned: self.assigned.pop(ob.id, None)
        self.stats["fulfilled"] += 1
        if now <= ob.deadline_us: self.stats["fulfilled_in_time"] += 1

    def expire_due(self, now: float):
        # heapì˜ í”„ë¡ íŠ¸ë¥¼ ë³´ë©° ë§Œë£Œ
        kept=[]
        while self.heap and self.heap[0].deadline_us <= now:
            item = heapq.heappop(self.heap)
            self.stats["expired"] += 1
        # (assigned ì¤‘ì—ì„œë„ deadline ê²½ê³¼ í™•ì¸í•˜ë ¤ë©´ ì¶”ê°€ ìŠ¤ìº”)

```

- Scheduler._schedule_operation:

if "obligation" in op.meta: obl.mark_assigned(op.meta["obligation"])
- Scheduler ë£¨í”„: ê° ì´ë²¤íŠ¸ ì²˜ë¦¬ ì§ì „ obl.expire_due(self.now) í˜¸ì¶œ
- OP_END ì‹œ:

if "obligation" in op.meta: obl.mark_fulfilled(op.meta["obligation"], self.now)
- ì¢…ë£Œ ì¶œë ¥:

```python
s=obl.stats
rate = (100.0*s["fulfilled_in_time"]/s["created"]) if s["created"] else 0.0
print(f"obligations  : created={s['created']} assigned={s['assigned']} fulfilled={s['fulfilled']} in_time={s['fulfilled_in_time']} expired={s['expired']} success={rate:.1f}%")

```

4.2 Admission Gating

```python
def get_admission_delta(cfg, hook_label, op_kind_name):
    _, state, _ = parse_hook_key(hook_label)
    adm = cfg.get("admission", {})
    if state and state in adm.get("phase_overrides", {}):
        return float(adm["phase_overrides"][state])
    if op_kind_name in adm.get("op_overrides", {}):
        return float(adm["op_overrides"][op_kind_name])
    return float(adm.get("default_delta_us", 0.3))

# PolicyEngine.propose(...)
# (1) obligation branch
if ob:
    ...
    if cfg["admission"].get("obligation_bypass", True) is False:
        delta = min(get_admission_delta(cfg, hook.label, ob.require.name), ob.deadline_us - now_us)
        if start_hint > now_us + max(0.0, delta): 
            # ë³´ìˆ˜ì ìœ¼ë¡œ ì‹¤íŒ¨ ì²˜ë¦¬(ë˜ëŠ” heapì— ì¬ì£¼ì…)
            pass
    return op

# (2) policy branch candidate op ì¤€ë¹„ í›„, ìµœì¢… ìŠ¹ì¸ ì§ì „
delta = get_admission_delta(self.cfg, hook.label, base)
if start_hint > now_us + delta:
    return None

```

4.3 ë¸”ë¡/í”Œë ˆì¸ ì¬ì •ì˜ ë°˜ì˜ (í•µì‹¬ë§Œ)

```python
# AddressManager.__init__
self.planes = topo["planes"]
self.blocks = topo["blocks"]

# ìƒíƒœ ë ˆì¼ ì´ˆê¸°í™”
for b in range(self.blocks):
    self.addr_state_committed[(0,b)] = init_state
    self.addr_state_future[(0,b)]    = init_state
# programmed_committed[(0)] = set()
for p in range(self.planes):
    self.write_head[(0,p)] = p  # ë˜ëŠ” plane ëª¨ë“ˆ ìµœì†Œ ë¸”ë¡

def plane_of(self, block:int)->int: return block % self.planes

# observe_states(die, plane): B_p ë£¨í”„
for b in range(self.blocks):
    if b % self.planes != plane: continue
    fut = self.addr_state_future[(die,b)]
    com = self.addr_state_committed[(die,b)]
    ...

# READ planner êµì§‘í•©
def _committed_pages_plane(self, die, plane)->Set[int]:
    return {p for (b,p) in self.programmed_committed[(die)] if (b % self.planes)==plane}

# PROGRAM next page(from future) on plane-set
def _next_page_future(self, die, block)->int:
    last = self.addr_state_future[(die,block)]
    return (last + 1) if last < self.pages_per_block-1 else self.pages_per_block

def _find_block_for_page_future(self, die, plane, target_page)->Optional[int]:
    for b in range(self.blocks):
        if b % self.planes != plane: continue
        if self._next_page_future(die,b) == target_page: return b
    return None

# ì»¤ë°‹/ì˜ˆì•½(future)
if op.kind==PROGRAM:
    self.addr_state_future[(die, block)] = max( ..., page)
    # write_head ì—…ë°ì´íŠ¸: if _next_page_future >= pages_per_block: write_head ì´ë™(plane ëª¨ë“ˆ ìœ ì§€)
elif op.kind==ERASE:
    self.addr_state_future[(die, block)] = -1

# programmed_committed ì˜ keyëŠ” (die) í•˜ë‚˜
# ì¶”ê°€: self.programmed_committed[(die)].add((block,page))
# ì‚­ì œ: set ì»´í”„ë¦¬í—¨ì…˜ìœ¼ë¡œ blockê°€ ê°™ì€ ê²ƒ ì œê±°

```

5) ë¦¬ìŠ¤í¬ í‰ê°€ & ëŒ€ì‘

| ì˜ì—­ | ë¦¬ìŠ¤í¬ | ì˜í–¥ | ëŒ€ì‘/ì™„í™” |
| --- | --- | --- | --- |
| ë¸”ë¡/í”Œë ˆì¸ ì¬ì •ì˜ | ê¸°ì¡´ blocks_per_plane ì°¸ì¡° ì½”ë“œ ì”ì¡´ | ëŸ°íƒ€ì„ KeyError/ë…¼ë¦¬ì˜¤ë¥˜ | grep/ì¼ê´„ ì¹˜í™˜, self.blocksë¡œ í†µì¼. planeë³„ ë£¨í”„ëŠ” b%planes í•„í„°ë¡œ êµì²´. ë‹¨ìœ„ í…ŒìŠ¤íŠ¸: ë¸”ë¡â†’í”Œë ˆì¸ ë§¤í•‘ assert |
| planeâ€“block ë¶ˆì¼ì¹˜ | Address ìƒì„± ì‹œ planeâ‰ (block%planes) | ìŠ¤ì¼€ì¤„/ì»¤ë°‹ ìƒíƒœ ì˜¤ì—¼ | precheck_planescopeì— assert/ê²€ì‚¬ ì¶”ê°€(ë¶ˆì¼ì¹˜ ì‹œ reject) |
| Admission gating ê³¼ë„ | Î”ê°€ ë„ˆë¬´ ì‘ì•„ policy ê¸°ì•„ | throughput/ë‹¤ì–‘ì„± ì €í•˜ | default_delta_us/phaseë³„ Î”ë¥¼ CFGë¡œ ì¡°ì •. ì˜ë¬´ëŠ” bypass. Î” ë©”íŠ¸ë¦­ ë¡œê¹…(ê±°ì ˆ ì‚¬ìœ ) |
| ì˜ë¬´ ë§Œë£Œ ê´€ë¦¬ | expire_due íƒ€ì´ë° ëˆ„ë½ | successìœ¨ ì™œê³¡ | ëª¨ë“  ì´ë²¤íŠ¸ ì²˜ë¦¬ ì‹œì ë§ˆë‹¤ í˜¸ì¶œ(ê²½ëŸ‰). assigned mapë„ ë°ë“œë¼ì¸ ê²€í†  ì˜µì…˜ |
| ìƒíƒœ 2ë ˆì¼ê³¼ ìƒˆ í‚¤ êµ¬ì¡° | ì»¤ë°‹<future ë¶ˆë³€ì¡°ê±´ ìœ„ë°˜ | ì¤‘ë³µ PROGRAM, READ ê°€ì‹œì„± ì˜¤ë¥˜ | ì˜ˆì•½ ì§í›„ future ê°±ì‹ , ì»¤ë°‹ì—ì„œ committed ê°±ì‹ . ë””ë²„ê·¸ ëª¨ë“œì—ì„œ assert committed<=future |
| write_head ì´ë™ | plane ëª¨ë“ˆ ê¹¨ì§ | PROGRAM ì •ë ¬ ì‹¤íŒ¨ ì¦ê°€ | ì´ë™ ì‹œ ë‹¤ìŒ planeâ€‘ëª¨ë“ˆ blockë§Œ ê³ ë ¤í•˜ë„ë¡ êµ¬í˜„ |

6) Toâ€‘Do (ì‹¤í–‰ ìˆœì„œ)
P0 (í•µì‹¬)
1. ObligationManager í†µê³„/ë¼ì´í”„ì‚¬ì´í´(+Scheduler ì—°ë™)
2. admission ê²Œì´íŠ¸ ì¶”ê°€(phase/opë³„ Î”, obligation bypass)
3. Schedulerì—ì„œ expire_due() ì£¼ê¸° í˜¸ì¶œ ë° í†µê³„ ì¶œë ¥

P1 (ë¸”ë¡/í”Œë ˆì¸ ì¬ì •ì˜)  

4. topology ìŠ¤í‚¤ë§ˆ êµì²´(planes,blocks)  

5. AddressManagerì˜ ìƒíƒœ ë ˆì¼ í‚¤ë¥¼ (die, block)ë¡œ ë³€ê²½  

6. READ/PROGRAM/ERASE í”Œë˜ë„ˆ/í”„ë¦¬ì²´í¬/ì»¤ë°‹ ë¡œì§ì„ b%planes ê¸°ì¤€ìœ¼ë¡œ ìˆ˜ì •  

7. planeâ‰ (block%planes) ê²€ì¦ ì¶”ê°€
P2 (í’ˆì§ˆ/ë©”íŠ¸ë¦­)  

8. Admission ê±°ì ˆ ì‚¬ìœ  ì¹´ìš´í„°(phase/opë³„)  

9. ì˜ë¬´ ì„±ê³µë¥ (ì‹œê°„ ì¶”ì„¸) ì¶œë ¥ ì˜µì…˜  

10. íšŒê·€: seed ê³ ì •ì—ì„œ accept ratio/obligation success í™•ì¸

í•„ìš”í•˜ë©´, ìœ„ ê³„íšì„ ë°”ë¡œ ë°˜ì˜í•œ íŒ¨ì¹˜ ë²„ì „ ì½”ë“œë„ ì´ì–´ì„œ ì œê³µí• ê²Œ.  

(í†µê³„Â·admissionÂ·ë¸”ë¡/í”Œë ˆì¸ ì¬ì •ì˜ê¹Œì§€ í•œ íŒŒì¼ì— ë¬¶ì–´ ë“œë¦´ ìˆ˜ ìˆì–´.)

## ğŸ‘¤ User

í†µê³„Â·admissionÂ·ë¸”ë¡/í”Œë ˆì¸ ì¬ì •ì˜ê¹Œì§€ í•œ íŒŒì¼ì— ë¬¶ì–´ì¤˜

## ğŸ¤– Assistant

ì•„ë˜ëŠ” ìš”ì²­í•˜ì‹  **í†µê³„(Obligation ì„±ê³µë¥ ) + Admission(ê°€ê¹Œìš´ ë¯¸ë˜ ê²Œì´íŒ…) + ë¸”ë¡/í”Œë ˆì¸ ì¬ì •ì˜(plane = block % planes)**ê¹Œì§€ ëª¨ë‘ ë°˜ì˜í•œ ë‹¨ì¼ íŒŒì¼ì…ë‹ˆë‹¤.  

ì´ì „ ë²„ì „(P4)ì˜ ê¸°ëŠ¥(ì—ì¼ë¦¬ì–´ìŠ¤ ê¸°ë°˜ ë©€í‹°í”Œë ˆì¸, SR, CORE_BUSY ì œì•½, DOUT ê¸€ë¡œë²Œ í”„ë¦¬ì¦ˆ, DIE_WIDE ì ìœ , Bus ê²Œì´íŒ…)ë„ ìœ ì§€/í˜¸í™˜ë©ë‹ˆë‹¤.

íŒŒì¼ëª… ì˜ˆì‹œ: nandsim_p5_allinone.py

```python
# nandsim_p5_allinone.py
# - P5: Stats + Admission gating + Block/Plane redefinition
# - AddressManager v2: committed/future rails (no-dup PROGRAM; READ uses committed visibility)
# - Block/Plane: plane = block % planes; topology: {dies, planes, blocks, pages_per_block}
# - Policy admission gating (near-future only; phase/op tunable; obligations bypass)
# - Obligation stats: created/assigned/fulfilled/fulfilled_in_time/expired
# - Multi-plane alias (SIN_*/MUL_*), DIE_WIDE CORE_BUSY, Bus gating, SR, constraints incl. DOUT freeze

from __future__ import annotations
import heapq, random
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple, Set

# --------------------------------------------------------------------------
# Simulation resolution
SIM_RES_US = 0.01
def quantize(t: float) -> float:
    return round(t / SIM_RES_US) * SIM_RES_US

# --------------------------------------------------------------------------
# Config
CFG = {
    "rng_seed": 12345,
    "policy": {
        "queue_refill_period_us": 3.0,
        "run_until_us": 180.0,
        "planner_max_tries": 8,
    },

    # Admission gating (near-future only to prevent policy explosion)
    "admission": {
        "default_delta_us": 0.30,
        "phase_overrides": {
            "CORE_BUSY": 0.05,
            "ISSUE":     0.10,
            "DATA_OUT":  0.05,
            "BOOT":      0.30,
            "NUDGE":     0.10,  # from REFILL.NUDGE hooks
        },
        "op_overrides": {
            "SR": 0.30
        },
        "obligation_bypass": True  # obligations ignore admission delta by default
    },

    # Phase-conditional proposal (alias keys allowed)
    "phase_conditional": {
        "READ.ISSUE":                {"MUL_PROGRAM": 0.15, "SIN_PROGRAM": 0.10, "SIN_READ": 0.35, "MUL_READ": 0.25, "SIN_ERASE": 0.15, "SR": 0.00},
        "READ.CORE_BUSY.START":      {"MUL_READ": 0.50, "SIN_READ": 0.20, "SIN_PROGRAM": 0.10, "SIN_ERASE": 0.10, "SR": 0.10},
        "READ.DATA_OUT.START":       {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.15, "SIN_ERASE": 0.10, "SR": 0.05},

        "PROGRAM.ISSUE":             {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.15, "SIN_ERASE": 0.10, "SR": 0.05},
        "PROGRAM.CORE_BUSY":         {"SR": 1.0},   # during PROGRAM core-busy: only SR
        "PROGRAM.CORE_BUSY.END":     {"SIN_READ": 0.55, "MUL_READ": 0.25, "SIN_PROGRAM": 0.10, "SIN_ERASE": 0.05, "SR": 0.05},

        "ERASE.ISSUE":               {"SIN_PROGRAM": 0.40, "MUL_PROGRAM": 0.20, "SIN_READ": 0.25, "MUL_READ": 0.10, "SR": 0.05},
        "ERASE.CORE_BUSY":           {"SR": 1.0},   # during ERASE core-busy: only SR
        "ERASE.CORE_BUSY.END":       {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.10, "MUL_PROGRAM": 0.05, "SR": 0.15},

        "MUL_READ.CORE_BUSY":        {"SR": 1.0},   # during MUL_READ core-busy: only SR
        "SIN_READ.CORE_BUSY":        {"SIN_READ": 0.6, "SR": 0.4},  # during SIN_READ core-busy: allow SIN_READ or SR; forbid MUL/PGM/ERASE

        "DEFAULT":                   {"SIN_READ": 0.55, "SIN_PROGRAM": 0.25, "SIN_ERASE": 0.10, "SR": 0.10},
    },

    # Backoff scoring weights (used if phase_conditional fails)
    "weights": {
        "base": {"host": {"READ": 0.70, "PROGRAM": 0.15, "ERASE": 0.05, "SR": 0.10, "RESET": 0.00, "DOUT": 0.00}},
        "g_state": {"pgmable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.8},
                    "readable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.9}},
        "g_local": {"plane_busy_frac": {"low": 1.2, "mid": 1.0, "high": 0.9}},
        "g_phase": {
            "READ": {"START_NEAR": 1.2, "MID_NEAR": 0.9, "END_NEAR": 1.2},
            "PROGRAM": {"START_NEAR": 1.1, "MID_NEAR": 1.0, "END_NEAR": 0.9},
            "ERASE": {"START_NEAR": 0.9, "MID_NEAR": 1.1, "END_NEAR": 1.1},
            "SR": {"START_NEAR": 1.1, "MID_NEAR": 1.1, "END_NEAR": 1.1},
        },
    },

    # Selection defaults/overrides (for fanout/interleave)
    "selection": {
        "defaults": {
            "READ":    {"fanout": 1, "interleave": True},
            "PROGRAM": {"fanout": 2, "interleave": True},
            "ERASE":   {"fanout": 2, "interleave": False},
            "SR":      {"fanout": 1, "interleave": True},
        },
        "phase_overrides": {
            "READ.CORE_BUSY.START": {"fanout": 4, "interleave": True},
        }
    },

    # Op specs (state sequence + bus usage; scope for CORE_BUSY occupancy)
    "op_specs": {
        "READ": {
            "scope": "PLANE_SET",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 8.0, "std": 1.5, "min": 2.0}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "normal", "mean": 2.0, "std": 0.4, "min": 0.5}},
            ],
        },
        "PROGRAM": {
            "scope": "DIE_WIDE",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 20.0, "std": 3.0, "min": 8.0}},
            ],
        },
        "ERASE": {
            "scope": "DIE_WIDE",
            "page_equal_required": False,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 40.0, "std": 5.0, "min": 15.0}},
            ],
        },
        "DOUT": {
            "scope": "NONE",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": False, "dist": {"kind": "fixed",  "value": 0.2}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "normal", "mean": 1.0, "std": 0.2, "min": 0.2}},
            ],
        },
        "SR": {
            "scope": "NONE",
            "page_equal_required": False,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.2}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "fixed",  "value": 0.3}},
            ],
        },
    },

    # Runtime exclusion rules (register on schedule; checked on propose)
    "constraints": {
        "exclusions": [
            # PROGRAM/ERASE: during CORE_BUSY block READ/PROGRAM/ERASE on the die; allow SR
            {"when": {"op": "PROGRAM", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},
            {"when": {"op": "ERASE",   "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},

            # MUL_READ: during CORE_BUSY block READ/PROGRAM/ERASE (on the die); allow SR
            {"when": {"op": "READ", "alias": "MUL", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},

            # SIN_READ: during CORE_BUSY block MUL_READ + PROGRAM + ERASE; allow SIN_READ & SR
            {"when": {"op": "READ", "alias": "SIN", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["ALIAS:MUL_READ", "BASE:PROGRAM", "BASE:ERASE"]},

            # DOUT: freeze all ops globally across its full duration
            {"when": {"op": "DOUT", "states": ["*"]}, "scope": "GLOBAL", "blocks": ["ANY"]},
        ]
    },

    # Obligation: READ â†’ DOUT
    "obligations": [
        {
            "issuer": "READ",
            "require": "DOUT",
            "window_us": {"kind": "normal", "mean": 6.0, "std": 1.5, "min": 1.0},
            "priority_boost": {"start_us_before_deadline": 2.5, "boost_factor": 2.0, "hard_slot": True},
        }
    ],

    # Topology (redefined): plane = block % planes
    "topology": {
        "dies": 1,
        "planes": 4,
        "blocks": 32,           # total blocks per die (not per plane)
        "pages_per_block": 16,
    },

    "export": {"tu_us": 0.01, "nop_symbol": "NOP", "wait_as_nop": True, "drift_correction": True},

    # Address initial state: -1=ERASED, -2=initial(not erased)
    "address_init_state": -1,
}

# --------------------------------------------------------------------------
# Alias mapping for policy/external naming
OP_ALIAS = {
    "SIN_READ":    {"base": "READ",    "fanout": ("eq", 1)},
    "MUL_READ":    {"base": "READ",    "fanout": ("ge", 2)},
    "SIN_PROGRAM": {"base": "PROGRAM", "fanout": ("eq", 1)},
    "MUL_PROGRAM": {"base": "PROGRAM", "fanout": ("ge", 2)},
    "SIN_ERASE":   {"base": "ERASE",   "fanout": ("eq", 1)},
    "MUL_ERASE":   {"base": "ERASE",   "fanout": ("ge", 2)},
}

# --------------------------------------------------------------------------
# Models
class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

class Scope(Enum):
    NONE=0; PLANE_SET=1; DIE_WIDE=2

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float
    bus: bool = False

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)

# --------------------------------------------------------------------------
# Utils
def sample_dist(d: Dict[str, Any]) -> float:
    k = d["kind"]
    if k == "fixed": return float(d["value"])
    if k == "normal":
        m, s, mn = d["mean"], d["std"], d.get("min", 0.0)
        v = random.gauss(m, s); return max(v, mn)
    if k == "exp": return random.expovariate(d["lambda"])
    raise ValueError(f"unknown dist kind: {k}")

def parse_hook_key(label: str):
    parts = label.split(".")
    if len(parts) >= 3: return parts[0], parts[1], parts[2]
    if len(parts) == 2: return parts[0], parts[1], None
    return None, None, None

def get_phase_dist(cfg: Dict[str,Any], hook_label: str):
    op, state, pos = parse_hook_key(hook_label)
    pc = cfg.get("phase_conditional", {})
    keys=[]
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    keys.append("DEFAULT")
    for key in keys:
        dist = pc.get(key)
        if dist and sum(dist.values())>0: return dist, key
    return None, None

def roulette_pick(dist: Dict[str, float], allow: set) -> Optional[str]:
    items=[(n,p) for n,p in dist.items() if n in allow and p>0]
    if not items: return None
    tot=sum(p for _,p in items); r=random.random()*tot; acc=0.0; pick=items[-1][0]
    for n,p in items:
        acc+=p
        if r<=acc: pick=n; break
    return pick

def resolve_alias(name: str) -> Tuple[str, Optional[Tuple[str,int]]]:
    if name in OP_ALIAS: return OP_ALIAS[name]["base"], OP_ALIAS[name]["fanout"]
    return name, None

def get_admission_delta(cfg: Dict[str,Any], hook_label: str, op_kind_name: str) -> float:
    _, state, _ = parse_hook_key(hook_label)
    adm = cfg.get("admission", {})
    if state and state in adm.get("phase_overrides", {}):
        return float(adm["phase_overrides"][state])
    if op_kind_name in adm.get("op_overrides", {}):
        return float(adm["op_overrides"][op_kind_name])
    return float(adm.get("default_delta_us", 0.3))

# --------------------------------------------------------------------------
# Builders
def build_operation(kind: OpKind, cfg_op: Dict[str, Any], targets: List[Address]) -> Operation:
    states=[]
    for s in cfg_op["states"]:
        states.append(StateSeg(name=s["name"], dur_us=sample_dist(s["dist"]), bus=bool(s.get("bus", False))))
    return Operation(kind=kind, targets=targets, states=states)

def get_op_duration(op: Operation) -> float:
    return sum(seg.dur_us for seg in op.states)

# --------------------------------------------------------------------------
# Address & Bus Managers (with block/plane redefinition + state rails)
class AddressManager:
    """
    v2 ìƒíƒœ ëª¨ë¸ (block-scoped):
    - addr_state_committed[(die, block)] : int  # last committed program page (-1=ERASED, -2=initial)
    - addr_state_future[(die, block)]    : int  # future after reservations
    - programmed_committed[(die)] : Set[(block, page)]
    - write_head[(die, plane)] : int  # block index assigned to plane (block % planes == plane)
    """
    def __init__(self, cfg: Dict[str, Any]):
        topo=cfg["topology"]; self.cfg=cfg
        self.dies=topo["dies"]; self.planes=topo["planes"]
        self.blocks=topo["blocks"]; self.pages_per_block=topo["pages_per_block"]

        self.available={(0,p):0.0 for p in range(self.planes)}  # per-plane availability time
        self.resv={(0,p):[] for p in range(self.planes)}        # per-plane reservations: (start,end,block)
        self.bus_resv: List[Tuple[float,float]] = []            # global bus reservations

        init_state = int(cfg.get("address_init_state", -1))
        self.addr_state_committed: Dict[Tuple[int,int], int] = {}
        self.addr_state_future:    Dict[Tuple[int,int], int] = {}
        self.programmed_committed: Dict[Tuple[int], Set[Tuple[int,int]]] = {(0,): set()}
        self.write_head: Dict[Tuple[int,int], int] = {}  # (die,plane)->block

        for b in range(self.blocks):
            self.addr_state_committed[(0,b)] = init_state
            self.addr_state_future[(0,b)]    = init_state
        for p in range(self.planes):
            self.write_head[(0,p)] = p  # first block of that plane stripe

    # ---- helpers for plane/block mapping ----
    def plane_of(self, block:int) -> int:
        return block % self.planes

    def iter_blocks_of_plane(self, plane:int):
        for b in range(plane, self.blocks, self.planes):
            yield b

    # ---- observations ----
    def available_at(self, die:int, plane:int)->float: return self.available[(die,plane)]

    def earliest_start_for_scope(self, die:int, scope: Scope, plane_set: Optional[List[int]]=None)->float:
        if scope==Scope.DIE_WIDE:
            planes=list(range(self.planes))
        elif scope==Scope.PLANE_SET and plane_set is not None:
            planes=plane_set
        else:
            planes=[plane_set[0]] if plane_set else [0]
        return max(self.available[(die,p)] for p in planes)

    def observe_states(self, die:int, plane:int, now_us: float):
        pgmable_blocks=0; readable_blocks=0
        for b in self.iter_blocks_of_plane(plane):
            fut=self.addr_state_future[(die,b)]
            com=self.addr_state_committed[(die,b)]
            if fut < self.pages_per_block-1: pgmable_blocks += 1
            if com >= 0: readable_blocks += 1
        total=max(1, len(list(self.iter_blocks_of_plane(plane))))
        def bucket(x):
            r=x/total
            return "low" if r<0.34 else ("mid" if r<0.67 else "high")
        pgmable_ratio=bucket(pgmable_blocks)
        readable_ratio=bucket(readable_blocks)
        plane_busy_frac="high" if self.available_at(die,plane)>now_us else "low"
        return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls":"host"},
                {"plane_busy_frac": plane_busy_frac})

    # ---- bus segments & gating ----
    def bus_segments_for_op(self, op: Operation)->List[Tuple[float,float]]:
        segs=[]; t=0.0
        for s in op.states:
            if s.bus: segs.append((t, t+s.dur_us))
            t+=s.dur_us
        return segs

    def bus_precheck(self, start_hint: float, segs: List[Tuple[float,float]])->bool:
        for (off0,off1) in segs:
            a0, a1 = quantize(start_hint+off0), quantize(start_hint+off1)
            for (s,e) in self.bus_resv:
                if not (a1<=s or e<=a0): return False
        return True

    def bus_reserve(self, start_time: float, segs: List[Tuple[float,float]]):
        for (off0,off1) in segs:
            self.bus_resv.append((quantize(start_time+off0), quantize(start_time+off1)))

    # ---- future/committed helpers ----
    def _next_page_future(self, die:int, block:int)->int:
        last = self.addr_state_future[(die,block)]
        return (last + 1) if last < self.pages_per_block-1 else self.pages_per_block

    def _find_block_for_page_future_on_plane(self, die:int, plane:int, target_page:int)->Optional[int]:
        for b in self.iter_blocks_of_plane(plane):
            if self._next_page_future(die,b) == target_page:
                return b
        return None

    def _first_erased_block_on_plane(self, die:int, plane:int)->Optional[int]:
        for b in self.iter_blocks_of_plane(plane):
            if self.addr_state_future[(die,b)] == -1:
                return b
        return None

    def _committed_pages_on_plane(self, die:int, plane:int)->Set[int]:
        return {p for (b,p) in self.programmed_committed[(die,)] if (b % self.planes)==plane}

    # ---- planner (non-greedy; degrade fanout; READ=committed, PROGRAM=future) ----
    def _random_plane_sets(self, fanout:int, tries:int, start_plane:int)->List[List[int]]:
        P=list(range(self.planes)); out=[]
        for _ in range(tries):
            cand=set(random.sample(P, min(fanout,len(P))))
            if start_plane not in cand and random.random()<0.6:
                if len(cand)>0: cand.pop()
                cand.add(start_plane)
            if len(cand)==fanout:
                key=tuple(sorted(cand))
                if key not in out: out.append(key)
        return [list(ps) for ps in dict.fromkeys(out)]

    def plan_multipane(self, kind: OpKind, die:int, start_plane:int, desired_fanout:int, interleave:bool)\
            -> Optional[Tuple[List[Address], List[int], Scope]]:
        if desired_fanout<1: desired_fanout=1
        tries=self.cfg["policy"]["planner_max_tries"]
        for f in range(desired_fanout, 0, -1):
            for plane_set in self._random_plane_sets(f, tries, start_plane):
                if kind==OpKind.READ:
                    commons=None
                    for pl in plane_set:
                        pages=self._committed_pages_on_plane(die, pl)
                        commons=pages if commons is None else (commons & pages)
                        if not commons: break
                    if not commons: continue
                    page=random.choice(sorted(list(commons)))
                    targets=[]
                    for pl in plane_set:
                        blks=[b for (b,p) in self.programmed_committed[(die,)] if p==page and (b%self.planes)==pl]
                        if not blks: targets=[]; break
                        targets.append(Address(die,pl,blks[0],page))
                    if not targets: continue
                    return targets, plane_set, Scope.PLANE_SET

                elif kind==OpKind.PROGRAM:
                    # Choose candidate pages: mode of next pages across write heads; or 0 if erased exists
                    nxts=[]
                    for pl in plane_set:
                        b_head=self.write_head[(die,pl)]
                        nx=self._next_page_future(die,b_head)
                        nxts.append(None if nx>=self.pages_per_block else nx)
                    candidates=[]
                    vals=[x for x in nxts if x is not None]
                    if vals:
                        freq={}
                        for v in vals: freq[v]=freq.get(v,0)+1
                        candidates.append(max(freq.items(), key=lambda x:x[1])[0])
                    if all(self._first_erased_block_on_plane(die,pl) is not None for pl in plane_set):
                        if 0 not in candidates: candidates.append(0)
                    if not candidates: continue

                    chosen=None
                    for page in candidates:
                        tlist=[]
                        ok=True
                        for pl in plane_set:
                            b_head=self.write_head[(die,pl)]
                            if self._next_page_future(die,b_head)==page:
                                b=b_head
                            else:
                                b=self._find_block_for_page_future_on_plane(die,pl,page)
                                if b is None: ok=False; break
                            tlist.append(Address(die,pl,b,page))
                        if ok: chosen=tlist; break
                    if not chosen: continue
                    return chosen, plane_set, Scope.DIE_WIDE

                elif kind==OpKind.ERASE:
                    targets=[]
                    for pl in plane_set:
                        b=self.write_head[(die,pl)]
                        if self.addr_state_future[(die,b)] == -1:
                            # pick a non-erased block on this plane if possible
                            found=None
                            for bb in self.iter_blocks_of_plane(pl):
                                if self.addr_state_future[(die,bb)] >= 0:
                                    found=bb; break
                            if found is not None: b=found
                        targets.append(Address(die,pl,b,None))
                    return targets, plane_set, Scope.DIE_WIDE

                elif kind==OpKind.SR:
                    return [Address(die, plane_set[0], plane_set[0], None)], plane_set[:1], Scope.NONE

        return None

    # ---- precheck/reserve/future/commit ----
    def precheck_planescope(self, kind: OpKind, targets: List[Address], start_hint: float, scope: Scope)->bool:
        start_hint=quantize(start_hint); end_hint=start_hint
        die=targets[0].die
        # time overlap check
        if scope==Scope.DIE_WIDE: planes={(die,p) for p in range(self.planes)}
        elif scope==Scope.PLANE_SET: planes={(t.die,t.plane) for t in targets}
        else: planes={(targets[0].die, targets[0].plane)}
        for (d,p) in planes:
            for (s,e,_) in self.resv[(d,p)]:
                if not (end_hint<=s or e<=start_hint): return False
        # address/plane consistency + rules
        for t in targets:
            if t.plane != (t.block % self.planes): return False  # consistency
            com=self.addr_state_committed[(t.die,t.block)]
            fut=self.addr_state_future[(t.die,t.block)]
            if kind==OpKind.PROGRAM:
                if t.page is None: return False
                if t.page != fut + 1: return False
                if t.page >= self.pages_per_block: return False
            elif kind==OpKind.READ:
                if t.page is None: return False
                if (t.block, t.page) not in self.programmed_committed[(t.die,)]: return False
            elif kind==OpKind.ERASE:
                pass
        return True

    def reserve_planescope(self, op: Operation, start: float, end: float):
        die=op.targets[0].die; start=quantize(start); end=quantize(end)
        if op.meta.get("scope")=="DIE_WIDE":
            planes=[(die,p) for p in range(self.planes)]
        elif op.meta.get("scope")=="PLANE_SET":
            planes=[(t.die,t.plane) for t in op.targets]
        else:
            planes=[(op.targets[0].die, op.targets[0].plane)]
        for (d,p) in planes:
            self.available[(d,p)]=max(self.available[(d,p)], end)
            self.resv[(d,p)].append((start,end,None))

    def register_future(self, op: Operation, start: float, end: float):
        for t in op.targets:
            key=(t.die,t.block)
            if op.kind==OpKind.PROGRAM and t.page is not None:
                self.addr_state_future[key] = max(self.addr_state_future[key], t.page)
                # advance write head if full
                nxt = self._next_page_future(t.die, t.block)
                if nxt >= self.pages_per_block:
                    er = self._first_erased_block_on_plane(t.die, t.plane)
                    if er is not None:
                        self.write_head[(t.die, t.plane)] = er
            elif op.kind==OpKind.ERASE:
                self.addr_state_future[key] = -1
                self.write_head[(t.die, t.plane)] = t.block

    def commit(self, op: Operation):
        for t in op.targets:
            key=(t.die,t.block)
            if op.kind==OpKind.PROGRAM and t.page is not None:
                self.addr_state_committed[key] = max(self.addr_state_committed[key], t.page)
                self.programmed_committed[(t.die,)].add((t.block, t.page))
            elif op.kind==OpKind.ERASE:
                self.addr_state_committed[key] = -1
                self.programmed_committed[(t.die,)] = {
                    pp for pp in self.programmed_committed[(t.die,)] if pp[0] != t.block
                }

# --------------------------------------------------------------------------
# Exclusion Manager (runtime blocking windows)
@dataclass
class ExclWindow:
    start: float; end: float
    scope: str
    die: Optional[int]
    tokens: Set[str]  # {"ANY"}, {"BASE:READ"}, {"ALIAS:MUL_READ"} ...

class ExclusionManager:
    def __init__(self, cfg: Dict[str,Any]):
        self.cfg = cfg
        self.global_windows: List[ExclWindow] = []
        self.die_windows: Dict[int, List[ExclWindow]] = {}

    def _state_windows(self, op: Operation, start: float, states: List[str]) -> List[Tuple[float,float]]:
        wins=[]; t=start
        segs=[]
        for s in op.states:
            segs.append((s.name, t, t+s.dur_us)); t+=s.dur_us
        if states==["*"]:
            return [(segs[0][1], segs[-1][2])]
        want=set(states)
        for name, s0, s1 in segs:
            if name in want: wins.append((s0,s1))
        return wins

    def _token_blocks(self, tok: str, op: Operation) -> bool:
        if tok=="ANY": return True
        if tok.startswith("BASE:"):
            base=tok.split(":")[1]
            return op.kind.name==base
        if tok.startswith("ALIAS:"):
            alias=tok.split(":")[1]
            if alias=="MUL_READ": return (op.kind==OpKind.READ and op.meta.get("arity",1)>1)
            if alias=="SIN_READ": return (op.kind==OpKind.READ and op.meta.get("arity",1)==1)
        return False

    def allowed(self, op: Operation, start: float, end: float) -> bool:
        for w in self.global_windows:
            if not (end<=w.start or w.end<=start):
                if any(self._token_blocks(tok, op) for tok in w.tokens): return False
        die=op.targets[0].die
        for w in self.die_windows.get(die, []):
            if not (end<=w.start or w.end<=start):
                if any(self._token_blocks(tok, op) for tok in w.tokens): return False
        return True

    def register(self, op: Operation, start: float):
        rules = self.cfg.get("constraints",{}).get("exclusions",[])
        die = op.targets[0].die
        for r in rules:
            when=r["when"]; if_op=when.get("op")
            if if_op != op.kind.name:
                if not (op.kind==OpKind.READ and if_op=="READ"):
                    continue
            alias_need = when.get("alias")
            if alias_need=="MUL" and not (op.meta.get("arity",1)>1): continue
            if alias_need=="SIN" and not (op.meta.get("arity",1)==1): continue
            states = when.get("states", ["*"])
            windows = self._state_windows(op, start, states)
            scope=r.get("scope","GLOBAL"); tokens=set(r.get("blocks",[]))
            for (s0,s1) in windows:
                w=ExclWindow(start=quantize(s0), end=quantize(s1), scope=scope,
                             die=(die if scope=="DIE" else None), tokens=tokens)
                if scope=="GLOBAL":
                    self.global_windows.append(w)
                else:
                    self.die_windows.setdefault(die,[]).append(w)

# --------------------------------------------------------------------------
# Obligation Manager (with stats)
@dataclass(order=True)
class _ObHeapItem:
    deadline_us: float
    seq: int
    ob: "Obligation" = field(compare=False)

@dataclass
class Obligation:
    id: int
    require: OpKind
    targets: List[Address]
    deadline_us: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg_list: List[Dict[str,Any]]):
        self.specs = cfg_list
        self.heap: List[_ObHeapItem] = []
        self._seq = 0
        self.assigned: Dict[int, Obligation] = {}
        self.stats = {"created":0, "assigned":0, "fulfilled":0, "fulfilled_in_time":0, "expired":0}

    def on_commit(self, op: Operation, now_us: float):
        # READ completion -> create DOUT obligation(s)
        for spec in self.specs:
            if spec["issuer"] == op.kind.name:
                self._seq += 1
                dt = sample_dist(spec["window_us"])
                ob = Obligation(
                    id=self._seq,
                    require = OpKind[spec["require"]],
                    targets = op.targets,  # plane-set op as one obligation
                    deadline_us = quantize(now_us + dt),
                    hard_slot = spec["priority_boost"].get("hard_slot", False),
                )
                heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=ob.id, ob=ob))
                self.stats["created"] += 1
                first=op.targets[0]
                print(f"[{now_us:7.2f} us] OBLIG  created: {op.kind.name} -> {ob.require.name} by {ob.deadline_us:7.2f} us, target(d{first.die},p{first.plane})")

    def pop_urgent(self, now_us: float, die:int, plane:int, horizon_us: float, earliest_start: float) -> Optional[Obligation]:
        if not self.heap: return None
        kept: List[_ObHeapItem] = []
        chosen: Optional[Obligation] = None
        now_us=quantize(now_us); earliest_start=quantize(earliest_start)
        while self.heap and not chosen:
            item = heapq.heappop(self.heap)
            ob=item.ob
            plane_list={a.plane for a in ob.targets}
            same_die=(ob.targets[0].die==die); same_plane=(plane in plane_list)
            in_horizon=((ob.deadline_us - now_us) <= max(horizon_us, 0.0)) or ob.hard_slot
            feasible=(earliest_start <= ob.deadline_us)
            if same_die and same_plane and in_horizon and feasible:
                chosen=ob; break
            kept.append(item)
        for it in kept: heapq.heappush(self.heap, it)
        return chosen

    def mark_assigned(self, ob: Obligation):
        self.assigned[ob.id] = ob
        self.stats["assigned"] += 1

    def mark_fulfilled(self, ob: Obligation, now: float):
        self.assigned.pop(ob.id, None)
        self.stats["fulfilled"] += 1
        if now <= ob.deadline_us:
            self.stats["fulfilled_in_time"] += 1

    def expire_due(self, now: float):
        kept=[]
        expired=0
        while self.heap and self.heap[0].deadline_us <= now:
            heapq.heappop(self.heap); expired+=1
        self.stats["expired"] += expired

# --------------------------------------------------------------------------
# Policy Engine (phase-conditional + admission gating + backoff)
class PolicyEngine:
    def __init__(self, cfg, addr: AddressManager, obl: ObligationManager, excl: ExclusionManager):
        self.cfg=cfg; self.addr=addr; self.obl=obl; self.excl=excl
        self.stats={"alias_degrade":0}

    def _score(self, op_name: str, phase_label: str, g: Dict[str,str], l: Dict[str,str]) -> float:
        w=self.cfg["weights"]["base"]["host"].get(op_name,0.0)
        w*=self.cfg["weights"]["g_state"]["pgmable_ratio"].get(g["pgmable_ratio"],1.0)
        w*=self.cfg["weights"]["g_state"]["readable_ratio"].get(g["readable_ratio"],1.0)
        w*=self.cfg["weights"]["g_local"]["plane_busy_frac"].get(l["plane_busy_frac"],1.0)
        near="MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w*=self.cfg["weights"]["g_phase"].get(op_name,{}).get(near,1.0)
        return w

    def _fanout_from_alias(self, base_name: str, alias_constraint: Optional[Tuple[str,int]], hook_label: str)->Tuple[int,bool]:
        fanout, interleave = get_phase_selection_override(self.cfg, hook_label, base_name)
        if alias_constraint:
            mode,val=alias_constraint
            if mode=="eq": fanout=val
            elif mode=="ge": fanout=max(fanout,val)
        return max(1,fanout), interleave

    def _exclusion_ok(self, op: Operation, die:int, plane_set: List[int], start_hint: float) -> bool:
        scope = Scope[op.meta["scope"]]
        start = self.addr.earliest_start_for_scope(die, scope, plane_set)
        dur = get_op_duration(op); end=quantize(start+dur)
        return self.excl.allowed(op, start, end)

    def _admission_ok(self, now_us: float, hook_label: str, kind_name: str, start_hint: float, deadline: Optional[float]=None) -> bool:
        adm = self.cfg.get("admission", {})
        delta = get_admission_delta(self.cfg, hook_label, kind_name)
        if deadline is not None:  # for obligations if bypass disabled
            delta = min(delta, max(0.0, deadline - now_us))
        return start_hint <= now_us + delta

    def propose(self, now_us: float, hook: PhaseHook, g: Dict[str,str], l: Dict[str,str], earliest_start: float) -> Optional[Operation]:
        die, hook_plane = hook.die, hook.plane

        # 0) obligations first (with optional admission bypass)
        ob=self.obl.pop_urgent(now_us, die, hook_plane, horizon_us=10.0, earliest_start=earliest_start)
        if ob:
            cfg_op=self.cfg["op_specs"][ob.require.name]
            op=build_operation(ob.require, cfg_op, ob.targets)
            op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=sorted({a.plane for a in ob.targets}); op.meta["arity"]=len(op.meta["plane_list"])
            op.meta["obligation"]=ob
            scope=Scope[op.meta["scope"]]; plane_set=op.meta["plane_list"]
            start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
            # admission bypass?
            bypass = self.cfg.get("admission",{}).get("obligation_bypass",True)
            admission_ok = True if bypass else self._admission_ok(now_us, hook.label, ob.require.name, start_hint, ob.deadline_us)
            if admission_ok and \
               self.addr.precheck_planescope(op.kind, op.targets, start_hint, scope) and \
               self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op)) and \
               self._exclusion_ok(op, die, plane_set, start_hint):
                op.meta["source"]="obligation"; op.meta["phase_key_used"]="(obligation)"
                return op
            # else: fallthrough to policy

        # 1) phase-conditional (alias keys allowed + SR)
        allow=set(list(OP_ALIAS.keys())+["READ","PROGRAM","ERASE","SR"])
        dist, used_key = get_phase_dist(self.cfg, hook.label)
        if dist:
            pick=roulette_pick(dist, allow)
            if pick:
                base, alias_const = resolve_alias(pick)
                kind=OpKind[base]
                # plan
                if kind==OpKind.SR:
                    plan=self.addr.plan_multipane(kind, die, hook_plane, 1, True)
                else:
                    fanout, interleave=self._fanout_from_alias(base, alias_const, hook.label)
                    plan=self.addr.plan_multipane(kind, die, hook_plane, fanout, interleave)
                    if not plan and fanout>1:
                        self.stats["alias_degrade"]+=1
                        plan=self.addr.plan_multipane(kind, die, hook_plane, 1, interleave)
                if plan:
                    targets, plane_set, scope=plan
                    cfg_op=self.cfg["op_specs"][base]; op=build_operation(kind, cfg_op, targets)
                    op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=plane_set; op.meta["arity"]=len(plane_set); op.meta["alias_used"]=pick
                    start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
                    # admission gating: near-future only
                    if not self._admission_ok(now_us, hook.label, base, start_hint):
                        return None
                    if self.addr.precheck_planescope(kind, targets, start_hint, scope) and \
                       self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op)) and \
                       self._exclusion_ok(op, die, plane_set, start_hint):
                        op.meta["source"]="policy.phase_conditional"; op.meta["phase_key_used"]=used_key; return op
            # else fallthrough to backoff

        # 2) backoff (READ/PROGRAM/ERASE/SR)
        cand=[]
        for name in ["READ","PROGRAM","ERASE","SR"]:
            s=self._score(name, hook.label, g, l)
            if s>0: cand.append((name,s))
        if not cand: return None
        tot=sum(s for _,s in cand); r=random.random()*tot; acc=0.0; pick=cand[-1][0]
        for name,s in cand:
            acc+=s
            if r<=acc: pick=name; break
        kind=OpKind[pick]
        if kind==OpKind.SR:
            plan=self.addr.plan_multipane(kind, die, hook_plane, 1, True)
        else:
            fanout, interleave=get_phase_selection_override(self.cfg, hook.label, pick)
            plan=self.addr.plan_multipane(kind, die, hook_plane, fanout, interleave)
        if not plan: return None
        targets, plane_set, scope=plan
        cfg_op=self.cfg["op_specs"][pick]; op=build_operation(kind, cfg_op, targets)
        op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=plane_set; op.meta["arity"]=len(plane_set)
        start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
        # admission gating
        if not self._admission_ok(now_us, hook.label, pick, start_hint):
            return None
        if not (self.addr.precheck_planescope(kind, targets, start_hint, scope) and \
                self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op)) and \
                self._exclusion_ok(op, die, plane_set, start_hint)):
            return None
        op.meta["source"]="policy.score_backoff"; op.meta["phase_key_used"]="(score_backoff)"; return op

# --------------------------------------------------------------------------
# Selection overrides
def get_phase_selection_override(cfg: Dict[str,Any], hook_label: str, kind_name: str):
    op, state, pos = parse_hook_key(hook_label)
    po=cfg.get("selection",{}).get("phase_overrides",{})
    keys=[]
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    for k in keys:
        val=po.get(k)
        if val:
            return int(val.get("fanout",1)), bool(val.get("interleave",True))
    dflt=cfg.get("selection",{}).get("defaults",{}).get(kind_name,{"fanout":1,"interleave":True})
    return int(dflt.get("fanout",1)), bool(dflt.get("interleave",True))

# --------------------------------------------------------------------------
# Scheduler
def _addr_str(a: Address)->str: return f"(d{a.die},p{a.plane},b{a.block},pg{a.page})"

class Scheduler:
    def __init__(self, cfg, addr: AddressManager, spe: PolicyEngine, obl: ObligationManager, excl: ExclusionManager):
        self.cfg=cfg; self.addr=addr; self.SPE=spe; self.obl=obl; self.excl=excl
        self.now=0.0; self.ev=[]; self._seq=0
        self.stat_propose_calls=0; self.stat_scheduled=0
        self._push(0.0, "QUEUE_REFILL", None)
        for plane in range(self.addr.planes):
            self._push(0.0, "PHASE_HOOK", PhaseHook(0.0, "BOOT.START", 0, plane))

    def _push(self, t: float, typ: str, payload: Any):
        heapq.heappush(self.ev, (quantize(t), self._seq, typ, payload)); self._seq+=1

    def _start_time_for_op(self, op: Operation) -> float:
        die=op.targets[0].die
        scope=Scope[op.meta.get("scope","PLANE_SET")]
        plane_set=[a.plane for a in op.targets]
        t_planes=self.addr.earliest_start_for_scope(die, scope, plane_set)
        return quantize(max(self.now, t_planes))

    def _label_for_read(self, op: Operation)->str:
        if op.kind!=OpKind.READ: return op.kind.name
        return "MUL_READ" if op.meta.get("arity",1)>1 else "SIN_READ"

    def _schedule_operation(self, op: Operation):
        start=self._start_time_for_op(op); dur=get_op_duration(op); end=quantize(start+dur)
        # reserve plane scope + bus + register exclusions + future update
        self.addr.reserve_planescope(op, start, end)
        self.addr.bus_reserve(start, self.addr.bus_segments_for_op(op))
        self.excl.register(op, start)
        self.addr.register_future(op, start, end)

        # obligation assignment stats
        if "obligation" in op.meta:
            self.obl.mark_assigned(op.meta["obligation"])

        # push events
        self._push(start, "OP_START", op); self._push(end, "OP_END", op)

        # hooks (READ â†’ SIN_READ/MUL_READ label)
        label_op=self._label_for_read(op)
        for t in op.targets:
            cur=start
            for s in op.states:
                self._push(cur,               "PHASE_HOOK", PhaseHook(cur,               f"{label_op}.{s.name}.START", t.die, t.plane))
                if s.name=="CORE_BUSY":
                    self._push(cur + s.dur_us*0.5, "PHASE_HOOK", PhaseHook(cur + s.dur_us*0.5, f"{label_op}.{s.name}.MID",   t.die, t.plane))
                self._push(cur + s.dur_us,    "PHASE_HOOK", PhaseHook(cur + s.dur_us,    f"{label_op}.{s.name}.END",   t.die, t.plane))
                cur += s.dur_us

        first=op.targets[0]
        print(f"[{self.now:7.2f} us] SCHED  {op.kind.name:7s} arity={op.meta.get('arity')} scope={op.meta.get('scope')} start={start:7.2f} end={end:7.2f} 1st={_addr_str(first)} src={op.meta.get('source')} alias={op.meta.get('alias_used')}")

        self.stat_scheduled+=1

    def run_until(self, t_end: float):
        t_end=quantize(t_end)
        while self.ev and self.ev[0][0] <= t_end:
            self.now, _, typ, payload = heapq.heappop(self.ev)

            # expire obligations due
            self.obl.expire_due(self.now)

            if typ=="QUEUE_REFILL":
                for plane in range(self.addr.planes):
                    self._push(self.now, "PHASE_HOOK", PhaseHook(self.now, "REFILL.NUDGE", 0, plane))
                self._push(self.now + self.cfg["policy"]["queue_refill_period_us"], "QUEUE_REFILL", None)

            elif typ=="PHASE_HOOK":
                hook: PhaseHook = payload
                earliest_start=self.addr.available_at(hook.die, hook.plane)
                g,l=self.addr.observe_states(hook.die, hook.plane, self.now)
                self.stat_propose_calls+=1
                op=self.SPE.propose(self.now, hook, g, l, earliest_start)
                if op: self._schedule_operation(op)

            elif typ=="OP_START":
                op: Operation=payload; first=op.targets[0]
                print(f"[{self.now:7.2f} us] START  {op.kind.name:7s} arity={op.meta.get('arity')} target={_addr_str(first)}")

            elif typ=="OP_END":
                op: Operation=payload; first=op.targets[0]
                print(f"[{self.now:7.2f} us] END    {op.kind.name:7s} arity={op.meta.get('arity')} target={_addr_str(first)}")
                self.addr.commit(op)
                # obligation fulfillment stats
                if "obligation" in op.meta:
                    self.obl.mark_fulfilled(op.meta["obligation"], self.now)
                self.obl.on_commit(op, self.now)

        # final stats
        print(f"\n=== Stats ===")
        print(f"propose calls : {self.stat_propose_calls}")
        print(f"scheduled ops : {self.stat_scheduled}")
        if self.stat_propose_calls:
            print(f"accept ratio  : {100.0*self.stat_scheduled/self.stat_propose_calls:.1f}%")
        s=self.obl.stats
        rate=(100.0*s["fulfilled_in_time"]/s["created"]) if s["created"] else 0.0
        print(f"obligations   : created={s['created']} assigned={s['assigned']} fulfilled={s['fulfilled']} in_time={s['fulfilled_in_time']} expired={s['expired']} success={rate:.1f}%")

# --------------------------------------------------------------------------
# Main
def main():
    random.seed(CFG["rng_seed"])
    addr=AddressManager(CFG); excl=ExclusionManager(CFG)
    obl=ObligationManager(CFG["obligations"])
    spe=PolicyEngine(CFG, addr, obl, excl)
    sch=Scheduler(CFG, addr, spe, obl, excl)
    print("=== NAND Sequence Generator (P5: stats + admission + block/plane redefined) ===")
    sch.run_until(CFG["policy"]["run_until_us"])
    print("=== Done ===")

if __name__=="__main__":
    main()

```

í¬í•¨ëœ í•µì‹¬ ë³€ê²½ì  ìš”ì•½
- í†µê³„: ObligationManager.statsë¡œ created/assigned/fulfilled/fulfilled_in_time/expired ì§‘ê³„.
  - ìŠ¤ì¼€ì¤„ ì‹œ mark_assigned, ì»¤ë°‹ ì‹œ mark_fulfilled, ì´ë²¤íŠ¸ ë£¨í”„ë§ˆë‹¤ expire_due.
  - ì¢…ë£Œ ì‹œ ì„±ê³µë¥ (fulfilled_in_time / created) ì¶œë ¥.
- Admission ê²Œì´íŒ…: admission ì„¤ì •ì— ë”°ë¼ í˜„ì¬ ì‹œê°+Î” ì´ë‚´ ì‹œì‘ ê°€ëŠ¥í•œ ì˜¤í¼ë§Œ ìŠ¹ì¸.
  - phase_overrides(ì˜ˆ: CORE_BUSY: 0.05us) â†’ CORE_BUSY ë™ì•ˆ SR ê°™ì€ ì¦‰ì‹œì„± ë†’ì€ ì—°ì‚° ìœ„ì£¼ë¡œ í˜ëŸ¬ê°€ë„ë¡ ì œì–´.
  - Obligationì€ ê¸°ë³¸ bypass(í•„ìš” ì‹œ obligation_bypass: falseë¡œ ë°”ê¿” ì œí•œ ê°€ëŠ¥).
- ë¸”ë¡/í”Œë ˆì¸ ì¬ì •ì˜: plane = block % planes
  - í† í´ë¡œì§€: planes, blocks, pages_per_blockë¡œ ë‹¨ìˆœí™”.
  - ìƒíƒœ ë ˆì¼ í‚¤ë¥¼ (die, block)ë¡œ ì¬ì„¤ê³„.
  - READ í”Œë˜ë‹ì€ ì»¤ë°‹ëœ í˜ì´ì§€ë§Œ ê°€ì‹œ, PROGRAMì€ future railë¡œ ë‹¤ìŒ í˜ì´ì§€ ì •í•© ë³´ì¥.
  - write_head[(die, plane)]ë¡œ plane ìŠ¤íŠ¸ë¼ì´í”„ ë‚´ ë¸”ë¡ í¬ì¸í„° ê´€ë¦¬.
- ë©€í‹°í”Œë ˆì¸/ì œì•½/ë²„ìŠ¤: ê¸°ì¡´ ì˜ë¯¸ë¡ ì„ ìœ ì§€(READ planeâ€‘set ì ìœ , PROGRAM/ERASE dieâ€‘wide CORE_BUSY, DOUT freeze, SR anywhere, Bus gating).

í•„ìš”í•˜ì‹œë©´, admission/phase_conditional/selectionì˜ ìˆ˜ì¹˜ë¥¼ ë” ê³µê²©ì ìœ¼ë¡œ(ë˜ëŠ” ë³´ìˆ˜ì ìœ¼ë¡œ) íŠœë‹í•œ í”„ë¡œíŒŒì¼ë„ ë§Œë“¤ì–´ ì¤„ê²Œìš”.
