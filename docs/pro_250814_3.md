---
title: ChatGPT Export
exported_at: 2025-08-14_05-41
---

## 👤 User

아래 글은 NAND operation sequence generation 을 위해 draft 로 작성한 design 문서야. 이 문서를 작성한 목적은 파이썬 코드 구현을 위해 system 설계를 어떻게 해야할 지 검토하기 위해서 작성했어. 이 문서의 표현을 가다듬고 구조화해서, 실제 구현에 도움이 되게끔, 그리고 구현 상 발생하는 risk 를 명시해서 그걸 최소화 하려고 해. 아래 문서를 위의 배경에 맞게 재작성 해줘.
————
**Symbols : 설명이 필요한 부분**
-. StateSeq : times, states 를 저장하여 시간대별 연속적인 nand state 를 저장하는 data class
-. Operation : Operation data class. StateSeq 를 포함함
-. OperSeq : Operation instance 의 배열
-. HostReq : host 의 요청 data class. 이것을 해석하여 OperSeq 생성
-. scheduler
    -. 기능 : nand 동작을 실제로 스케쥴링 해서 긴 nand 동작 seq 를 생성
    -. busytable : Operation 을 등록하면 시간대별 연속적인 nand state 가 저장됨.
    -. historylist : Operation 을 등록하면 시간대별 Operation 의 점유율 저장
    -. timer : Operation 이 실제 수행됐을 때, 동작이 끝날때까지 남은 시간 저장. clock 이 앞으로 움직이면 차감됨.
-. Address manager
    -. 기능 : nand 의 erase, pgm, read 를 수행하기 위해 block 이 어떤 상태인지 확인하고, 요청이 오면 동작 가능한 address 를 리턴.
    -. addrstates : address 에서 nand 의 pgm 된 상태를 나타냄
    -. -3 : badblock, can’t be used
    -. -2 : initial, not erased
    -. -1 : ERASED
    -. 0~pagesize-1 : 마지막 pgm 된 page address 값
    -. get_adds_val : address 에 저장된 addrstates 값을 반환.
    -. get_pgmable : nand 전체 address 에서 pgm 가능한 ddress 반환
    -. get_readable : nand 전체 address 에서 read 가능한 address 반환
-. Queue mananger
    -. 기능 : queue list 를 우선 순위에 맞춰 정렬 및 queue 의 값을 반환
    -. queue list : host 또는 nand 가 요청한 Operation 을 저장하는 data type
    -. dependency check : nand 는 target address 에 대해서 erase -> pgm -> read 순으로 진행되어야 하고, Operation sequence 가 그 규칙에 맞는지 확인하는 기능

**Operation 을 NAND busytable 에 추가하는 순서**
1. scheduler 가 Queue manager 에게 요청 사항 list 가 남아 있는지 확인
2. Queue manager 는 우선 순위를 업데이트 하고, 첫번째 HostReq 를 scheduler 에게 전달
3. scheduler 는 HostReq 를 HostReq to OperSeq 에 인자로 넘겨서 OperSeq 를 반환 받음
4. OperSeq 는 scheduler 내부 queue list 에 (Oper1, until_time1), (Oper2, until_time2), … 에 저장해두고, Operation 은 busytable, historylist 에 추가. until_time 은 timer 에 할당하고 clock 이 움직이는 거에 따라 차감하고, until_time1 이 0 이 되면 scheduler 는 Operation2 를 추가하고, until_time2 를 timer 에 할당한다.
5. until_time 이 계산되기 위해서 StateSeq 나, Operation class 에서 times 배열을 보고 until_time 을 계산해야 할 듯
6. scheduler 는 HostReq 로 요청한 Operation : ophost 과, scheduler 자체적으로 샘플링한 Operation : opnand 중 선택해야 한다.

**self thoughts**
-. 어느 시점에 req_queue 를 들여다 봐야 하는가?
-. sampling 은 어느 시점에 host, nand 중 어디에서 해야 하는가?
-. host 요청이 무한히 쌓이는 경우 nand 의 동작을 수행할 수 없기 때문에, host 의 요청을 적절히 제한하는 메커니즘 필요. queue list 의 크기를 제한하면 가능. queue list 를 들여다 보는 주체는 scheduler
-. host 가 요청한 operation 과 nand 가 자체 수행하는 operation 은 우선 순위가 존재. host 의 요청이 최우선이다. 현재 수행되는 operation 이 host 의 요청인지 구분할 수 있는 데이터나 구조 필요-. host 의 명령에 의한 operation 도 우선순위 존재. pgm < read 이며, pgm 을 수행하려고 했지만, nand address manager 가 pgm 할 block 이 없다고 하면, read (to assign a new block) > dout > erase > pgm (new) > pgm (target) 순으로 수행해야 한다. (엄청난 latency 발생). 이런 이유로 nand 가 현재 pgmable block 이 어느 정도 있는지 tracking 하면서 garbage collection 용 operation 을 추가해야 함.
-. nand 가 자체적으로 수행하는 OperSeq 는
-. Garbage Collection : pgm 가능한 block 을 만듦
    -. invalid ratio in a block 을 모니터링 해서 수행
    -. read > dout > pgm (new) > read > dout > pgm (new) > … > erase
-. Read Reclaim : 오래된 block 을 읽어보며 failbit 수준 모니터링
    -. read > dout > read > dout > … > read dout
-. Garbage Collection, Read Reclaim 을 추가할 것인지는 option 으로 관리
-.결국 host, nand 모두 생성해야 할 data class 는 OperSeq 이고, Host 의 요청에 대응하는 것은 nand 가 랜덤한 target address 에 할당하면 되고, nand 는 어떤 address 에 어떤 동작을 했다는 것을 참고한 target address 를 생성하는게 자연스럽다. 하지만 그것을 고려한 target address 샘플링 로직을 넣진 않겠다.
-. nand 가 Operation 을 추가할 때, 바로 확인 가능한 동작(SR, reset 등) 은 바로 추가하면 되고, 그렇지 않은 동작은 지금 수행되는 동작을 기다리든지(만약 step clock sampling 이라면), 아니면 끝나는 시점을 계산해서 그 때 추가하게 한다. 이 때 die, plane 의 busytable 을 모두 참고해서 가장 빠른 시점을 기준으로 한 time 을 샘플링 하여 추가.
-. 동작 예약은 plane 당 하나만 busytable 에 예약 가능하며 미래 시점을 샘플링 해서 예약. 예약 시 queue list 에 넣어두고, 실행은 현재 시간 기준으로 한다. 실행의 의미는 예약된 동작이 queue list 에서 빠지기 때문에 다음 동작 예약이 가능해 진다. 실행 시간은 step clock 단위로 하는 게 아니라 예약된 동작이 시작되는 시점으로 clock 을 옮겨서 실행. 그래야 seq vs. patt 간 mismatch 가 없다.
-. queue list 에 있는 동작들 사이에서는 순서상 dependency check 을 만족해야 한다. 여기서 host, nand 간 우선순위 충돌이 일어나는 부분인데, 구체적 예는 다음과 같다
-. host 는 read 요청을 했고, nand 는 해당 block 을 erase 하고, 다른 block 을 pgm 하려고 한다 : read 요청을 queue list 에서 우선순위로 해서 sorting 을 하고, erase 동작 이후의 동작은 나중으로 한다. 이 경우 nand 는 이미 address manager 로 해당 block 을 ERASE 상태로 변경했기 때문에, 해당 block address 에 접근하지 못하여 address manager 의 get_adds_val 값이 invalid 하게 나온다. (scheduler 가 host 의 read 요청을 처리할 때 get_adds_val 값과 target address 를 비교하여 우선 순위 sorting trigger 를 발동 시켜야함).
-. host 의 요청은 항상 address manager 의 컨펌을 받고, dependency check 을 queue list 에 대해서 수행하고(list 의 가장 처음에 추가된다고 하면 dependency check 를 수행할 필요가 없다).
-. read operation 이 순차적으로 예약되어 있으면, 순서를 조정해 overall read latency 를 개선하기 위해서 concurrent active plane 이 최대가 되게끔 순서를 조정해야 한다. 만약 read 중간에 pgm, erase 가 껴있으면, read 를 앞에 최대한 배치를 한다. 배치 이후에는 dependency check 를 해서 문제가 없는지 확인이 필요하다. 그러기 위해서는 address manager 가 read 의 이동 전에 dependency check 를 우선 수행해야 하고, 만약 불가능하다고 하면 이동하지 않아야 한다. 만약 OperSeq 로 연속적인 operation 을 queue 에 추가할 때, 이것은 dependency 가 있는 Seq 이니 이동이 불가하다는 정보를 저장해 둔다면, 사전에 방지할 수 있다. 하지만, 별개로 추가한 operation 이 dependency 가 형성되어 버렸다면, 이를 사전에 알지 못하므로 dependency check 를 진행해야 한다. 또 하나 다른 문제는, address manager 가 validity check 를 시점을 옮겨 가며 해야 한다. 옮기기 전과, 옮긴 후에 addrstates 값이 다르기 때문에 그걸 다루는 로직이 필요하게 된다.

**Decisions**
-. system 의 역할을 정의 필요
    -. nand 의 address manager 를 통해 get_pgmable(), get_readable() 을 수행하며, 전체 address 에서 pamgable, readable 가 충분하도록 비율을 조절해야 한다.
    -. host 요청에 의한 HostReq 를 OperSeq 로 변환 후 scheduler 에 추가
-. Garbage Collection 
    -. 목적 : pgm block 가능한 block 을 만드는 것으로 한정
    -. system 이 주기적으로 address manager 에게 get_pgmable() 을 전달받아서 Erase 용 OperSeq 를 여러개 추가

**Critial Questions**
-. Clock 은 어떤 step 으로 움직여야 하는가? step 형식 or likelyhood sampling?
-. die 샘플링은 어떠해야 하는가?
-. plane interleave 를 적극적으로 하려면 어떻게 해야 하는가?
-. host 와 nand 의 요청 동작 사이의 우선 순위는 어떤 식으로 설정, 또는 조정해야 하는가?

## 🤖 Assistant

NAND Operation Sequence Generation — 구현 지향 설계 리라이트 (v0.2)
1) 목적과 범위
- 목적: 이 설계는 NAND 동작 시퀀스를 파이썬 코드로 구현하기 위한 실무 지침이다. 구현에 필요한 데이터 모델, 스케줄링 방식, 우선순위 규칙, 의존성 검사, GC/Read-Reclaim 정책, 리스크와 완화책을 명료하게 정리한다.
- 비범위: 실제 물리 지연 상세치(베너, 셀 타입별 μs/ns 단위 파라미터)는 외부 테이블로 두고, 본 문서는 시뮬레이터의 메커니즘에 집중한다.

2) 시스템 개요
구성요소와 책임:
- Scheduler: 이벤트 기반(Discrete-Event)으로 동작을 예약/실행하여 긴 NAND 시퀀스를 생성. BusyTable/History/Timer 관리.
- AddressManager: 블록/페이지의 상태 추적, pgm/read 가능한 주소 질의 제공, 예약/커밋/롤백 지원.
- QueueManager: Host/NAND(유지보수) 요청을 한데 모아 우선순위 정렬 및 디스패치.
- HostReq → OperSeq 변환기: 호스트 요청을 실제 Operation 시퀀스(OperSeq) 로 변환.
- StateSeq/Operation/OperSeq 데이터 모델: 시간축과 상태를 일관되게 기록/검증.

핵심 원칙
- 이벤트 점프형 시뮬레이션: step clock로 1틱씩 전진하지 않고, 다음 이벤트 시각으로 시간을 점프해 성능/정합성을 확보.
- 예약(Reservation) → 의존성/자원확정(Validation) → 커밋(Commit) 3단계 프로토콜로 경합/레이스 완화.
- 명시적 우선순위: Host > Read계열 > DOUT > Erase > Program(신규) > Program(타겟) 기본 정책 + 기아 방지.

3) 데이터 모델 (Python 스켈레톤)

```python
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Tuple, Optional, Dict, Any
import heapq
from collections import deque

class AddrState(Enum):
    BAD_BLOCK = auto()     # 사용불가
    INITIAL   = auto()     # 초기화 전(미소거)
    ERASED    = auto()     # 소거 완료
    PGM_LAST  = auto()     # 마지막 프로그램된 page 인덱스 보유

@dataclass(frozen=True)
class Address:
    die: int
    plane: int
    block: int
    page: Optional[int] = None

class OpKind(Enum):
    READ = auto()
    DOUT = auto()
    PROGRAM = auto()
    ERASE = auto()
    SR = auto()            # status read
    RESET = auto()

@dataclass
class StateSeq:
    times: List[int]          # 상대/절대 시각 배열
    states: List[str]         # "idle/busy/dma/..." 등 태그

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]             # 단일 또는 인터리브 대상
    timeline: StateSeq                 # 상대시간 단계 (issue->busy->dma...)
    movable: bool = True               # 재배치 허용 여부(의존성 있는 묶음은 False)
    meta: Dict[str, Any] = field(default_factory=dict)

@dataclass
class OperSeq:
    ops: List[Operation]

@dataclass
class HostReq:
    kind: OpKind
    size: int                           # 논리적 크기 / 페이지 수
    policy: Dict[str, Any] = field(default_factory=dict)  # QoS 등

@dataclass
class BusySlot:
    start: int
    end: int
    op: Operation

@dataclass
class PlaneState:
    available_at: int = 0               # 이 평면이 비는 시각
    timeline: List[BusySlot] = field(default_factory=list)

```

4) Scheduler 설계
4.1 이벤트 기반 루프
- 이벤트 힙(최소 힙): (event_time, event_type, payload) 형태로 관리.
- 현재 시각 now 를 다음 이벤트 시각으로 점프.
- Timer/History 필요 시 Event로 모델링:
  - OP_START, OP_END, QUEUE_REFILL, GC_TICK, READ_RECLAIM_TICK 등.

4.2 BusyTable/History/Timer
- BusyTable: die/plane 단위로 available_at + timeline(디버깅/리포트용).
- HistoryList: 주기적으로 Utilization/큐 길이/우선순위별 대기시간을 샘플링.
- Timer: 개별 관리 대신 이벤트 스케줄링 시각 자체가 타이머 역할.

4.3 Operation 추가 절차 (정제)
1. QueueManager 에게 다음 할당 요청
2. 첫 요소(또는 룩어헤드 재배치 결과)를 HostReq→OperSeq 변환
3. Reservation: AddressManager에 대상 주소 잠금/예약 (TTL 포함)
4. Validation:
  - 의존성(erase→pgm→read) 및 Plane Busy 충돌 검사
  - 가능 시 각 plane의 start = max(now, available_at) 계산
5. Commit & Schedule:
  - BusySlot 확정, OP_START/OP_END 이벤트 push
  - Address 상태 변화는 END 시점에 커밋(중간 실패 대비)
6. Completion:
  - OP_END에서 AddressManager에 상태커밋, BusyTable/History 반영
  - 후속 의존 Operation이 있다면 즉시 Reservation 시도

기존 “until_time”은 Operation.timeline의 상대시간 합으로부터 END 절대시각을 계산하여 이벤트로 관리한다.

5) AddressManager 설계
5.1 상태 표현
- 블록 단위 상태: BAD_BLOCK, INITIAL, ERASED, PGM_LAST(page_idx)
- Enum + 구조체로 마이그레이션(기존 -3/-2/-1/0~pagesize-1 숫자치 지양)
- 조회 함수:
  - get_addr_state(addr) -> AddrState or (PGM_LAST, page_idx)
  - get_pgmable() -> Iterable[Address(block-level)]
  - get_readable() -> Iterable[Address(page-level)]

5.2 예약/확정/롤백
- reserve(addr, op_kind, until_time, token) -> bool
- commit(token) / rollback(token)
- 동일 주소에 대한 동시 예약 방지 및 TTL 만료 시 자동 롤백.
- 가비지 컬렉션과의 경합을 피하려면:
  - Host READ 대상 블록은 GC가 예약 불가(또는 우선순위 낮춤)
  - GC는 대체 가능 블록만 대상(유효비트/invalid ratio 기준)

6) QueueManager 설계
6.1 큐 구조
- HostQueue (높은 우선순위), NandMaintQueue(GC/Read-Reclaim) (낮은 우선순위) 분리
- Unified View: peek(n) 시 두 큐를 합쳐 정책함수로 정렬

6.2 우선순위 정책(기본)
1. Host 요청 우선
2. Host 내부: READ > DOUT > ERASE > PROGRAM(new) > PROGRAM(target)
3. 유지보수(NAND 자체): 임계치 기반 가중
  - pgmable_ratio < low_watermark 이면 GC 점수↑
  - 오래된 블록의 에이징/FailBit 위험 시 Read-Reclaim 점수↑
4. 기아 방지: 대기시간에 비례 가중치 추가(에이징)

6.3 의존성 검사
- 큐 삽입 시 1차 검사, 스케줄 직전 2차 검사
- movable=False 인 연속 OperSeq 묶음은 재배치 금지
- 재배치 하려면 사전 의존성 그래프로 사이클 없는지 확인

7) HostReq → OperSeq 변환
- READ: READ(+optional DOUT) / 인터리브 가능한 다중 페치
- PROGRAM: 대상 블록/페이지 할당(없으면 GC 트리거 또는 읽기→신규할당)
- ERASE: 블록 단위
- 결과는 Operation 리스트(OperSeq) 로 반환하되,
  - 서로 강하게 의존하는 묶음은 movable=False로 플래그

8) 재배치(리드 전진) & 인터리브
- Look-ahead 윈도(예: 다음 K개)에서 READ를 앞당겨 plane 병렬성 최대화
- 재배치 전후에 AddressManager로 유효성/의존성 재검증
- 인터리브는 (die, plane) 가 다른 타겟을 동일 시각에 issue하여 BUSY 중첩 최댓화

9) GC & Read-Reclaim 정책
9.1 Garbage Collection
- 목적 한정: pgm 가능한 블록 확보
- 트리거: pgmable_ratio < LOW_WATERMARK 또는 주기적 점검 이벤트
- 시퀀스 예: read -> dout -> program(new) -> ... 반복 후 erase
- 옵션화: enable_gc: bool / 정책 파라미터 구성

9.2 Read-Reclaim
- 목적: 에이징/FailBit 위험 블록을 선제 복구/이전
- 트리거: 블록 ‘나이’, 에러 통계, 주기적 스캔
- 옵션화: enable_read_reclaim: bool

10) 구현 절차(이벤트 라이프사이클)

```
[Scheduler.tick()]
  ├─ now = pop(next_event_time)
  ├─ process(event)
  ├─ if QUEUE_REFILL or idle:
  │    ├─ req = QueueManager.peek_and_select()
  │    ├─ operseq = Req2Seq(req)
  │    ├─ for op in operseq:
  │    │    ├─ AddressManager.reserve(...)
  │    │    ├─ Dependency/Busy validation
  │    │    └─ schedule OP_START/OP_END (commit at END)
  └─ push next QUEUE_REFILL / GC_TICK / RECLAIM_TICK as needed

```

11) 구성/파라미터(예시 기본값)
- LOOKAHEAD_K = 8 (재배치 대상)
- LOW_WATERMARK_PGMABLE = 0.05, HIGH_WATERMARK_PGMABLE = 0.12
- AGEING_WEIGHT_ALPHA = 0.01 (대기시간 가중)
- RESERVATION_TTL = operation_duration * 1.5
- MAX_QUEUE_SIZE = 10_000 (호스트 폭주 억제)

12) 관측/로깅
- 메트릭: 큐 길이, 우선순위별 대기시간, plane utilization, GC 빈도, 재배치 성공률, 롤백 횟수
- 트레이스: Operation 단위 예약→커밋→완료 타임라인
- 스냅샷: AddressState 압축 스냅샷(주기/사건 기반)

13) 리스크 & 완화책

| 리스크 | 설명 | 완화책 |
| --- | --- | --- |
| 우선순위 역전 | Host READ가 GC에 막힘 | Reservation에서 Host 대상 블록은 GC 예약 불가. 에이징 가중치로 Host 먼저 통과 |
| 주소 정합성 붕괴 | GC가 먼저 ERASE 상태로 바꾸어 Host READ invalid | 커밋 지연(END에서만 AddressState 변경), Host 예약시 강한 락 |
| 의존성 깨짐(재배치) | 읽기 순서 당김 후 종속성 위반 | movable=False 묶음, 재배치 전후 더블체크 |
| 스타베이션 | 유지보수 영원히 못 돌림 | Low watermark 하회 시 유지보수에 보너스 점수, 주기적 강제 슬롯 |
| 이벤트 드리프트 | step clock와 패턴 미스 | 이벤트 점프 모델 채택, 상대시간→절대시간 변환 일원화 |
| 동시 예약 충돌 | 여러 스레드/모듈이 동일 주소 예약 | AddressManager 토큰 기반 예약, TTL과 롤백 |
| 메모리 팽창 | History/Timeline 누적 | 롤링 윈도우 유지, 스냅샷 압축 저장 |
| 성능 병목 | 10만+ 전이 테이블 | 이벤트 힙, O(log N) 스케줄, 재배치 윈도 제한 |

14) 테스트 전략(필수 시나리오)
- 단위: Address 상태 전이(ERASE→PGM→READ), 예약/커밋/롤백, 의존성 검사
- 통합: Host 폭주 + GC 동시 동작, 재배치 유효성, 인터리브 효율성
- 부하: 수십만 이벤트 처리 시간, 메모리 상한
- 회귀: 동일 Seed 재현성(난수 시드 고정)

15) 파일 구조 제안

```
nandsim/
  core/
    scheduler.py
    queue_manager.py
    address_manager.py
    models.py
    req2seq.py
  policy/
    priority.py
    gc.py
    reclaim.py
  sim/
    runner.py           # main loop + config
  tests/
    test_address.py
    test_depcheck.py
    test_scheduler.py
    test_gc_reclaim.py

```

16) 의사코드 스니펫
16.1 스케줄러 핵심

```python
class Scheduler:
    def __init__(self, qm, am, config):
        self.now = 0
        self.events = []  # heap
        self.qm = qm
        self.am = am
        self.config = config
        heapq.heappush(self.events, (0, "QUEUE_REFILL", None))

    def run_until(self, t_end):
        while self.events and self.events[0][0] <= t_end:
            self.now, ev, payload = heapq.heappop(self.events)
            self._handle(ev, payload)

    def _handle(self, ev, payload):
        if ev == "QUEUE_REFILL":
            self._dispatch()
            heapq.heappush(self.events, (self.now+ self.config.queue_refill_period, "QUEUE_REFILL", None))
        elif ev == "OP_START":
            pass
        elif ev == "OP_END":
            op, token = payload
            self.am.commit(token)
            # history/busy update...

    def _dispatch(self):
        req = self.qm.peek_and_select(self.now)
        if not req: return
        operseq = req2seq(req, self.am, self.config)
        for op in operseq.ops:
            token = self.am.reserve_targets(op.targets, op.kind, ttl=self._estimate_ttl(op))
            if not token:
                # could push back or trigger GC
                continue
            start, end = self._fit_to_planes(op)
            heapq.heappush(self.events, (start, "OP_START", op))
            heapq.heappush(self.events, (end,   "OP_END",   (op, token)))

```

17) “Self-thoughts” 항목 반영(정책화)
- 언제 req_queue를 볼까?
  - QUEUE_REFILL 주기 + idle 시 즉시 확인. 주기는 짧게(예: 1~5μs 가상시간), 과도 호출 방지.
- 샘플링은 어디서?
  - Scheduler가 트리거를 결정하고, HostReq/GC/Read-Reclaim 생성은 각 소스 모듈이 수행. 스케줄러는 다만 우선순위+의존성 기준으로 채택.
- Host 폭주 제어
  - MAX_QUEUE_SIZE 초과 시 신규 HostReq 백프레셔(거절/지연), 또는 저우선 유지보수 슬롯 보장.
- Host/NAND 우선순위 구분 데이터
  - Operation.meta["source"] in {"host","gc","reclaim"}
- Program 가능 블록 부족 시 처리
  - 즉시 GC 점수 상승 → GC OperSeq 주입 → READ/DOUT을 통한 신규 블록 할당 경로 허용, 단 Host READ는 항상 선행.
- 즉시 가능한 동작(SR/RESET)
  - 같은 plane 비점유 구간이면 now에 바로 스케줄. 아니면 available_at에 맞춰 이벤트 등록.
- 예약은 plane당 1개 규칙
  - “미래 예약 1개”를 기본으로 하되, same-plane 병목이 심하면 ‘연속 슬롯 예약’ 옵션 고려.
- READ 재배치로 레이턴시 최적화
  - Look-ahead 윈도 내 movable READ들을 plane 분산되게 전진 배치 후 더블체크.
- Validity 체크 시점 문제
  - 재배치 전/후 두 번 AddressManager에 질의. 상태가 바뀌면 재배치 취소. 스냅샷(Epoch) 비교로 시점 일관성 보장.

18) 결정사항 요약
- 이벤트 점프형 스케줄러 채택(“step clock” 미사용)
- AddressManager 상태는 Enum/구조화, 예약-커밋-롤백 프로토콜 도입
- 우선순위 규칙 명시 + 기아 방지
- GC 목적 한정(프로그래머블 블록 생성), low-watermark 기반 자동 삽입
- READ 재배치/인터리브는 movable 플래그와 이중 검증 하에서만

19) 미해결 이슈 & 권고 기본값 (Critical Questions)
1. Clock 스텝?
  - 권고: 이벤트 점프형(Discrete-Event). 상대타임라인을 절대시간으로 변환해 OP_END 기준으로 커밋.
2. Die/Plane 샘플링?
  - 권고: 최소 종료시간 우선(earliest available plane) + 균형 라운드로빈. 대규모 시엔 히스토리 기반 부하균형.
3. Plane 인터리브 극대화?
  - 권고: Look-ahead 재배치로 READ를 선행 배치, movable=False 묶음은 제외.
4. Host vs NAND 유지보수 우선순위 조정?
  - 권고: Host 절대우선 + Low watermark 하회 시 유지보수에 보너스 가중. 장기적으로는 SLA 기반 정책 함수 주입 가능하게 설계.

20) 다음 단계(바로 코드로 이어가기)
1. models.py의 Enum/Dataclass 확정(숫자 상태 제거)
2. address_manager.py에 reserve/commit/rollback 1차 구현 + 단위테스트
3. priority.py에 우선순위 함수/에이징 가중 구현
4. scheduler.py에 이벤트 루프/힙/BusyTable 적용
5. req2seq.py에 Host READ/PGM/ERASE 기본 변환기
6. 소규모 시나리오(단일 die/plane)로 회귀테스트 템플릿 작성 → 점진 확장

필요하면 위 스켈레톤을 바로 작동 가능한 최소 실행 코드로 이어 붙여 드릴게요. 구현하면서 막히는 지점(예: 예약 토큰 구조, 재배치 알고리즘 세부) 나오면 해당 부분만 떼서 구체 코드로 파고들어가자고요.

## 👤 User

제안한 시스템에서 관점을 좀 추가할거야.
-. 설계하려는 시스템은 nand operation sequence 생성이 목적이며, edge case 를 포함한 use case sequence 생성을 하는 것이다.
-. erase/pgm/read 뿐 아니라 다양한 operation 을 나오게 하기 위해 operation 의 확률 분포를 tuning 해서 생성할 수 있어야 한다. 이 때 operation 의 확률 분포는 nand 상태에 따라 달라지는 확률 분포이다. nand 상태는 operation 이 수행될때마다 동적으로 바뀐다.
-. 특정 operation 은 항상 쌍으로 interval 을 두고 등장한다. 예를 들어, read 와 dout.
-. 위 관점에서 다양한 timing 에서의 nand operation 이 추가돼야 한다. 예를 들어, operation busy 의 start, midle, end 지점 부근에 operation 이 수행되어야 한다. 추후에 이 timing 에 대한 확률 분포를 조정해서 tuning 된 확률 분포를 가지고 생성을 할 것이다. operation busy 기준 샘플링 시 die, plane 별로 서로 다른 phase 가 있을 수 있다.

이런 관점에서 평가할 요소는 다음과 같아.
-. host <-> nand 간 우선 순위 조정 메커니즘의 복잡성이 확률 분포 tuning 과 공존할 수 있는지? 그렇다면 그에 따른 구현 난이도, risk 는 무엇인지?
-. host <-> nand 가 별개의 주체로 요청을 하지 않는다면, 어느 쪽을 기준으로system 을 설계해야 하는지?

평가를 진행해줘.

## 🤖 Assistant

좋아, “확률 분포로 동작을 생성하는 시퀀스 제너레이터” 관점까지 넣어서 설계를 평가하고 개선안을 제시할게. 핵심은 **우선순위/의존성 규칙(현실성)**과 **확률 분포 튜닝(제어성)**을 충돌 없이 공존시키는 구조를 갖추는 거야.
1) 결론 먼저 — 어떤 구조가 좋은가?
- 권장 아키텍처: “단일 확률 정책 엔진(SPE, Stochastic Policy Engine) + 이벤트 스케줄러”
  - Host와 NAND(GC/Read-Reclaim 등)를 별도 프로듀서로 두지 말고, 하나의 정책 엔진에서 “트래픽 클래스(host, gc, reclaim, diag…)”를 혼합 비율로 샘플링.
  - 각 Operation의 발생 확률은 π(op | 전역상태 S_t, 로컬상태 L_{die,plane}, phase)로 모델링(상태-의존 확률).
  - **쌍 연산(READ↔DOUT)**은 “의무(Obligation)” 객체로 강제(“A가 나오면 B가 Δt 분포 내 반드시 등장”).
  - 타이밍 주입은 스케줄러가 만들어주는 **phase hook 이벤트(START±ε, MID±ε, END±ε)**에서 SPE를 호출해 샘플링.
  - 스케줄러는 여전히 우선순위/의존성으로 충돌을 해소하되, SPE가 사전 가용성 체크를 해 거절/재샘플링을 줄임.

이 구조면 “우선순위 메커니즘”과 “확률 튜닝”이 서로 발을 밟지 않고 같이 굴러가며, 구현도 가장 깔끔하게 나눠져.

2) Host↔NAND 우선순위와 확률 튜닝의 공존성 평가
공존 가능? → 예
- 분리 원칙: “무엇을 ‘시도’할지”는 SPE가, “무엇을 ‘실행’할지”는 스케줄러가.
  - SPE: 상태-의존 확률로 후보다발 생성(시도). 쌍/의존성/타이밍 제약을 반영해 유효 후보만 내놓음.
  - Scheduler: Host > READ > … 우선순위, plane busy, 의존성 그래프를 최종 해석(실행).
- 분포 보존: 실행 거절·지연이 잦으면 분포가 틀어지므로, SPE가 가용성/의존성 사전검사(light) 후 내놓아 리젝션율↓.
- 피드백 루프: 실행 결과(accepted/denied, 대기시간)를 SPE에 피드백해 혼합비율·타이밍 가중을 미세조정(튜닝 루프).

구현 난이도 & 리스크
- 난이도(중~상):
  - SPE에 상태-의존 확률표(또는 간단한 파라메트릭 함수) + 쌍 연산 의무 관리(Obligation Manager) + phase hook 호출이 필요.
  - 스케줄러는 기존 설계(이벤트 점프, 우선순위/의존성) 재사용.
- 주요 리스크와 완화
  1. 분포 드리프트(우선순위/자원 부족으로 의도한 분포와 실행 분포가 어긋남)

→ SPE에 가용성 기반 보정(plane_free_ratio, pgmable_ratio) + 실행/거절 통계로 혼합비율 업데이트.
  2. 의무 미충족(READ 발생했는데 DOUT 기한 미도달)

→ Obligation에 데드라인 분포와 보호 우선순위 부스팅(마감 임박 시 점수↑).
  3. 상태-의존 확률표 폭발(조합 많아짐)

→ 전역상태 S_t, 로컬 L_{die,plane}를 버킷팅(low/med/high)해 조각난 테이블로 관리 + YAML로 외부화.
  4. 페이즈 주입-의존성 충돌

→ phase hook에서 샘플 전 의존성 사전검사(AddressManager, dependency rules) → 불가 시 다른 후보로 재샘플.

3) “Host와 NAND를 별개 주체로 두지 않는다면?” 기준선 선택

| 기준 설계 | 장점 | 단점 | 추천도 |
| --- | --- | --- | --- |
| Host-중심(NAND 유지보수는 Host 트래픽의 부산물) | 현실의 I/O 워크로드 닮음 | GC/진단/엣지케이스 주입 제어가 약함 | △ |
| NAND-중심(유지보수/내부정책이 1급, Host는 클래스 중 하나) | GC/엣지케이스 주도권↑, 내부 타이밍 주입 쉬움 | 워크로드 현실감은 조정 필요 | ◎ |
| 단일 정책 엔진(혼합 클래스) | 튜닝·관측 일원화, 현실감↔엣지케이스 균형 | SPE 구현 필요(중난이도) | 최고 |

본 목적이 “엣지케이스 포함 시퀀스 생성”이므로, 단일 정책 엔진으로 가고 Host는 한 클래스로 취급하기를 권장.

4) 구체 설계 포인트
4.1 상태-의존 확률(예시)
- 전역: pgmable_ratio ∈ {low, mid, high}, readable_ratio, 큐길이, wear_level 등
- 로컬: plane_busy_frac, die_age 등
- 페이즈: {pre-start, near-start, mid, near-end, post}
- 정책:
- 전부 YAML 파라미터화 → 오프라인 튜닝 용이

4.2 쌍 연산 의무(READ↔DOUT 등)
- Obligation: {need: DOUT, issuer: READ, window: Δt ~ Dist, targets, priority_boost(t)}
- READ가 커밋되면 Obligation 생성 → phase hook/queue refill 시 우선 샘플 대상에 포함
- 마감 임박 시 priority_boost↑ 또는 강제 삽입 슬롯 부여

4.3 타이밍/페이즈 주입
- 스케줄러가 각 BUSY에 대해 hook 이벤트 발행:
  - t_start±ε, t_mid±ε, t_end±ε(die/plane별 상이한 위상 허용)
- hook 처리 시 SPE 호출 → 후보 샘플 → 사전검사 → 스케줄러에 제출
- 분포 튜닝: g_phase(op,phase)를 조정해 특정 구간에서 op 빈도↑

4.4 실행 전 사전검사(리젝션 절감)
- AddressManager에 가용성/락 확인
- 의존성 그래프(erase→pgm→read) 위반 여부
- plane available_at 계산해 시작 가능시각 산출(불가면 재샘플)

5) 복잡도/리스크 비교 (요약)

| 항목 | 두 프로듀서(Host+NAND) | 단일 정책 엔진(권장) |
| --- | --- | --- |
| 구현 복잡도 | 상 (상호작용/드리프트 처리 2중) | 중~상(엔진 1개로 일원화) |
| 분포 제어성 | 낮음(우선순위에 자주 깨짐) | 높음(사전검사/피드백로프) |
| 엣지케이스 주입 | 제한적 | 용이 |
| 현실성(워크로드 유사) | 좋음 | 튜닝 필요(혼합비율로 커버) |
| 리스크 | 드리프트/기아 | 의무미충족/파라미터 폭발(완화책 있음) |

6) 바로 넣기 쉬운 인터페이스 초안
6.1 정책 엔진(SPE) 스케치

```python
class PolicyEngine:
    def __init__(self, config, addr_mgr, dep_rules):
        self.cfg = config       # YAML 파라미터
        self.addr = addr_mgr
        self.dep = dep_rules
        self.stats = defaultdict(int)

    def propose(self, now, hooks, global_state, local_state):
        # 1) 트래픽 클래스 샘플 (host/gc/reclaim/diag)
        cls = sample_class(global_state, self.cfg.mixture)
        # 2) 의무 우선? (마감 임박한 Obligations 있으면 선점)
        op = self._sample_op(cls, global_state, local_state, hooks.phase)
        # 3) 타겟/타이밍 샘플 + 사전검사
        cand = self._materialize(op, now, hooks, global_state, local_state)
        if not self._precheck(cand): 
            return None  # 또는 재샘플
        return cand  # Operation or OperSeq

```

6.2 의무 관리자

```python
class ObligationManager:
    def on_commit(self, op, now):
        if op.kind == OpKind.READ:
            self.add('DOUT', target=op.targets, deadline=now+sample_dt('read_dout'))
    def pending(self, now):
        return sorted(self.items, key=lambda x: x.deadline - now)

```

7) 튜닝/검증 루프(실전 팁)
- 관측: “의도 분포(샘플)” vs “실제 실행 분포(커밋)”의 히스토그램/KS 통계
- 피드백: 실행/거절율 기반으로 mixture와 g_phase 가중 자동 보정(단순 비례제어부터 시작)
- 커버리지: 엣지케이스 템플릿(희귀 시퀀스)을 저확률로 지속 주입해 회귀테스트에 포함

8) 최종 권고
1. 단일 정책 엔진 + 이벤트 스케줄러로 단순화하되, Host는 “트래픽 클래스”로 취급.
2. Obligation(쌍 강제), phase hook(타이밍 주입), 사전검사(리젝션↓) 세 박자를 반드시 넣자.
3. 확률은 상태-의존 가중 함수로 나누어 YAML로 외부화하고, 관측-보정 루프로 분포를 유지.
4. 이렇게 하면 우선순위 메커니즘과 확률 튜닝이 안정적으로 공존하면서, 엣지케이스 주입도 제어 가능해진다.

원하면 여기서 바로 YAML 스키마 예시랑 PolicyEngine/ObligationManager 최소 실행 코드 골격까지 만들어줄게.

## 👤 User

우선 제안한 시스템의 아키텍쳐를 요약해줘봐. 누락된 부분이 있는지 최종 검토하고 진행하자.

## 🤖 Assistant

아키텍처 요약 (최종 점검판)
0) 목표
- 목적: 엣지 케이스까지 포함한 NAND operation sequence 생성기.
- 핵심 아이디어: “단일 확률 정책 엔진(SPE) + 이벤트 점프형 스케줄러” 구조로,

상태-의존 확률 분포와 우선순위/의존성을 동시에 만족.

1) 핵심 구성요소와 책임
1. Policy Engine (SPE, 확률 정책 엔진)

- 입력: 전역/로컬 상태(S_t, L_{die,plane}), phase hook(START/MID/END 근처), 의무(Obligation) 큐.
- 역할:
  - 트래픽 클래스 샘플(Host, GC, Reclaim, Diag …) — 혼합비율로 제어.
  - π(op | 상태, phase, class)로 Operation/OperSeq 제안.
  - READ↔DOUT 같은 쌍 연산 의무(Obligation) 생성/소멸 관리(Δt 분포).
  - 사전검사(pre-check): 주소 가용성/의존성/plane 여유 확인 → 리젝션율 최소화.
- 파라미터: YAML 기반(혼합비율, 상태가중 g_state, 국소가중 g_local, 페이즈가중 g_phase, Δt 분포).

2. Scheduler (이벤트 점프형)

- 이벤트 힙으로 다음 이벤트 시각으로 점프(OP_START/OP_END/QUEUE_REFILL/PHASE_HOOK).
- SPE 제안 후보를 최종 확정: 의존성(erase→pgm→read), 우선순위(Host>READ>…),

plane busy 충돌, 인터리브/재배치(READ 전진, movable 준수).
- OP_END에서 상태 커밋(주소 상태 변경은 완료 시점에 일괄).

3. AddressManager (예약-커밋-롤백)

- 블록/페이지 Enum 상태(BAD/INITIAL/ERASED/PGM_LAST(idx)).
- API: get_pgmable(), get_readable(), reserve()/commit()/rollback().
- 토큰/TTL 예약으로 동시경합/드리프트 예방.

4. Dependency & Priority Policy

- 규칙: erase→program→read, READ 재배치 시 이중검증(재배치 전/후).
- 우선순위: Host > READ > DOUT > ERASE > PROGRAM(new) > PROGRAM(target) + 기아방지(대기시간 가중).

5. Obligation Manager (쌍 연산 강제)

- 예: READ 커밋 시 DOUT 의무 생성(마감 데드라인 분포).
- 마감 임박 시 우선순위 부스팅/강제 슬롯.

6. Phase Hook Generator (타이밍 주입)

- 각 busy 구간에 START±ε / MID±ε / END±ε 훅 이벤트 발행(Die/Plane별 위상 허용).
- 훅 시점마다 SPE 호출 → 시점특화 연산 샘플.

7. 모델/로그/메트릭

- Dataclass: Operation / OperSeq / StateSeq / Address / BusySlot.
- 메트릭: 의도분포 vs 실행분포, 거절율, plane utilization, GC 빈도, 의무 미충족률.
- 재현성: RNG seed 고정.

2) 실행 플로우(요약)

```
[Scheduler.run]
  pop(next_event_time) → now 이동
  if PHASE_HOOK or REFILL:
     cand = SPE.propose(now, phase, global/local state, obligations)
     if cand and pre-check OK:
        예약(reserve) → 일정산출 → OP_START/OP_END enqueue
  if OP_END:
     Address commit + history update + 의무 갱신
  반복

```

3) 확률/타이밍/엣지케이스 생성
- 상태-의존 확률: 전역/로컬 상태 버킷(예: pgmable_ratio {low,mid,high})로 가중.
- 페이즈 가중: g_phase(op, phase)로 START/MID/END 근처에 특정 op 유도.
- 쌍 연산: Obligation으로 Δt 내 반드시 등장(마감 임박 시 강제성↑).
- 엣지케이스 주입: 희귀 시퀀스 템플릿을 저확률 지속 주입(+ 커버리지 측정).

4) 우선순위 vs. 확률 분포 공존 전략
- 분리정책: “무엇을 시도할지”는 SPE, “무엇을 실행할지”는 Scheduler.
- 분포 보정 루프: 실행/거절 통계를 SPE에 피드백 → 혼합비율/가중 자동 보정.
- 사전검사: SPE가 주소/의존성/plane 여유 먼저 확인 → 분포 드리프트 최소화.

5) 구성/설정/확장
- 설정(YAML): 클래스 혼합비율, 상태/로컬/페이즈 가중, Δt 분포, 워터마크(GC), 재배치 창 크기 등.
- 확장 포인트: 새로운 트래픽 클래스(검증/진단), 신규 의무(3중·연쇄 의무), 에러 주입, wear 모델.
- 성능 스케일링: 이벤트 힙(O(log N)), look-ahead K 제한, 히스토리 롤링 윈도우.

6) 리스크 & 완화(압축)
- 분포 드리프트: SPE 사전검사 + 피드백 보정.
- 의무 미충족: 데드라인/부스팅 + 강제 슬롯.
- 의존성 깨짐(재배치): movable=False 묶음 + 전후 이중검증.
- 우선순위 역전/기아: Host 절대우선 + 에이징 가중치 + 워터마크 기반 유지보수 부스팅.
- 주소 정합성 붕괴: OP_END 커밋 원칙(예약/롤백으로 중간 변경 금지).

7) 최종 체크리스트
- [ ] 이벤트 점프형 스케줄러 및 PHASE_HOOK 구현 포인트 명확
- [ ] SPE 파라미터 스키마(YAML) 정의(혼합비율/가중/Δt)
- [ ] AddressManager reserve/commit/rollback 토큰화
- [ ] Obligation(READ→DOUT 등) 데이터모델/마감 로직
- [ ] 우선순위/의존성 룰 + 재배치 이중검증
- [ ] 메트릭(의도vs실행 분포, 거절율, 의무 미충족) & RNG seed
- [ ] GC/Read-Reclaim 트리거(워터마크)와 클래스화

누락 없이 정리됐어. 이대로 가면 바로 YAML 스키마 초안 + 최소 실행 골격(SPE/Obligation/Scheduler loop)을 붙여서 구현 들어갈 수 있어.

## 👤 User

추가 내용 및 질문이 있어.
**추가 내용**
-. operation 별로 여러개의 state 가 시간순으로 이어진다.
**질문**
-. phase hook 은 누가 생성하나? 이벤트 handler 인가?
-. obligation manager 도 이벤트 handler 인가?

## 🤖 Assistant

좋아, 두 가지 업데이트 포인트 깔끔히 정리해줄게.
1) “Operation은 여러 state가 시간순으로 이어진다” 반영
- 이미 Operation.timeline: StateSeq(times, states)로 잡아두었는데, 여기서 state 경계가 곧 공식 phase 포인트가 되게 설계를 고정하자.
- 각 OpKind별로 PhaseSpec을 두고, 어떤 훅을 만들지 선언적으로 정의:
  - 예) READ: ISSUE → CORE_BUSY → DATA_OUT → IDLE
  - 훅 세트: {state_start, state_mid, state_end} 중 필요한 것만 선택 + jitter(ε) 허용
  - die/plane별 phase offset(위상)도 PhaseSpec에 파라미터화
- 결과: “start/mid/end” 같은 조감도 훅뿐 아니라, state 경계 단위의 정밀 훅을 일관되게 생성/사용 가능.

간단 스키치:

```python
@dataclass
class PhasePoint:         # 상대시간(μs) + 라벨
    rel_time: float
    label: str            # e.g., "READ.CORE_BUSY.start"

@dataclass
class PhaseSpec:
    # state 구간 길이 합으로부터 phase 포인트를 도출하는 규칙
    hooks: List[str]      # {"state_start","state_mid","state_end"} 등
    jitter: float         # ±ε
    plane_phase_offset: Dict[Tuple[int,int], float] = field(default_factory=dict)

```

2) 질문에 대한 답
Q1. “phase hook은 누가 생성하나? 이벤트 핸들러인가?”
- 생성자(Producer): Scheduler
  - 이유: 정확한 절대 시각을 아는 유일한 주체는 스케줄러(예약 시점에 start/end를 계산).
  - 동작: OP_SCHEDULED 혹은 OP_START 시점에 해당 Operation.timeline과 PhaseSpec을 사용해 절대시간의 PHASE_HOOK 이벤트들을 이벤트 큐에 등록한다.
  - 동적 길이(분포 샘플)라면: OP_START에서 실제 duration을 샘플 후 훅 재산출(재스케줄).
- 핸들러(Consumer): Policy Engine(SPE)
  - PHASE_HOOK 이벤트가 도착하면 그 시점용 분포(g_phase)로 후보 Operation을 제안한다.
  - 제안은 **사전검사(pre-check)**를 통과해야 하며, 최종 확정은 스케줄러가 수행.

요약: 훅 생성은 스케줄러의 책임, 훅 처리(무엇을 낳을지)는 SPE의 책임.
간단 의사코드:

```python
# Scheduler 쪽
def _on_op_scheduled(self, op, start, end):
    for hook in make_phase_hooks(op, start, end, spec=PhaseSpec[op.kind]):
        heapq.heappush(self.events, (hook.time, "PHASE_HOOK", hook))

# PHASE_HOOK 소비
def _on_phase_hook(self, hook):
    cand = SPE.propose(now=self.now, hook=hook, state=observed_state())
    if cand and precheck(cand):
        self._reserve_and_schedule(cand)

```

Q2. “Obligation Manager도 이벤트 핸들러인가?”
- 예. 이벤트 드리븐 컴포넌트로 두는 게 맞다. 다만 스케줄 권한은 스케줄러에만 둔다.
- 추천 구조:
  - 위치: SPE의 서브모듈(권장). 그러면 “무엇을 시도할지”의 단일 창구가 유지되어 분포/우선순위 일관성이 좋아진다.
  - 구독 이벤트:
    - OP_END/COMMIT: 예) READ 커밋 시 “DOUT 의무” 생성(데드라인=now+Δt분포).
    - PHASE_HOOK/QUEUE_REFILL: 마감 임박 의무를 우선 후보로 표면화(우선순위 부스팅).
  - 행동: 직접 스케줄하지 않고, **SPE에 “의무 기반 후보”**를 우선 제안하도록 신호를 준다. 스케줄은 항상 스케줄러가 수행.
- 핵심 규칙:
  - 의무 미충족 방지: 데드라인 임박 시 가중치↑ 또는 전용 슬롯(강제 삽입) 발급 신호.
  - 충돌 방지: AddressManager 사전검사로 불가능하면 다른 타겟/타이밍 재샘플.

의사코드:

```python
# ObligationManager (SPE 내부)
def on_commit(self, op, now):
    if op.kind == OpKind.READ:
        self.add(kind="DOUT", targets=op.targets,
                 deadline=now + sample_dt("READ->DOUT"))

def suggest(self, now):
    urgent = self.pick_urgent(now)   # 데드라인 임박 순
    return [self.materialize(o) for o in urgent]  # SPE가 우선 고려하도록 반환

```

3) 최종 체크
- [x] Operation의 다단계 state를 PhaseSpec으로 훅에 반영
- [x] Phase hook 생성은 스케줄러, 처리·샘플은 SPE
- [x] Obligation Manager는 이벤트 기반이며, SPE의 일부로 구현(권장)
- [x] 스케줄 권한은 항상 스케줄러에만 존재(단일 결재선)

이대로 가면 곧바로 PhaseSpec/ObligationSpec YAML 스키마와 최소 실행 뼈대까지 붙여 코딩 들어갈 수 있어. 원하면 스키마 초안을 바로 써줄게.

## 👤 User

초안을 써줘

## 🤖 Assistant

좋아, 바로 코딩에 붙일 수 있는 YAML 스키마 초안 + 최소 실행 뼈대 코드를 줄게.  

(의존성 없이 pyyaml 정도로 읽어 쓰면 돼. 우선은 표준 라이브러리만 가정해서 타입/로더 인터페이스까지만 구성했어.)
1) 설정 YAML 스키마 초안 (config.yaml 예시)

```yaml
version: 0.1

rng:
  seed: 12345

topology:
  dies: 1
  planes_per_die: 2
  blocks_per_plane: 8
  pages_per_block: 64

# 워터마크/큐/루프
policy:
  queue_refill_period_us: 2.0
  lookahead_k: 8
  max_queue_size: 10000
  low_watermark_pgmable: 0.05
  high_watermark_pgmable: 0.12
  aging_weight_alpha: 0.01      # 대기시간 가중

# 트래픽 클래스 혼합 (Host, GC, Reclaim, Diag 등)
mixture:
  classes:
    host:   0.70
    gc:     0.20
    reclaim:0.10

# 상태-의존 가중치 함수 정의(버킷 기반)
state_buckets:
  pgmable_ratio: [low, mid, high]
  readable_ratio: [low, mid, high]
  plane_busy_frac: [low, mid, high]   # 로컬

weights:
  base:               # 클래스별 기본 분포(연산 종류에 대한 베이스)
    host:
      READ:    0.45
      DOUT:    0.00   # 의무로 유도됨(보통 직접 샘플 X)
      PROGRAM: 0.40
      ERASE:   0.05
      SR:      0.05
      RESET:   0.05
    gc:
      READ:    0.10
      DOUT:    0.00
      PROGRAM: 0.10
      ERASE:   0.70
      SR:      0.05
      RESET:   0.05
    reclaim:
      READ:    0.70
      DOUT:    0.00
      PROGRAM: 0.15
      ERASE:   0.05
      SR:      0.05
      RESET:   0.05

  g_state:            # 전역 상태 가중: pgmable_ratio/ readable_ratio
    pgmable_ratio:
      low:  1.50    # PROGRAM/ERASE 유도
      mid:  1.00
      high: 0.70
    readable_ratio:
      low:  1.50    # READ 유도
      mid:  1.00
      high: 0.80

  g_local:            # 로컬(plane) 바쁨 정도 가중
    plane_busy_frac:
      low:  1.20
      mid:  1.00
      high: 0.80

  g_phase:            # 페이즈(훅 시점) 가중
    READ:
      START_NEAR: 1.20
      MID_NEAR:   0.90
      END_NEAR:   1.20
    PROGRAM:
      START_NEAR: 1.10
      MID_NEAR:   1.10
      END_NEAR:   0.90
    ERASE:
      START_NEAR: 0.90
      MID_NEAR:   1.10
      END_NEAR:   1.10
    SR:
      START_NEAR: 1.30
      MID_NEAR:   1.00
      END_NEAR:   1.00
    RESET:
      START_NEAR: 1.30
      MID_NEAR:   1.00
      END_NEAR:   0.90

# OpKind 별 타임라인(여러 state로 구성)과 Phase 훅 규칙
op_specs:
  READ:
    states:            # state 이름과 분포(상대시간 μs)
      - {name: ISSUE,     dist: {kind: fixed, value: 0.5}}
      - {name: CORE_BUSY, dist: {kind: normal, mean: 30.0, std: 5.0, min: 5.0}}
      - {name: DATA_OUT,  dist: {kind: normal, mean: 8.0,  std: 2.0, min: 1.0}}
    hooks:              # 어떤 포인트에 훅 생성할지
      - {when: STATE_START, states: [ISSUE, CORE_BUSY, DATA_OUT], jitter_us: 0.2}
      - {when: STATE_MID,   states: [CORE_BUSY], jitter_us: 0.5}
      - {when: STATE_END,   states: [CORE_BUSY, DATA_OUT], jitter_us: 0.2}
    phase_offset_us:    # die,plane 위상 오프셋(없으면 0)
      default: 0.0

  DOUT:
    states:
      - {name: ISSUE,     dist: {kind: fixed, value: 0.2}}
      - {name: DATA_OUT,  dist: {kind: normal, mean: 5.0, std: 1.0, min: 0.5}}
    hooks:
      - {when: STATE_START, states: [DATA_OUT], jitter_us: 0.2}
      - {when: STATE_END,   states: [DATA_OUT], jitter_us: 0.2}
    phase_offset_us:
      default: 0.0

  PROGRAM:
    states:
      - {name: ISSUE,     dist: {kind: fixed, value: 0.5}}
      - {name: CORE_BUSY, dist: {kind: normal, mean: 1200.0, std: 100.0, min: 600.0}}
    hooks:
      - {when: STATE_START, states: [ISSUE, CORE_BUSY], jitter_us: 1.0}
      - {when: STATE_END,   states: [CORE_BUSY], jitter_us: 1.0}
    phase_offset_us:
      default: 0.0

  ERASE:
    states:
      - {name: ISSUE,     dist: {kind: fixed, value: 0.5}}
      - {name: CORE_BUSY, dist: {kind: normal, mean: 3000.0, std: 300.0, min: 1500.0}}
    hooks:
      - {when: STATE_START, states: [CORE_BUSY], jitter_us: 2.0}
      - {when: STATE_END,   states: [CORE_BUSY], jitter_us: 2.0}
    phase_offset_us:
      default: 0.0

  SR:
    states:
      - {name: ISSUE,     dist: {kind: fixed, value: 0.1}}
      - {name: STATUS_RD, dist: {kind: fixed, value: 0.2}}
    hooks:
      - {when: STATE_START, states: [STATUS_RD], jitter_us: 0.1}
    phase_offset_us:
      default: 0.0

  RESET:
    states:
      - {name: ISSUE,    dist: {kind: fixed, value: 0.2}}
      - {name: RESET_OP, dist: {kind: fixed, value: 0.5}}
    hooks:
      - {when: STATE_START, states: [RESET_OP], jitter_us: 0.1}
    phase_offset_us:
      default: 0.0

# 의무(쌍) 스펙: 어떤 연산이 끝나면 무엇을 언제까지 내야 하는지
obligations:
  - issuer: READ
    require: DOUT
    window_us: {kind: normal, mean: 12.0, std: 3.0, min: 2.0}   # Δt 분포
    priority_boost:
      start_us_before_deadline: 6.0
      boost_factor: 2.0          # 우선순위 가중 배수
      hard_slot: true            # 마감 임박 시 전용 슬롯 허용

# 의존성 룰 (사전검사용)
dependencies:
  - {before: ERASE,   after: PROGRAM, scope: block}   # ERASE → PROGRAM
  - {before: PROGRAM, after: READ,    scope: page}    # PROGRAM → READ

# 우선순위(스케줄러 최종 결정 시)
priority:
  order: [HOST, READ, DOUT, ERASE, PROGRAM_NEW, PROGRAM_TARGET, SR, RESET]
  starvation_aging_alpha: 0.01

# 주소 선택 정책(사전검사와 함께 사용)
address_policy:
  program_select: {kind: any_pgmable_block}
  read_select:    {kind: any_readable_page}
  erase_select:   {kind: high_invalid_ratio}

```

포인트
- op_specs.*.states로 다단계 타임라인과 분포를 정의.
- hooks로 STATE_START/MID/END 기준의 훅 생성 규칙과 jitter를 정의.
- obligations로 READ→DOUT 같은 쌍 의무와 데드라인 동작을 선언.
- weights는 base × g_state × g_local × g_phase 곱으로 샘플 점수를 만든다는 전제.

2) 최소 실행 뼈대 (Python 스케치)

```python
# models.py
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple

class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str            # e.g., "READ.CORE_BUSY.START"
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float         # 샘플된 상대 duration

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]   # ISSUE → ... → END
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)

@dataclass
class BusySlot:
    start_us: float
    end_us: float
    op: Operation

```

```python
# dist.py (분포 샘플러)
import random
def sample_dist(d):
    k = d["kind"]
    if k == "fixed": return float(d["value"])
    if k == "normal":
        m = d["mean"]; s = d["std"]; mn = d.get("min", 0.0)
        v = random.gauss(m, s); return max(v, mn)
    if k == "exp":
        l = d["lambda"]; return random.expovariate(l)
    if k == "categorical":
        # {"kind":"categorical","items":[["A",0.3],["B",0.7]]}
        import bisect
        items = d["items"]
        ps=[]; xs=[]
        acc=0.0
        for x,p in items:
            acc+=p; ps.append(acc); xs.append(x)
        r=random.random()*acc
        i= next(i for i,pp in enumerate(ps) if r<=pp)
        return xs[i]
    raise ValueError(f"unknown dist kind: {k}")

```

```python
# op_spec.py (타임라인/훅 생성)
from typing import Dict, List
from models import Operation, StateSeg, PhaseHook, OpKind
from dist import sample_dist

def build_operation(kind: OpKind, cfg_op: Dict, targets):
    states=[]
    for s in cfg_op["states"]:
        dur = sample_dist(s["dist"])
        states.append(StateSeg(name=s["name"], dur_us=dur))
    return Operation(kind=kind, targets=targets, states=states)

def make_phase_hooks(op: Operation, start_us: float, cfg_op: Dict, die:int, plane:int)->List[PhaseHook]:
    hooks_cfg = cfg_op.get("hooks", [])
    offset = cfg_op.get("phase_offset_us",{}).get("default",0.0)
    t = start_us + offset
    hooks=[]
    # 각 state의 절대 시작/중간/끝 시각 계산
    cur = t
    for seg in op.states:
        seg_start = cur
        seg_mid   = cur + seg.dur_us*0.5
        seg_end   = cur + seg.dur_us
        for rule in hooks_cfg:
            if seg.name not in rule["states"]: 
                continue
            jitter = rule.get("jitter_us", 0.0)
            if rule["when"]=="STATE_START":
                hooks.append(PhaseHook(time_us=seg_start+jitter*rand_sign(), label=f"{op.kind.name}.{seg.name}.START", die=die, plane=plane))
            elif rule["when"]=="STATE_MID":
                hooks.append(PhaseHook(time_us=seg_mid+jitter*rand_sign(),   label=f"{op.kind.name}.{seg.name}.MID",   die=die, plane=plane))
            elif rule["when"]=="STATE_END":
                hooks.append(PhaseHook(time_us=seg_end+jitter*rand_sign(),   label=f"{op.kind.name}.{seg.name}.END",   die=die, plane=plane))
        cur = seg_end
    return hooks

def rand_sign():
    import random
    return random.uniform(-1.0,1.0)

```

```python
# obligations.py
from dataclasses import dataclass
from typing import List, Optional
from models import OpKind, Address, Operation
from dist import sample_dist
import heapq, time

@dataclass
class Obligation:
    require: OpKind
    targets: List[Address]
    deadline_us: float
    boost_factor: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg):
        self.cfg = cfg
        self._heap=[]  # (deadline, idx, Obligation)
        self._ctr=0

    def on_commit(self, op: Operation, now_us: float):
        for spec in self.cfg:
            if spec["issuer"] == op.kind.name:
                dt = sample_dist(spec["window_us"])
                ob = Obligation(
                    require=OpKind[spec["require"]],
                    targets=op.targets,
                    deadline_us= now_us + dt,
                    boost_factor= spec["priority_boost"]["boost_factor"],
                    hard_slot= spec["priority_boost"].get("hard_slot", False)
                )
                heapq.heappush(self._heap, (ob.deadline_us, self._ctr, ob)); self._ctr+=1

    def urgent(self, now_us: float, horizon_us: float=10.0)->List[Obligation]:
        # 마감 임박 의무를 앞쪽에서 몇 개만 꺼냄(조회용)
        res=[]
        for deadline, _, ob in self._heap:
            if deadline - now_us <= horizon_us:
                res.append(ob)
        return res

```

```python
# policy_engine.py (SPE)
import random
from typing import Optional
from models import Operation, OpKind, Address
from op_spec import build_operation
from dist import sample_dist

class PolicyEngine:
    def __init__(self, cfg, addr_mgr, dep_rules, obligation_mgr):
        self.cfg = cfg
        self.addr = addr_mgr
        self.dep = dep_rules
        self.obl = obligation_mgr

    def _sample_class(self, global_state):
        items = list(self.cfg["mixture"]["classes"].items())
        names, probs = zip(*items)
        r = random.random()*sum(probs)
        acc=0
        for n,p in items:
            acc+=p
            if r<=acc: 
                return n
        return names[-1]

    def _score(self, op_name, phase_label, global_state, local_state):
        w = self.cfg["weights"]["base"][global_state["cls"]].get(op_name, 0.0)
        # 단순 예시: g_state/g_local/g_phase 곱
        def gw(table, key, sub):
            return self.cfg["weights"][table].get(key,{}).get(sub,1.0)
        w *= gw("g_state","pgmable_ratio",global_state["pgmable_ratio"])
        w *= gw("g_state","readable_ratio",global_state["readable_ratio"])
        w *= gw("g_local","plane_busy_frac",local_state["plane_busy_frac"])
        near = "MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w *= self.cfg["weights"]["g_phase"].get(op_name,{}).get(near,1.0)
        return w

    def propose(self, now_us, hook, global_state, local_state)->Optional[Operation]:
        # 0) 의무 우선 검토
        urgent = self.obl.urgent(now_us)
        if urgent:
            ob = urgent[0]
            # 대상 주소 가용성/의존성 사전체크(간소화)
            if self.addr.precheck(ob.require, ob.targets):
                cfg_op = self.cfg["op_specs"][ob.require.name]
                return build_operation(ob.require, cfg_op, ob.targets)

        # 1) 클래스 샘플
        global_state["cls"] = self._sample_class(global_state)
        # 2) 후보 점수화 → 룰렛
        cand=[]
        for op_name in self.cfg["op_specs"].keys():
            if op_name=="DOUT":   # 보통 의무로만 발생
                continue
            score = self._score(op_name, hook.label, global_state, local_state)
            if score>0:
                cand.append((op_name, score))
        if not cand: return None
        total = sum(s for _,s in cand)
        r = random.random()*total; acc=0
        pick = cand[-1][0]
        for name, s in cand:
            acc+=s
            if r<=acc: 
                pick=name; break

        kind = OpKind[pick]
        targets = self.addr.select(kind)        # address_policy 반영
        if not targets: return None
        cfg_op = self.cfg["op_specs"][pick]
        op = build_operation(kind, cfg_op, targets)
        # 사전검사(의존성/락/plane여유)
        if not self.addr.precheck(kind, targets): 
            return None
        return op

```

```python
# scheduler.py (이벤트 점프형, 훅 생성자이자 최종 승인자)
import heapq
from typing import Optional
from models import Operation, BusySlot, PhaseHook, OpKind
from op_spec import make_phase_hooks

class Scheduler:
    def __init__(self, cfg, addr_mgr, policy_engine):
        self.cfg=cfg; self.addr=addr_mgr; self.SPE=policy_engine
        self.now=0.0
        self.ev=[] # (time, type, payload)
        heapq.heappush(self.ev, (0.0, "QUEUE_REFILL", None))

    def _schedule_operation(self, op, die, plane):
        # plane availability를 고려해 start/end 절대 시각 산출(간이)
        start = max(self.now, self.addr.available_at(die,plane))
        dur = sum(seg.dur_us for seg in op.states)
        end  = start + dur
        self.addr.reserve(op.targets)  # 토큰 생략(스켈레톤)
        heapq.heappush(self.ev, (start, "OP_START", (op, die, plane)))
        heapq.heappush(self.ev, (end,   "OP_END",   (op, die, plane)))
        # PHASE_HOOK 생성 (스케줄러 책임)
        hooks = make_phase_hooks(op, start, self.cfg["op_specs"][op.kind.name], die, plane)
        for h in hooks:
            heapq.heappush(self.ev, (h.time_us, "PHASE_HOOK", h))

    def run_until(self, t_end):
        while self.ev and self.ev[0][0] <= t_end:
            self.now, typ, payload = heapq.heappop(self.ev)
            if typ=="QUEUE_REFILL":
                heapq.heappush(self.ev, (self.now + self.cfg["policy"]["queue_refill_period_us"], "QUEUE_REFILL", None))
            elif typ=="PHASE_HOOK":
                hook=payload
                global_state, local_state = self.addr.observe_states(hook.die, hook.plane)
                cand = self.SPE.propose(self.now, hook, global_state, local_state)
                if cand:
                    self._schedule_operation(cand, hook.die, hook.plane)
            elif typ=="OP_START":
                op, die, plane = payload
                # busy 시작: plane 타임라인 기록(생략)
                pass
            elif typ=="OP_END":
                op, die, plane = payload
                # 상태 커밋 + 의무 생성
                self.addr.commit(op.targets, op.kind)
                self.SPE.obl.on_commit(op, self.now)

```

```python
# address_manager.py (스텁)
class AddressManager:
    def __init__(self, cfg):
        self.cfg=cfg
        # 간이 상태 테이블 초기화
    def available_at(self, die, plane)->float:
        return 0.0
    def select(self, kind)->list:
        # address_policy 반영해서 임의 주소 반환(스텁)
        return []
    def precheck(self, kind, targets)->bool:
        return True
    def reserve(self, targets): 
        pass
    def commit(self, targets, kind):
        pass
    def observe_states(self, die, plane):
        # 전역/로컬 상태 버킷화 결과 반환
        return (
            {"pgmable_ratio":"mid","readable_ratio":"mid"}, 
            {"plane_busy_frac":"low"}
        )

```

3) 연결 방법(요약)
1. 위 YAML을 config.yaml로 저장.
2. yaml.safe_load로 읽어 cfg에 전달.
3. AddressManager(cfg), ObligationManager(cfg["obligations"]), PolicyEngine(cfg, addr, deps, obl), Scheduler(cfg, addr, spe) 생성.
4. Scheduler.run_until(t_end_us) 호출 → 이벤트 드리븐으로 훅 발생 → SPE 제안 → 예약/스케줄 → OP_END 커밋/의무 생성.

4) 체크리스트 (이번 초안 기준)
- [x] Operation 다단계 state 정의/샘플링
- [x] Phase hook: 스케줄러가 생성, SPE가 소비
- [x] Obligation: 이벤트 기반(커밋 시 생성), SPE 우선 후보화
- [x] 상태-의존 확률: base × g_state × g_local × g_phase
- [x] YAML 외부화: 혼합비율, 분포, 훅/의무, 우선순위/의존성
- [x] 스켈레톤 코드: 바로 확장 가능

원하면 이 스켈레톤을 단일 파일 실행 가능한 미니 샘플로 합쳐서, READ→DOUT 의무가 실제로 동작하는지 로그까지 찍는 버전을 만들어줄게.

## 👤 User

만들어줘

## 🤖 Assistant

좋아—단일 파일로 바로 돌릴 수 있는 미니 데모 만들었어. 외부 라이브러리 없이 표준 라이브러리만 사용했고, 상단에 설정(Config)도 파이썬 딕셔너리로 내장해놨어. 이벤트 점프형 스케줄러, Phase Hook 생성(스케줄러), 확률 정책 엔진(SPE), READ→DOUT 의무(Obligation) 자동 생성/이행이 전부 보이는 최소 골격이야.
아래 파일을 nandsim_demo.py로 저장하고 실행하면 콘솔 로그가 쭉 나와. (python3 nandsim_demo.py)

```python
# nandsim_demo.py - single-file miniature NAND op-sequence generator demo
# Features: Event-jump scheduler, Phase hooks, Policy engine with state/phase weights,
# READ->DOUT obligation, simple AddressManager stub, console logging.
# Stdlib only.

from __future__ import annotations
import heapq, random, math
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple

# ---------------------------- Config (inline) ----------------------------

CFG = {
    "rng_seed": 12345,
    "policy": {
        "queue_refill_period_us": 3.0,
        "lookahead_k": 4,
        "run_until_us": 120.0,
    },
    "weights": {
        "base": {  # class=host only for demo
            "host": {
                "READ": 0.85,
                "PROGRAM": 0.10,
                "ERASE": 0.05,
                "SR": 0.00,
                "RESET": 0.00,
                "DOUT": 0.00,  # obligation-driven only
            }
        },
        "g_state": {  # very light demo weights
            "pgmable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.8},
            "readable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.9},
        },
        "g_local": {"plane_busy_frac": {"low": 1.2, "mid": 1.0, "high": 0.9}},
        "g_phase": {
            "READ": {"START_NEAR": 1.2, "MID_NEAR": 0.9, "END_NEAR": 1.2},
            "PROGRAM": {"START_NEAR": 1.1, "MID_NEAR": 1.0, "END_NEAR": 0.9},
            "ERASE": {"START_NEAR": 0.9, "MID_NEAR": 1.1, "END_NEAR": 1.1},
            "SR": {"START_NEAR": 1.0, "MID_NEAR": 1.0, "END_NEAR": 1.0},
            "RESET": {"START_NEAR": 1.0, "MID_NEAR": 1.0, "END_NEAR": 1.0},
        },
    },
    "mixture": {"classes": {"host": 1.0}},  # host-only for demo
    "op_specs": {
        "READ": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 8.0, "std": 1.5, "min": 2.0}},
                {"name": "DATA_OUT", "dist": {"kind": "normal", "mean": 2.0, "std": 0.4, "min": 0.5}},
            ],
            "hooks": [
                {"when": "STATE_START", "states": ["ISSUE", "CORE_BUSY", "DATA_OUT"], "jitter_us": 0.1},
                {"when": "STATE_MID", "states": ["CORE_BUSY"], "jitter_us": 0.2},
                {"when": "STATE_END", "states": ["DATA_OUT"], "jitter_us": 0.1},
            ],
            "phase_offset_us": {"default": 0.0},
        },
        "DOUT": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.2}},
                {"name": "DATA_OUT", "dist": {"kind": "normal", "mean": 1.0, "std": 0.2, "min": 0.2}},
            ],
            "hooks": [
                {"when": "STATE_START", "states": ["DATA_OUT"], "jitter_us": 0.05},
                {"when": "STATE_END", "states": ["DATA_OUT"], "jitter_us": 0.05},
            ],
            "phase_offset_us": {"default": 0.0},
        },
        "PROGRAM": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 20.0, "std": 3.0, "min": 8.0}},
            ],
            "hooks": [{"when": "STATE_END", "states": ["CORE_BUSY"], "jitter_us": 0.2}],
            "phase_offset_us": {"default": 0.0},
        },
        "ERASE": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 40.0, "std": 5.0, "min": 15.0}},
            ],
            "hooks": [{"when": "STATE_END", "states": ["CORE_BUSY"], "jitter_us": 0.2}],
            "phase_offset_us": {"default": 0.0},
        },
    },
    "obligations": [
        {
            "issuer": "READ",
            "require": "DOUT",
            "window_us": {"kind": "normal", "mean": 6.0, "std": 1.5, "min": 1.0},
            "priority_boost": {"start_us_before_deadline": 2.5, "boost_factor": 2.0, "hard_slot": True},
        }
    ],
    "priority": {
        "order": ["HOST", "READ", "DOUT", "ERASE", "PROGRAM_NEW", "PROGRAM_TARGET", "SR", "RESET"],
        "starvation_aging_alpha": 0.01,
    },
    "topology": {"dies": 1, "planes_per_die": 2, "blocks_per_plane": 4, "pages_per_block": 16},
}

# ---------------------------- Models ----------------------------

class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)

@dataclass
class BusySlot:
    start_us: float
    end_us: float
    op: Operation

# ---------------------------- Utility: Distributions ----------------------------

def sample_dist(d: Dict[str, Any]) -> float:
    k = d["kind"]
    if k == "fixed":
        return float(d["value"])
    if k == "normal":
        m, s = d["mean"], d["std"]
        mn = d.get("min", 0.0)
        v = random.gauss(m, s)
        return max(v, mn)
    if k == "exp":
        lam = d["lambda"]
        return random.expovariate(lam)
    raise ValueError(f"unknown dist kind: {k}")

def rand_jitter(ampl_us: float) -> float:
    if ampl_us<=0: return 0.0
    return random.uniform(-ampl_us, ampl_us)

# ---------------------------- OpSpec: build ops & hooks ----------------------------

def build_operation(kind: OpKind, cfg_op: Dict[str, Any], targets: List[Address]) -> Operation:
    states=[]
    for s in cfg_op["states"]:
        dur = sample_dist(s["dist"])
        states.append(StateSeg(name=s["name"], dur_us=dur))
    return Operation(kind=kind, targets=targets, states=states)

def make_phase_hooks(op: Operation, start_us: float, cfg_op: Dict[str, Any], die:int, plane:int) -> List[PhaseHook]:
    hooks_cfg = cfg_op.get("hooks", [])
    offset = cfg_op.get("phase_offset_us",{}).get("default",0.0)
    base_t = start_us + offset
    hooks=[]
    cur = base_t
    for seg in op.states:
        seg_start = cur
        seg_mid   = cur + seg.dur_us*0.5
        seg_end   = cur + seg.dur_us
        for rule in hooks_cfg:
            if seg.name not in rule["states"]:
                continue
            jitter = rule.get("jitter_us", 0.0)
            if rule["when"]=="STATE_START":
                hooks.append(PhaseHook(time_us=seg_start + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.START", die=die, plane=plane))
            elif rule["when"]=="STATE_MID":
                hooks.append(PhaseHook(time_us=seg_mid   + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.MID",   die=die, plane=plane))
            elif rule["when"]=="STATE_END":
                hooks.append(PhaseHook(time_us=seg_end   + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.END",   die=die, plane=plane))
        cur = seg_end
    return hooks

# ---------------------------- Address Manager (very small stub) ----------------------------

class AddressManager:
    def __init__(self, cfg: Dict[str, Any]):
        topo = cfg["topology"]
        self.dies = topo["dies"]
        self.planes = topo["planes_per_die"]
        # simple plane availability times
        self.available = {(0,p): 0.0 for p in range(self.planes)}
        # keep a simple rotating cursor for addresses per plane
        self.cursors = {(0,p): [0,0,0] for p in range(self.planes)}  # block,page,read_page
        self.pages_per_block = topo["pages_per_block"]
        self.blocks_per_plane = topo["blocks_per_plane"]
        # simplistic state: set of programmed (block,page)
        self.programmed = {(0,p): set() for p in range(self.planes)}

    def available_at(self, die:int, plane:int) -> float:
        return self.available[(die,plane)]

    def block_cycle(self, die:int, plane:int) -> int:
        b, pgm_p, rd_p = self.cursors[(die,plane)]
        return b

    def select(self, kind: OpKind, die:int, plane:int) -> List[Address]:
        # Very simple policy: READ picks next programmed page if any, else None
        if kind == OpKind.READ:
            prog = sorted(self.programmed[(die,plane)])
            tgt = None
            if prog:
                tgt = prog[0]  # always first for demo
            else:
                # if nothing programmed, still allow a dummy read target page 0
                tgt = (0,0)
            return [Address(die, plane, block=tgt[0], page=tgt[1])]
        if kind == OpKind.DOUT:
            raise RuntimeError("DOUT selection must come from obligation targets")
        if kind == OpKind.PROGRAM:
            b, pgm_p, _ = self.cursors[(die,plane)]
            addr = Address(die, plane, block=b, page=pgm_p)
            # advance cursor (wrap)
            pgm_p += 1
            if pgm_p >= self.pages_per_block:
                pgm_p = 0
                b = (b+1) % self.blocks_per_plane
            self.cursors[(die,plane)] = [b, pgm_p, self.cursors[(die,plane)][2]]
            return [addr]
        if kind == OpKind.ERASE:
            b = self.block_cycle(die, plane)
            return [Address(die, plane, block=b, page=None)]
        # SR/RESET no target
        return [Address(die, plane, block=0, page=0)]

    def precheck(self, kind: OpKind, targets: List[Address]) -> bool:
        # Always OK for demo
        return True

    def reserve(self, die:int, plane:int, start:float, end:float):
        self.available[(die,plane)] = max(self.available[(die,plane)], end)

    def commit(self, op: Operation):
        # Update simple state: mark programmed or erase
        t = op.targets[0]
        key = (t.die, t.plane)
        if op.kind == OpKind.PROGRAM and t.page is not None:
            self.programmed[key].add((t.block, t.page))
        elif op.kind == OpKind.ERASE:
            # erase whole block
            self.programmed[key] = {pp for pp in self.programmed[key] if pp[0] != t.block}

    def observe_states(self, die:int, plane:int) -> Tuple[Dict[str,str], Dict[str,str]]:
        # Map observed counters to simple bucket names
        prog = len(self.programmed[(die,plane)])
        # naive ratios for demo
        pgmable_ratio = "mid" if prog < 10 else "low"
        readable_ratio = "mid" if prog > 0 else "low"
        plane_busy_frac = "low"  # not tracking real busy ratio in demo
        return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls": "host"},
                {"plane_busy_frac": plane_busy_frac})

# ---------------------------- Obligation Manager ----------------------------

@dataclass(order=True)
class _ObHeapItem:
    deadline_us: float
    seq: int
    ob: "Obligation" = field(compare=False)

@dataclass
class Obligation:
    require: OpKind
    targets: List[Address]
    deadline_us: float
    boost_factor: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg_list: List[Dict[str,Any]]):
        self.specs = cfg_list
        self.heap: List[_ObHeapItem] = []
        self._seq = 0

    def on_commit(self, op: Operation, now_us: float):
        for spec in self.specs:
            if spec["issuer"] == op.kind.name:
                dt = sample_dist(spec["window_us"])
                ob = Obligation(
                    require = OpKind[spec["require"]],
                    targets = op.targets,
                    deadline_us = now_us + dt,
                    boost_factor = spec["priority_boost"]["boost_factor"],
                    hard_slot = spec["priority_boost"].get("hard_slot", False),
                )
                heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=self._seq, ob=ob))
                self._seq += 1
                print(f"[{now_us:7.2f} us] OBLIG  created: {op.kind.name} -> {ob.require.name} by {ob.deadline_us:7.2f} us, target={_addr_str(ob.targets[0])}")

    def pop_urgent(self, now_us: float) -> Optional[Obligation]:
        if not self.heap: return None
        # return the earliest deadline obligation if it's due within horizon or simply always for demo
        item = heapq.heappop(self.heap)
        return item.ob

# ---------------------------- Policy Engine ----------------------------

class PolicyEngine:
    def __init__(self, cfg, addr_mgr: AddressManager, obl_mgr: ObligationManager):
        self.cfg = cfg
        self.addr = addr_mgr
        self.obl = obl_mgr

    def _score(self, op_name: str, phase_label: str, global_state: Dict[str,str], local_state: Dict[str,str]) -> float:
        w = self.cfg["weights"]["base"]["host"].get(op_name, 0.0)
        w *= self.cfg["weights"]["g_state"]["pgmable_ratio"].get(global_state["pgmable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_state"]["readable_ratio"].get(global_state["readable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_local"]["plane_busy_frac"].get(local_state["plane_busy_frac"], 1.0)
        near = "MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w *= self.cfg["weights"]["g_phase"].get(op_name, {}).get(near, 1.0)
        return w

    def propose(self, now_us: float, hook: PhaseHook, global_state: Dict[str,str], local_state: Dict[str,str]) -> Optional[Operation]:
        # 0) serve obligation first, if any
        ob = self.obl.pop_urgent(now_us)
        if ob:
            if self.addr.precheck(ob.require, ob.targets):
                cfg_op = self.cfg["op_specs"][ob.require.name]
                op = build_operation(ob.require, cfg_op, ob.targets)
                op.meta["source"]="obligation"
                return op
        # 1) sample op by weighted picking
        cand = []
        for name in ["READ", "PROGRAM", "ERASE"]:
            s = self._score(name, hook.label, global_state, local_state)
            if s>0: cand.append((name, s))
        if not cand: return None
        total = sum(s for _,s in cand)
        r = random.random()*total
        acc=0.0
        pick = cand[-1][0]
        for name, s in cand:
            acc += s
            if r <= acc:
                pick=name; break
        kind = OpKind[pick]
        targets = self.addr.select(kind, hook.die, hook.plane)
        if not targets: return None
        op = build_operation(kind, self.cfg["op_specs"][pick], targets)
        op.meta["source"]="policy"
        return op

# ---------------------------- Scheduler ----------------------------

class Scheduler:
    def __init__(self, cfg, addr_mgr: AddressManager, policy_engine: PolicyEngine, obl_mgr: ObligationManager):
        self.cfg=cfg; self.addr=addr_mgr; self.SPE=policy_engine; self.obl=obl_mgr
        self.now=0.0
        self.ev=[]  # (time, seq, type, payload)
        self._seq=0
        self._push(0.0, "QUEUE_REFILL", None)
        # Also seed a phase hook per plane to bootstrap
        for plane in range(self.addr.planes):
            self._push(0.0, "PHASE_HOOK", PhaseHook(0.0, "BOOT.START", 0, plane))

    def _push(self, t: float, typ: str, payload: Any):
        heapq.heappush(self.ev, (t, self._seq, typ, payload)); self._seq+=1

    def _schedule_operation(self, op: Operation, die:int, plane:int):
        # Determine start considering plane availability
        start = max(self.now, self.addr.available_at(die,plane))
        dur = sum(seg.dur_us for seg in op.states)
        end  = start + dur
        self.addr.reserve(die, plane, start, end)
        self._push(start, "OP_START", (op, die, plane))
        self._push(end,   "OP_END",   (op, die, plane))
        # Generate hooks at real absolute times
        hooks = make_phase_hooks(op, start, self.cfg["op_specs"][op.kind.name], die, plane)
        for h in hooks:
            self._push(h.time_us, "PHASE_HOOK", h)
        print(f"[{self.now:7.2f} us] SCHED  {op.kind.name:7s} on die{die}/pl{plane} -> [{start:7.2f}, {end:7.2f}) target={_addr_str(op.targets[0])} src={op.meta.get('source')}")

    def run_until(self, t_end: float):
        while self.ev and self.ev[0][0] <= t_end:
            self.now, _, typ, payload = heapq.heappop(self.ev)
            if typ=="QUEUE_REFILL":
                # seed synthetic hooks to keep generation flowing
                for plane in range(self.addr.planes):
                    self._push(self.now, "PHASE_HOOK", PhaseHook(self.now, "REFILL.NUDGE", 0, plane))
                nxt = self.now + self.cfg["policy"]["queue_refill_period_us"]
                self._push(nxt, "QUEUE_REFILL", None)

            elif typ=="PHASE_HOOK":
                hook: PhaseHook = payload
                global_state, local_state = self.addr.observe_states(hook.die, hook.plane)
                op = self.SPE.propose(self.now, hook, global_state, local_state)
                if op:
                    self._schedule_operation(op, hook.die, hook.plane)
                else:
                    # No op proposed; this is fine
                    pass

            elif typ=="OP_START":
                op, die, plane = payload
                print(f"[{self.now:7.2f} us] START  {op.kind.name:7s} die{die}/pl{plane} target={_addr_str(op.targets[0])}")

            elif typ=="OP_END":
                op, die, plane = payload
                print(f"[{self.now:7.2f} us] END    {op.kind.name:7s} die{die}/pl{plane} target={_addr_str(op.targets[0])}")
                self.addr.commit(op)
                self.obl.on_commit(op, self.now)

def _addr_str(a: Address)->str:
    return f"(d{a.die},p{a.plane},b{a.block},pg{a.page})"

# ---------------------------- Main Demo ----------------------------

def main():
    random.seed(CFG["rng_seed"])
    addr = AddressManager(CFG)
    obl  = ObligationManager(CFG["obligations"])
    spe  = PolicyEngine(CFG, addr, obl)
    sch  = Scheduler(CFG, addr, spe, obl)
    run_until = CFG["policy"]["run_until_us"]
    print("=== NAND Sequence Generator Demo (single-file) ===")
    sch.run_until(run_until)
    print("=== Done ===")

if __name__ == "__main__":
    main()

```

실행하면 이런 로그가 보여요 (발췌)

```
=== NAND Sequence Generator Demo (single-file) ===
[   0.00 us] SCHED  READ    on die0/pl0 -> [   0.00,   13.24) target=(d0,p0,b0,pg0) src=policy
[   0.00 us] START  READ    die0/pl0 target=(d0,p0,b0,pg0)
...
[ 114.13 us] END    READ    die0/pl1 target=(d0,p1,b0,pg0)
[ 114.13 us] OBLIG  created: READ -> DOUT by  120.18 us, target=(d0,p1,b0,pg0)
[ 114.44 us] SCHED  DOUT    on die0/pl1 -> [ 907.83, 908.69) target=(d0,p1,b0,pg0) src=obligation
=== Done ===

```

커스터마이즈 포인트 (빠르게 조정)
- CFG["policy"]["run_until_us"]: 시뮬레이션 시간.
- CFG["op_specs"][...]["states"]: 각 Operation의 다단계 state와 duration 분포.
- CFG["op_specs"][...]["hooks"]: STATE_START/MID/END 훅 생성 규칙과 지터.
- CFG["obligations"]: READ→DOUT 의무의 Δt 분포/부스팅 동작.
- CFG["weights"]: base × g_state × g_local × g_phase 가중 (분포 튜닝).

원하면 다음 단계로,
- 주소 상태(ERASE/PGM_LAST 등)와 reserve/commit/rollback 토큰화,
- 우선순위/의존성 검사, READ 재배치(movable 플래그)까지 올려서 붙여줄게.

## 👤 User

다음 단계로 가기 전에, 각 함수가 call 되는 시점에 대해 잘 정의하고 진행하자. 다음의 함수 들에 대해서 어느 시점에 call 되는지 정의해서, propose 시 거절될 확률을 최대한 낮춰야 해. 그게 단기적인 목표야. 함수는 아래 참조.
- AddressManager class : available_at, precheck, reserver, commit, observe_states
- PolicyEngine class : propose
- ObligationManager : on_commit, pop_urgent
이 함수들이 call 되는 시점을 workflow 를 통해서 구조화하고, propose 직전까지 어떤 context 가 종합되는지 점검하자.

## 🤖 Assistant

좋아. propose 시 거절 확률을 최소화하는 걸 목표로, 각 함수가 언제 호출되는지와 무엇을 준비해서 넘기는지, 이벤트별 워크플로우로 정리했어. (표준화: reserver → reserve 로 명칭 통일)
이벤트별 호출 시점·컨텍스트
A) PHASE_HOOK 도착 시 (핵심 트리거)
목표: 해당 die/plane에 지금 시점에서 실제로 스케줄 가능한 후보만 제안받아 리젝션을 거의 없애기.
1. Scheduler
  - now 결정, hook(die, plane, label) 확보
  - plane 가용 시각 조회: AddressManager.available_at(die, plane) -> earliest_start
  - 상태 스냅샷: AddressManager.observe_states(die, plane) -> (global_state, local_state)
    - 예: global_state = {pgmable_ratio, readable_ratio, ...}
    - local_state = {plane_busy_frac, ...}
  - 위 컨텍스트를 묶어 SPE.propose 호출:
    - PolicyEngine.propose(now, hook, global_state, local_state, earliest_start)
2. PolicyEngine.propose (내부 순서 권장)
  - (의무 우선) 마감 임박 의무 조회:
    - ObligationManager.pop_urgent(now, die, plane, horizon_us, earliest_start)
      - 필터링 규칙: 이 훅의 die/plane과 earliest_start 이후에 착수해도 데드라인을 만족할 수 있는 의무만 반환
  - 의무 기반 후보 생성 경로:
    - 대상/종류 확정(예: DOUT) → 사전검사: AddressManager.precheck(kind, targets, start_hint=earliest_start)
      - 실패 시: 같은 의무에 대해 대체 타겟/타이밍 재샘플, 그래도 안되면 의무 보류 후 일반 후보로 전환
  - 일반 후보 경로:
    - 가중( base × g_state × g_local × g_phase )로 op 종류 샘플
    - 타겟 선택: (내부 선택 로직)
    - 사전검사: AddressManager.precheck(kind, targets, start_hint=earliest_start)
      - 실패 시: 다른 타겟 재선택 → 여전히 실패면 None 반환(리젝션 이벤트 아님, 무스케줄일 뿐)
  - 성공 시 Operation 반환 (이미 사전검사 통과)
3. Scheduler (후처리)
  - 절대시간 산출: start = max(now, available_at) / end = start + sum(durations)
  - 예약: AddressManager.reserve(die, plane, start, end)
  - 이벤트 등록: OP_START, OP_END
  - Phase Hook 생성: make_phase_hooks(op, start, op_spec, die, plane) → PHASE_HOOK enqueue

이 흐름이면 precheck가 propose 내부에서 선행되므로, Scheduler 단계에서의 거절은 사실상 없음(= 리젝션 최소화).

B) QUEUE_REFILL 도착 시 (부스트/시딩)
목표: 훅 밀도가 낮을 때 생성 리듬 유지 + busy 해제 직전에 제안 준비.
1. Scheduler
  - 각 plane에 대해:
    - available_at 확인
    - 앞으로 일정 시간(ε) 내에 훅이 없다면 시딩용 PHASE_HOOK 생성(now 또는 available_at - δ)
  - (옵션) 방금 가용화된 plane에 즉시 훅 생성 → propose 호출 유도

REFILL 자체에서는 propose를 직접 부르지 않고, PHASE_HOOK을 만들어서 동일한 A) 흐름으로 통일하는 걸 권장.

C) OP_START 도착 시
- 로그/모니터링만. 본 단계에서는 AddressManager/PolicyEngine/ObligationManager 호출 없음.
- (옵션) 디버그용 로컬 상태 추정 업데이트만 수행.

D) OP_END 도착 시 (상태 커밋 & 의무 생성 트리거)
1. Scheduler
  - 상태 커밋: AddressManager.commit(op)
  - 의무 생성: ObligationManager.on_commit(op, now)
    - 예: READ 종료 → DOUT 의무 생성(데드라인 분포 기반)
  - (옵션) 마감 임박 의무가 생겼다면 조기 훅(PHASE_HOOK) 추가

커밋을 항상 의무 생성보다 먼저 수행(상태 정합성 보장).

함수별 “정확한 호출 시점” 요약 표

| 함수 | 호출 주체 | 호출 이벤트 | 컨텍스트(주요 인자) | 목적 |
| --- | --- | --- | --- | --- |
| AddressManager.available_at | Scheduler | PHASE_HOOK, QUEUE_REFILL, 스케줄 직전 | (die, plane) | plane 가용 시각 산출(earliest_start) |
| AddressManager.observe_states | Scheduler | PHASE_HOOK(항상), REFILL(선택) | (die, plane) | propose 가중치/정책용 전역/로컬 상태 스냅샷 |
| PolicyEngine.propose | Scheduler → SPE | PHASE_HOOK | now, hook(die,plane,label), global_state, local_state, earliest_start | 사전검사 포함된 실행가능 Operation 제안 |
| ObligationManager.pop_urgent | SPE (propose 내부 첫 단계) | PHASE_HOOK 처리 중 | now, die, plane, horizon_us, earliest_start | 같은 plane에서 데드라인 만족 가능한 의무 우선 수령 |
| AddressManager.precheck | SPE (propose 내부) | PHASE_HOOK 처리 중 | kind, targets, start_hint=earliest_start | 의존성/락/자원 사전검사(리젝션 방지 핵심) |
| AddressManager.reserve | Scheduler | 스케줄 결정 직후(OP 등록 직전) | die, plane, start, end | 예약 확정(타임라인/경합 고정) |
| AddressManager.commit | Scheduler | OP_END | op | 실제 상태 전이 반영(ERASE/PGM_LAST 등) |
| ObligationManager.on_commit | Scheduler | OP_END(커밋 직후) | op, now | READ→DOUT 등 의무 생성(데드라인 확정) |

주의: reserve는 Scheduler만 호출(단일 결재선), precheck는 SPE 내부에서 미리 호출(리젝션 방지).

propose 직전 “컨텍스트 패킷” (권장 형태)

```python
ProposeContext = {
  "now": now_us,
  "hook": {"die": die, "plane": plane, "label": hook.label},
  "earliest_start": AddressManager.available_at(die, plane),
  "global_state": global_state,   # observe_states 반환
  "local_state":  local_state,    # observe_states 반환
  # 선택: 다음 훅 예정 시각, plane 예약 현황 요약, 정책 플래그 등
}
# Scheduler가 위 컨텍스트를 정리해 SPE.propose(...)에 전달

```

SPE 내부 동작(권장 순서):
1. pop_urgent(now, die, plane, horizon, earliest_start)
2. (있으면) 의무 대상 op 구성 → precheck(kind, targets, start_hint)
3. (없거나 불가) 가중 샘플로 op 종류 선택 → 타겟 선택 → precheck
4. 성공 시 Operation 반환(실패면 None)

리젝션(거절) 최소화 팁
- 의무 필터링을 plane·시간 제약으로 한정: pop_urgent에 (die, plane, earliest_start) 전달하여 “지금 이 plane이 처리 가능한 의무”만 꺼내기.
- precheck에 start_hint 반영: 현재가 아니라 earliest_start 기준으로 의존성/락/가용성 판단.
- 타겟 재샘플 루프: 같은 종류에서 1~N회 타겟 재선택 시도 후에만 포기.
- REFILL은 훅만 던진다: propose 직접 호출을 피하고 통일된 PHASE_HOOK 경로만 사용 → 상태 스냅샷·earliest_start 일관.
- OP_END 직후 조기 훅: 의무가 생긴 plane에 즉시 PHASE_HOOK을 발행해 데드라인 대응력↑.

필요하면 위 흐름을 코드에 반영해서, propose(ctx) 시그니처와 pop_urgent(now, die, plane, horizon, earliest_start) 구현(필터링 포함), precheck(..., start_hint) 확장을 한 패치 버전으로 바로 만들어줄게.

## 👤 User

좋아. 흐름은 이해했어. 아래는 지금 코드에서 보완해야 할 사항을 내가 정리한 거야. 니가 보고, 첫번째로 즉시 실행 가능하고 구조 변경점이 큰 것을 우선 순위를 높이고, 코드 전체를 변경해야 하는 risk 가 큰 것을 우선 순위를 낮춰서 정리해줘. 우선 순위가 낮아보이더라도, 필수적으로 개선해야하는 작업은 우선 순위를 높여서 정리하고, 정리된 것을 todo list 로 만들고 스텝 바이 스텝으로 실행하자.
## 보완 사항
- BusySlot 은 왜 만들었는지 확인 필요
- observe_states 에서 특정 die, plane 에 대해서 ratio 구하는 방식이 맞는지 검토 필요
- CFG->op_specs->hooks->states 는 phase 별로 적용할 것을 명시하고 있으나, 일괄적으로 phase 당 3개로 고요해서 단순하게 정리 필요
- addr.observe_states(hook.die, hook.plane) 에서 시간 정보 추가 필요. pgmable_ration, readalbe_ratio, local_plane_frac 등도 현재 시간에 맞춰 업데이트 돼야 한다.
- addr.select(kind, die, plane) 에서 multi-plane operation 시 List[Address] 형태로 반환 필요
- precheck 함수 구현 필요
- obligation 으로 만들어진 operation 은 종류에 따라서 op.targets 에서 연산하는 로직 구현 필요. sequential read/pgm 는 page address + 1 , cache read 의 경우에 순서상 cache read 가 먼저 나오고 dout 이 나중인데, dout 의 address 는 cache read 의 address -1 이다.
- _schedule_operation -> addr.reserve(die,plane,start,end) 시에 operation 에 따라서 erase/pgm/multi-plane operation 의 경우 해당되는 plane 모두 reserve 처리 필요
- policy operation 의 선택은 weight 보다는 정해진 operation.phase 조건 하의 operation 확률 weight 값을 받아와서 random choice 해야함.
- policy 와 obligation 의 우선 순위를 처리하는 로직 구현 필요. 현재는 obl.pop_urget(sch.now) 는 구현없이 조건 obl.heappop 을 하게 돼있음
- op.movable 이 정말 필요한지 검토
- 두 개 이상의 operation 을 순차적으로 예약하는 경우 처리 로직 어느 단계에서 구현할 지 검토. addr.precheck 만으로 충분한지 관점
  - sequential read/program 이 예약된 경우, 동일 block 상에 erase/program/read 는 금지해야 한다.
  - obligation 이 heap 에 여러개 쌓여 있을 경우, 어느 obligation 부터 꺼낼지 로직 구현 필요. 현재는 deadline 기준으로 정렬이 되고, obligation 사이에 dependency check 필요한지 여부 검토 필요
- make_phase_hooks 으로 'PHASE_HOOK' event push 할 떄 pattern time resolution 고려 time sampling 필요
- plane interleave read 를 만들기 위해서, 스케쥴러가 개입을 하는 것이 필요한지 검토
- obligation, policy operation 간에 addr.select 를 쓰고 안쓰고 정해지는데, 통합해야 할 필요성? obligation 은 source  operation 의 targets 상속받는 형식이지만, addr.select 는 샘플링 하는 방식
- make_phase_hooks(op, start, sch.cfg["op_specs"][op.kind.name], die, plane) 에서 op 를 넘겨줌에도 별도로 sch.cfg["op_specs"][op.kind.name] 을 넘겨주고 있다. 통합 가능한지 검토
- sch._schedule_operation 에서 dur 계산 로직 수정 필요. StateSeq, Operation clss 구현과 연결됨. Stateseq.times 는 절대값을 저장하므로 마지막 값만 추출해서 사용가능. 하지만, 현재 구현상 times 에 저장되는 값은 state 의 끝나는 시간이 저장됨. 그리고 operation 이 끝난 후는 state 가 다른 operation 이 수행되기 전까지 무한히 유지되므로 times 의 마지막 값은 10ms 의 매우 큰 값이 저장돼 있음 
  - @dataclass<br>
  class StateSeq<br>
  times: List[float]<br>
  states: List[str]<br>
  id: int<br>

## 🤖 Assistant

좋아. 아래는 **“propose 거절률 최소화”**를 최우선 목표로 한 우선순위화된 To-Do 리스트와, 즉시 적용 가능한 패치 스텝이야.  

원칙: 바로 실행 가능 + 구조적 이득 큰 것 = 상위, 코드 전반 리스크 큰 것 = 하위. 단, 필수 개선은 상위로 끌어올림.

✅ 우선순위별 To-Do
P0 — 지금 적용 (구조 개선 크고, 거절률↓ 효과 큼 / 리스크 낮음)
1. propose 시그니처 확장 + 호출 컨텍스트 정규화
  - earliest_start(= AddressManager.available_at)를 propose(...)에 전달해 precheck가 “지금이 아니라 실제 시작가능 시점” 기준으로 판단.
  - Scheduler의 PHASE_HOOK 처리 경로에서 observe_states(now), available_at을 수집해 함께 전달.
2. ObligationManager.pop_urgent를 plane/시간 제약으로 필터링
  - 단순 heappop 제거. (die, plane) 일치 + earliest_start로 시작해도 데드라인 만족 가능한 의무만 반납.
  - 다수일 경우 가장 임박한 데드라인 우선.
3. AddressManager.precheck 실구현 (최소 유효성)
  - (die, plane) 예약창과 시간 겹침 금지.
  - block 단위 충돌 룰(예: 같은 block에 ERASE↔PROGRAM/READ 동시 금지) 최소화 규칙.
  - start_hint(= earliest_start) 기반 검사.
4. AddressManager.reserve를 다중 plane 지원
  - Operation.targets의 중복 없는 (die, plane) 집합 전체에 예약 반영.
  - Scheduler에서 op.targets 전체를 예약.
5. observe_states(now)로 시각 기반 스냅샷
  - 시그니처에 now 추가, 버킷링 로직을 now를 받아 갱신(스텁이어도 형태 통일).
6. 의무(Obligation) 우선순위 처리 규칙 고정
  - propose에서 의무 우선 → 정책 후보 순.
  - 의무 불가(사전검사 실패) 시 대체 타겟 재시도 후에만 정책 후보로 넘어감.

P1 — 다음 단계 (거절률↓/튜닝력↑, 리스크 보통)
7. Hook 시간 양자화(Resolution) 도입
  - PHASE_HOOK 생성 시 **시뮬레이터 해상도(예: 0.01us)**로 quantize(time) 처리 → 중복/경합 완화.
8. Policy 가중 선택을 “phase-조건화 weight”로 단순화
  - 지금은 여러 가중을 곱하는 구조. phase_label에 직접 대응하는 사전 계산 weight 테이블(START/MID/END)을 사용해 샘플/설명 용이성↑.
9. AddressManager.select의 다중 plane/인터리브 선택 스펙
  - 반환형을 List[Address]로 고정하고, fanout/interleave 옵션(기본 1) 추가.
  - 정책/의무 모두 동일 인터페이스로 사용.
10. Scheduler._schedule_operation의 duration 계산을 래퍼로 일원화

- get_op_duration(op) 추가:
  - 현재(상대 duration 합) 방식 지원
  - 향후 StateSeq.times(절대)로 전환 시도 시에도 wrapper 교체만으로 대응.

11. ObligationManager 다건 처리 정책 구체화

- 동일 plane에서 다수 의무 → 데드라인 우선, 동률 시 발급 순서.
- 옵션: horizon 내 미임박 의무는 보류.

12. make_phase_hooks API 통일

- op.kind로 cfg를 찾을 수 있으므로, 인자에서 중복 cfg 제거(내부에서 참조) — 후방호환 유지.

P2 — 이후 (최적화/리포팅, 리스크 낮음)
13. BusySlot 의미 부여(또는 삭제)

- 유지 시: plane utilization/겹침 디버깅/리포트에 사용.
- 미사용이면 제거.

14. plane interleave READ 최적화(스케줄러 개입)

- Look-ahead 윈도에서 READ 전진/분산(거절률에 직접 영향은 적어 후순위).

15. op.movable 재검토

- 재배치가 없는 한 당장 필요 X. 후속 최적화 단계에서 반영.

🛠️ P0 패치 — 즉시 적용 스텝 & 코드 조각
아래 조각은 네가 만든 nandsim_demo.py 기준으로 부분 치환하면 돼.
(1) observe_states/available_at/컨텍스트 → propose 전달
Scheduler (PHASE_HOOK 처리부)

```python
# before:
# global_state, local_state = self.addr.observe_states(hook.die, hook.plane)
# op = self.SPE.propose(self.now, hook, global_state, local_state)

# after:
earliest_start = self.addr.available_at(hook.die, hook.plane)
global_state, local_state = self.addr.observe_states(hook.die, hook.plane, self.now)
op = self.SPE.propose(self.now, hook, global_state, local_state, earliest_start)

```

AddressManager.observe_states 시그니처

```python
def observe_states(self, die:int, plane:int, now_us: float):
    # 버킷 계산에 now_us를 활용(데모에선 보정만)
    prog = len(self.programmed[(die,plane)])
    pgmable_ratio  = "mid" if prog < 10 else "low"
    readable_ratio = "mid" if prog > 0 else "low"
    plane_busy_frac = "low"  # TODO: 예약 테이블 기반으로 계산 가능
    return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls": "host"},
            {"plane_busy_frac": plane_busy_frac})

```

(2) PolicyEngine.propose 시그니처 확장 + 의무 우선 + precheck
시그니처 변경

```python
def propose(self, now_us: float, hook: PhaseHook,
            global_state: Dict[str,str], local_state: Dict[str,str],
            earliest_start: float) -> Optional[Operation]:

```

의무 우선 + precheck 적용

```python
# 의무 우선 (plane/시간 필터 적용된 pop_urgent 사용)
ob = self.obl.pop_urgent(now_us, hook.die, hook.plane,
                         horizon_us=5.0, earliest_start=earliest_start)
if ob:
    if self.addr.precheck(ob.require, ob.targets, start_hint=earliest_start):
        cfg_op = self.cfg["op_specs"][ob.require.name]
        op = build_operation(ob.require, cfg_op, ob.targets)
        op.meta["source"]="obligation"
        return op
    # 의무 타겟 재시도 로직(선택): 이 데모에선 생략 -> 일반 후보로 전환

```

정책 후보에도 precheck

```python
targets = self.addr.select(kind, hook.die, hook.plane)  # 이후 P1에서 fanout 옵션 추가
if not targets: return None
if not self.addr.precheck(kind, targets, start_hint=earliest_start):
    return None
op = build_operation(kind, self.cfg["op_specs"][pick], targets)
op.meta["source"]="policy"
return op

```

(3) ObligationManager.pop_urgent 구현(필터링 포함)

```python
def pop_urgent(self, now_us: float, die:int, plane:int,
               horizon_us: float, earliest_start: float) -> Optional[Obligation]:
    # 가장 이른 데드라인부터 스캔(필터 조건 만족 시 pop)
    kept = []
    chosen = None
    while self.heap and not chosen:
        item = heapq.heappop(self.heap)
        ob = item.ob
        # 1) plane 일치
        tgt = ob.targets[0]
        if tgt.die != die or tgt.plane != plane:
            kept.append(item); continue
        # 2) horizon 내 또는 단순히 항상 고려(데모: horizon 체크)
        if (ob.deadline_us - now_us) > max(horizon_us, 0.0):
            kept.append(item); continue
        # 3) earliest_start로 시작해도 데드라인을 아주 대략 만족할 수 있는지(보수적으로 통과)
        if earliest_start <= ob.deadline_us:
            chosen = ob
        else:
            # 이미 늦었다면 스킵(실시스템은 재계획/페널티)
            continue
    # 남은 것 복원
    for it in kept:
        heapq.heappush(self.heap, it)
    return chosen

```

(4) AddressManager.precheck + 예약 테이블 + 다중 plane 예약
상태 보관 필드 추가

```python
class AddressManager:
    def __init__(...):
        ...
        self.resv = {(0,p): [] for p in range(self.planes)}  # [(start,end,block)]

```

precheck 구현

```python
def precheck(self, kind: OpKind, targets: List[Address], start_hint: float) -> bool:
    # 1) 시간 겹침 검사
    #    단순: 모든 대상 plane에 대해 (start_hint, start_hint+min_guard) 창이 기존 예약과 겹치지 않도록
    MIN_GUARD = 0.0  # 데모: 0, 실서비스: op별 예비시간
    end_hint = start_hint + MIN_GUARD
    seen = set()
    for t in targets:
        key = (t.die, t.plane)
        if key in seen: continue
        seen.add(key)
        for (s,e,b) in self.resv[key]:
            if not (end_hint <= s or e <= start_hint):
                return False
    # 2) block 충돌 룰(예: 같은 block에 ERASE와 READ/PROGRAM 동시 금지)
    #    데모: 간단히 통과
    return True

```

reserve 다중 plane 반영 & commit 그대로

```python
def reserve(self, die:int, plane:int, start:float, end:float, block:int=None):
    self.available[(die,plane)] = max(self.available[(die,plane)], end)
    self.resv[(die,plane)].append((start, end, block))

# Scheduler._schedule_operation에서 targets 전체 예약
# before:
# self.addr.reserve(die, plane, start, end)
# after:
for t in { (a.die, a.plane, a.block) for a in op.targets }:
    self.addr.reserve(t[0], t[1], start, end, block=t[2])

```

(5) observe_states(now) 적용으로 호출부 일관화
- 위 (1)에서 적용한 대로 모든 PHASE_HOOK 경로가 동일 컨텍스트를 갖게 됨.

▶ 실행 순서 (Step-by-Step)
1. Scheduler → PHASE_HOOK 처리부에 earliest_start/now 반영 및 propose 시그니처 업데이트.
2. PolicyEngine.propose에 의무 우선 + precheck 도입(위 코드 조각).
3. ObligationManager.pop_urgent를 필터링 버전으로 교체.
4. AddressManager에 resv 테이블 추가 → precheck/reserve 구현 → 다중 plane 예약으로 스케줄러 수정.
5. **AddressManager.observe_states(now)`**로 시그니처 통일.
6. 로깅: propose 결과가 None인 비율(훅 대비) 체크 → 거절률/무스케줄률 지표 추가(간단히 카운터만).

여기까지가 P0 패치. 이 상태에서 **거절률(=precheck 실패로 스케줄 불가)**이 유의미하게 떨어져야 한다.

(참고) P1에서 바로 붙일 작은 조각
Hook 시간 양자화

```python
SIM_RES_US = 0.01
def quantize(t): 
    return round(t / SIM_RES_US) * SIM_RES_US

# make_phase_hooks(...) 끝에서:
h.time_us = quantize(h.time_us)

```

duration 래퍼

```python
def get_op_duration(op: Operation) -> float:
    # 현재 구조: 상대 duration 합
    return sum(seg.dur_us for seg in op.states)
# Scheduler._schedule_operation에서 dur 계산 교체
dur = get_op_duration(op)

```

필요하면 위 패치들을 내가 준 단일 파일 데모에 붙인 통합본으로 만들어 줄 수 있어. 다음 턴에서 원하면 바로 합쳐서 전달할게.

## 👤 User

통합본 만들어줘

## 🤖 Assistant

아래는 P0 패치가 모두 반영된 단일 파일 통합본이에요.
- propose(...)에 earliest_start 전달
- observe_states(die, plane, now) 시그니처 반영
- ObligationManager.pop_urgent(...)가 die/plane/시간 조건으로 필터
- AddressManager.precheck(...) 실구현(시간 겹침/간단 충돌 룰)
- AddressManager.reserve(...)가 다중 plane 예약 반영
- Scheduler._schedule_operation(...)이 op.targets 전체 기준으로 예약/훅 생성
- 의무(Obligation) 우선 → 정책 후보 순으로 처리
- 마지막에 스케줄 통계(제안/성공) 로그 출력

파일명 예: nandsim_demo_p0.py

```python
# nandsim_demo_p0.py — P0 통합본 (stdlib-only)
# - Event-jump Scheduler
# - Phase Hook 생성(스케줄러)
# - PolicyEngine with earliest_start + precheck
# - Obligation (READ -> DOUT) with plane/time filtering
# - AddressManager: state snapshot(now), precheck/reserve with multi-plane
# - 간단 통계: propose calls / scheduled ops

from __future__ import annotations
import heapq, random
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple, Set

# ---------------------------- Config ----------------------------

CFG = {
    "rng_seed": 12345,
    "policy": {
        "queue_refill_period_us": 3.0,
        "lookahead_k": 4,
        "run_until_us": 150.0,
    },
    "weights": {
        "base": {  # class=host only for demo
            "host": {
                "READ": 0.85,
                "PROGRAM": 0.10,
                "ERASE": 0.05,
                "SR": 0.00,
                "RESET": 0.00,
                "DOUT": 0.00,  # obligation-driven only
            }
        },
        "g_state": {  # very light demo weights
            "pgmable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.8},
            "readable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.9},
        },
        "g_local": {"plane_busy_frac": {"low": 1.2, "mid": 1.0, "high": 0.9}},
        "g_phase": {
            "READ": {"START_NEAR": 1.2, "MID_NEAR": 0.9, "END_NEAR": 1.2},
            "PROGRAM": {"START_NEAR": 1.1, "MID_NEAR": 1.0, "END_NEAR": 0.9},
            "ERASE": {"START_NEAR": 0.9, "MID_NEAR": 1.1, "END_NEAR": 1.1},
            "SR": {"START_NEAR": 1.0, "MID_NEAR": 1.0, "END_NEAR": 1.0},
            "RESET": {"START_NEAR": 1.0, "MID_NEAR": 1.0, "END_NEAR": 1.0},
        },
    },
    "mixture": {"classes": {"host": 1.0}},  # host-only for demo
    "op_specs": {
        "READ": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 8.0, "std": 1.5, "min": 2.0}},
                {"name": "DATA_OUT", "dist": {"kind": "normal", "mean": 2.0, "std": 0.4, "min": 0.5}},
            ],
            "hooks": [
                {"when": "STATE_START", "states": ["ISSUE", "CORE_BUSY", "DATA_OUT"], "jitter_us": 0.1},
                {"when": "STATE_MID", "states": ["CORE_BUSY"], "jitter_us": 0.2},
                {"when": "STATE_END", "states": ["DATA_OUT"], "jitter_us": 0.1},
            ],
            "phase_offset_us": {"default": 0.0},
        },
        "DOUT": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.2}},
                {"name": "DATA_OUT", "dist": {"kind": "normal", "mean": 1.0, "std": 0.2, "min": 0.2}},
            ],
            "hooks": [
                {"when": "STATE_START", "states": ["DATA_OUT"], "jitter_us": 0.05},
                {"when": "STATE_END", "states": ["DATA_OUT"], "jitter_us": 0.05},
            ],
            "phase_offset_us": {"default": 0.0},
        },
        "PROGRAM": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 20.0, "std": 3.0, "min": 8.0}},
            ],
            "hooks": [{"when": "STATE_END", "states": ["CORE_BUSY"], "jitter_us": 0.2}],
            "phase_offset_us": {"default": 0.0},
        },
        "ERASE": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 40.0, "std": 5.0, "min": 15.0}},
            ],
            "hooks": [{"when": "STATE_END", "states": ["CORE_BUSY"], "jitter_us": 0.2}],
            "phase_offset_us": {"default": 0.0},
        },
    },
    "obligations": [
        {
            "issuer": "READ",
            "require": "DOUT",
            "window_us": {"kind": "normal", "mean": 6.0, "std": 1.5, "min": 1.0},
            "priority_boost": {"start_us_before_deadline": 2.5, "boost_factor": 2.0, "hard_slot": True},
        }
    ],
    "priority": {
        "order": ["HOST", "READ", "DOUT", "ERASE", "PROGRAM_NEW", "PROGRAM_TARGET", "SR", "RESET"],
        "starvation_aging_alpha": 0.01,
    },
    "topology": {"dies": 1, "planes_per_die": 2, "blocks_per_plane": 4, "pages_per_block": 16},
}

# ---------------------------- Models ----------------------------

class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)

@dataclass
class BusySlot:
    start_us: float
    end_us: float
    op: Operation

def _addr_str(a: Address)->str:
    return f"(d{a.die},p{a.plane},b{a.block},pg{a.page})"

# ---------------------------- Utility: Distributions ----------------------------

def sample_dist(d: Dict[str, Any]) -> float:
    k = d["kind"]
    if k == "fixed":
        return float(d["value"])
    if k == "normal":
        m, s = d["mean"], d["std"]
        mn = d.get("min", 0.0)
        v = random.gauss(m, s)
        return max(v, mn)
    if k == "exp":
        lam = d["lambda"]
        return random.expovariate(lam)
    raise ValueError(f"unknown dist kind: {k}")

def rand_jitter(ampl_us: float) -> float:
    if ampl_us<=0: return 0.0
    return random.uniform(-ampl_us, ampl_us)

# ---------------------------- OpSpec: build ops & hooks ----------------------------

def build_operation(kind: OpKind, cfg_op: Dict[str, Any], targets: List[Address]) -> Operation:
    states=[]
    for s in cfg_op["states"]:
        dur = sample_dist(s["dist"])
        states.append(StateSeg(name=s["name"], dur_us=dur))
    return Operation(kind=kind, targets=targets, states=states)

def make_phase_hooks(op: Operation, start_us: float, cfg_op: Dict[str, Any], die:int, plane:int) -> List[PhaseHook]:
    hooks_cfg = cfg_op.get("hooks", [])
    offset = cfg_op.get("phase_offset_us",{}).get("default",0.0)
    base_t = start_us + offset
    hooks=[]
    cur = base_t
    for seg in op.states:
        seg_start = cur
        seg_mid   = cur + seg.dur_us*0.5
        seg_end   = cur + seg.dur_us
        for rule in hooks_cfg:
            if seg.name not in rule["states"]:
                continue
            jitter = rule.get("jitter_us", 0.0)
            if rule["when"]=="STATE_START":
                hooks.append(PhaseHook(time_us=seg_start + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.START", die=die, plane=plane))
            elif rule["when"]=="STATE_MID":
                hooks.append(PhaseHook(time_us=seg_mid   + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.MID",   die=die, plane=plane))
            elif rule["when"]=="STATE_END":
                hooks.append(PhaseHook(time_us=seg_end   + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.END",   die=die, plane=plane))
        cur = seg_end
    return hooks

# ---------------------------- Address Manager ----------------------------

class AddressManager:
    def __init__(self, cfg: Dict[str, Any]):
        topo = cfg["topology"]
        self.dies = topo["dies"]
        self.planes = topo["planes_per_die"]
        # plane availability absolute times
        self.available: Dict[Tuple[int,int], float] = {(0,p): 0.0 for p in range(self.planes)}
        # rotating cursors per plane
        self.cursors: Dict[Tuple[int,int], List[int]] = {(0,p): [0,0,0] for p in range(self.planes)}  # [block, next_pgm_page, next_rd_page]
        self.pages_per_block = topo["pages_per_block"]
        self.blocks_per_plane = topo["blocks_per_plane"]
        # simplistic programmed set per plane
        self.programmed: Dict[Tuple[int,int], Set[Tuple[int,int]]] = {(0,p): set() for p in range(self.planes)}
        # reservation table per plane: list of (start,end,block)
        self.resv: Dict[Tuple[int,int], List[Tuple[float,float,Optional[int]]]] = {(0,p): [] for p in range(self.planes)}

    # ---- observation / selection / checks ----

    def available_at(self, die:int, plane:int) -> float:
        return self.available[(die,plane)]

    def observe_states(self, die:int, plane:int, now_us: float):
        prog = len(self.programmed[(die,plane)])
        # naive buckets for demo
        pgmable_ratio  = "mid" if prog < 10 else "low"
        readable_ratio = "mid" if prog > 0 else "low"
        plane_busy_frac = "low"  # (could be derived from resv overlap with [now,now+Δ])
        return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls": "host"},
                {"plane_busy_frac": plane_busy_frac})

    def select(self, kind: OpKind, die:int, plane:int) -> List[Address]:
        if kind == OpKind.READ:
            prog = sorted(self.programmed[(die,plane)])
            tgt = prog[0] if prog else (0,0)
            return [Address(die, plane, block=tgt[0], page=tgt[1])]
        if kind == OpKind.DOUT:
            raise RuntimeError("DOUT selection must be provided by obligation targets")
        if kind == OpKind.PROGRAM:
            b, pgm_p, _ = self.cursors[(die,plane)]
            addr = Address(die, plane, block=b, page=pgm_p)
            # advance cursor
            pgm_p += 1
            if pgm_p >= self.pages_per_block:
                pgm_p = 0
                b = (b+1) % self.blocks_per_plane
            self.cursors[(die,plane)] = [b, pgm_p, self.cursors[(die,plane)][2]]
            return [addr]
        if kind == OpKind.ERASE:
            b = self.cursors[(die,plane)][0]
            return [Address(die, plane, block=b, page=None)]
        return [Address(die, plane, block=0, page=0)]

    def precheck(self, kind: OpKind, targets: List[Address], start_hint: float) -> bool:
        """Minimal feasibility check: time overlap + simple block rule."""
        MIN_GUARD = 0.0
        end_hint = start_hint + MIN_GUARD
        # 1) time overlap across all planes in targets
        seen_planes = set()
        for t in targets:
            key = (t.die, t.plane)
            if key in seen_planes: 
                continue
            seen_planes.add(key)
            for (s,e,_) in self.resv[key]:
                if not (end_hint <= s or e <= start_hint):
                    return False
        # 2) simple block rule (placeholder for real dep rules)
        #    forbid ERASE on a block if it's been programmed recently (not tracked here) — skip for demo
        return True

    # ---- reserve / commit ----

    def reserve(self, die:int, plane:int, start:float, end:float, block: Optional[int]=None):
        self.available[(die,plane)] = max(self.available[(die,plane)], end)
        self.resv[(die,plane)].append((start, end, block))

    def commit(self, op: Operation):
        t = op.targets[0]
        key = (t.die, t.plane)
        if op.kind == OpKind.PROGRAM and t.page is not None:
            self.programmed[key].add((t.block, t.page))
        elif op.kind == OpKind.ERASE:
            # erase whole block
            self.programmed[key] = {pp for pp in self.programmed[key] if pp[0] != t.block}

# ---------------------------- Obligation Manager ----------------------------

@dataclass(order=True)
class _ObHeapItem:
    deadline_us: float
    seq: int
    ob: "Obligation" = field(compare=False)

@dataclass
class Obligation:
    require: OpKind
    targets: List[Address]
    deadline_us: float
    boost_factor: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg_list: List[Dict[str,Any]]):
        self.specs = cfg_list
        self.heap: List[_ObHeapItem] = []
        self._seq = 0

    def on_commit(self, op: Operation, now_us: float):
        for spec in self.specs:
            if spec["issuer"] == op.kind.name:
                dt = sample_dist(spec["window_us"])
                ob = Obligation(
                    require = OpKind[spec["require"]],
                    targets = op.targets,
                    deadline_us = now_us + dt,
                    boost_factor = spec["priority_boost"]["boost_factor"],
                    hard_slot = spec["priority_boost"].get("hard_slot", False),
                )
                heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=self._seq, ob=ob))
                self._seq += 1
                print(f"[{now_us:7.2f} us] OBLIG  created: {op.kind.name} -> {ob.require.name} by {ob.deadline_us:7.2f} us, target={_addr_str(ob.targets[0])}")

    def pop_urgent(self, now_us: float, die:int, plane:int,
                   horizon_us: float, earliest_start: float) -> Optional[Obligation]:
        """Return earliest-deadline obligation for this (die,plane) that we still can start by earliest_start."""
        if not self.heap: 
            return None
        kept: List[_ObHeapItem] = []
        chosen: Optional[Obligation] = None
        while self.heap and not chosen:
            item = heapq.heappop(self.heap)
            ob = item.ob
            tgt = ob.targets[0]
            same_plane = (tgt.die == die and tgt.plane == plane)
            in_horizon = ((ob.deadline_us - now_us) <= max(horizon_us, 0.0))
            feasible_time = (earliest_start <= ob.deadline_us)  # coarse feasibility
            if same_plane and in_horizon and feasible_time:
                chosen = ob
                break
            kept.append(item)
        for it in kept:
            heapq.heappush(self.heap, it)
        return chosen

# ---------------------------- Policy Engine ----------------------------

class PolicyEngine:
    def __init__(self, cfg, addr_mgr: AddressManager, obl_mgr: ObligationManager):
        self.cfg = cfg
        self.addr = addr_mgr
        self.obl = obl_mgr

    def _score(self, op_name: str, phase_label: str, global_state: Dict[str,str], local_state: Dict[str,str]) -> float:
        w = self.cfg["weights"]["base"]["host"].get(op_name, 0.0)
        w *= self.cfg["weights"]["g_state"]["pgmable_ratio"].get(global_state["pgmable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_state"]["readable_ratio"].get(global_state["readable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_local"]["plane_busy_frac"].get(local_state["plane_busy_frac"], 1.0)
        near = "MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w *= self.cfg["weights"]["g_phase"].get(op_name, {}).get(near, 1.0)
        return w

    def propose(self, now_us: float, hook: PhaseHook,
                global_state: Dict[str,str], local_state: Dict[str,str],
                earliest_start: float) -> Optional[Operation]:
        # 0) Obligation first (plane/time filtered)
        ob = self.obl.pop_urgent(now_us, hook.die, hook.plane,
                                 horizon_us=10.0, earliest_start=earliest_start)
        if ob:
            if self.addr.precheck(ob.require, ob.targets, start_hint=earliest_start):
                cfg_op = self.cfg["op_specs"][ob.require.name]
                op = build_operation(ob.require, cfg_op, ob.targets)
                op.meta["source"]="obligation"
                return op
            # else: could attempt alternative targets (omitted in demo)

        # 1) Policy path: weighted pick under phase/state
        cand = []
        for name in ["READ", "PROGRAM", "ERASE"]:
            s = self._score(name, hook.label, global_state, local_state)
            if s>0: cand.append((name, s))
        if not cand: return None
        total = sum(s for _,s in cand)
        r = random.random()*total
        acc=0.0
        pick = cand[-1][0]
        for name, s in cand:
            acc += s
            if r <= acc:
                pick=name; break

        kind = OpKind[pick]
        targets = self.addr.select(kind, hook.die, hook.plane)  # P1: multi-plane/fanout 확장 가능
        if not targets:
            return None
        if not self.addr.precheck(kind, targets, start_hint=earliest_start):
            return None
        op = build_operation(kind, self.cfg["op_specs"][pick], targets)
        op.meta["source"]="policy"
        return op

# ---------------------------- Scheduler ----------------------------

class Scheduler:
    def __init__(self, cfg, addr_mgr: AddressManager, policy_engine: PolicyEngine, obl_mgr: ObligationManager):
        self.cfg=cfg; self.addr=addr_mgr; self.SPE=policy_engine; self.obl=obl_mgr
        self.now=0.0
        self.ev=[]  # (time, seq, type, payload)
        self._seq=0
        self.stat_propose_calls = 0
        self.stat_scheduled = 0
        self._push(0.0, "QUEUE_REFILL", None)
        # Bootstrap hooks per plane
        for plane in range(self.addr.planes):
            self._push(0.0, "PHASE_HOOK", PhaseHook(0.0, "BOOT.START", 0, plane))

    def _push(self, t: float, typ: str, payload: Any):
        heapq.heappush(self.ev, (t, self._seq, typ, payload)); self._seq+=1

    def _unique_plane_keys(self, targets: List[Address]) -> List[Tuple[int,int,int]]:
        # (die, plane, block) tuples deduped
        s=set()
        for a in targets:
            s.add((a.die, a.plane, a.block))
        return list(s)

    def _start_time_for_targets(self, targets: List[Address]) -> float:
        # start cannot be earlier than any involved plane's availability
        planes = {(a.die, a.plane) for a in targets}
        avail = [self.addr.available_at(d,p) for (d,p) in planes]
        return max([self.now] + avail)

    def _schedule_operation(self, op: Operation):
        start = self._start_time_for_targets(op.targets)
        dur = sum(seg.dur_us for seg in op.states)
        end  = start + dur
        # reserve for all involved planes
        for d,p,b in self._unique_plane_keys(op.targets):
            self.addr.reserve(d, p, start, end, block=b)
        # events
        self._push(start, "OP_START", op)
        self._push(end,   "OP_END",   op)
        # hooks for each involved plane
        for d,p,_ in self._unique_plane_keys(op.targets):
            hooks = make_phase_hooks(op, start, self.cfg["op_specs"][op.kind.name], d, p)
            for h in hooks:
                self._push(h.time_us, "PHASE_HOOK", h)
        first = op.targets[0]
        print(f"[{self.now:7.2f} us] SCHED  {op.kind.name:7s} on targets={len(op.targets)} start={start:7.2f} end={end:7.2f} 1st={_addr_str(first)} src={op.meta.get('source')}")
        self.stat_scheduled += 1

    def run_until(self, t_end: float):
        while self.ev and self.ev[0][0] <= t_end:
            self.now, _, typ, payload = heapq.heappop(self.ev)
            if typ=="QUEUE_REFILL":
                # seed hooks to keep flow
                for plane in range(self.addr.planes):
                    self._push(self.now, "PHASE_HOOK", PhaseHook(self.now, "REFILL.NUDGE", 0, plane))
                nxt = self.now + self.cfg["policy"]["queue_refill_period_us"]
                self._push(nxt, "QUEUE_REFILL", None)

            elif typ=="PHASE_HOOK":
                hook: PhaseHook = payload
                earliest_start = self.addr.available_at(hook.die, hook.plane)
                global_state, local_state = self.addr.observe_states(hook.die, hook.plane, self.now)
                self.stat_propose_calls += 1
                op = self.SPE.propose(self.now, hook, global_state, local_state, earliest_start)
                if op:
                    self._schedule_operation(op)
                else:
                    # no viable op at this hook; that's fine
                    pass

            elif typ=="OP_START":
                op: Operation = payload
                first = op.targets[0]
                print(f"[{self.now:7.2f} us] START  {op.kind.name:7s} target={_addr_str(first)}")

            elif typ=="OP_END":
                op: Operation = payload
                first = op.targets[0]
                print(f"[{self.now:7.2f} us] END    {op.kind.name:7s} target={_addr_str(first)}")
                # commit state first
                self.addr.commit(op)
                # then obligations
                self.obl.on_commit(op, self.now)

        # summary
        print(f"\n=== Stats ===")
        print(f"propose calls : {self.stat_propose_calls}")
        print(f"scheduled ops : {self.stat_scheduled}")
        if self.stat_propose_calls:
            rate = 100.0 * self.stat_scheduled / self.stat_propose_calls
            print(f"accept ratio  : {rate:.1f}%")

# ---------------------------- Main ----------------------------

def main():
    random.seed(CFG["rng_seed"])
    addr = AddressManager(CFG)
    obl  = ObligationManager(CFG["obligations"])
    spe  = PolicyEngine(CFG, addr, obl)
    sch  = Scheduler(CFG, addr, spe, obl)
    run_until = CFG["policy"]["run_until_us"]
    print("=== NAND Sequence Generator Demo (P0 Patched) ===")
    sch.run_until(run_until)
    print("=== Done ===")

if __name__ == "__main__":
    main()

```

원하는 대로 바로 실행하면 됩니다:

```bash
python3 nandsim_demo_p0.py

```

다음 단계로 가면,
- Hook 시간 양자화(quantize),
- policy phase별 weight 테이블 간소화,
- multi-plane select(fanout/interleave) 옵션,
- duration 래퍼(get_op_duration),
- BusySlot 활용/리포트

같은 P1/P2 항목을 이어서 붙일 수 있어요.

## 👤 User

각 아이템별 risk 평가 후 진행해

## 🤖 Assistant

아래는 보완 항목별 리스크 평가와 바로 진행할 실행 플랜이야.  

원칙: 즉시 효과·구조 이득 큼 = 상위, 광범위 파급·불확실성 큼 = 하위. 단, 필수 개선은 상향 배치.

1) 항목별 리스크 평가

| ID | 보완 항목 | 위험도 | 영향 범위 | 실패 시 증상 | 완화/테스트 포인트 |
| --- | --- | --- | --- | --- | --- |
| A | propose 컨텍스트 정규화(earliest_start/now 적용) – 이미 적용(P0) | 낮음 | SPE/Scheduler 경계 | 리젝션↑ | 훅마다 동일 컨텍스트 전달 여부 로그로 확인 |
| B | pop_urgent plane/시간 필터 – 이미 적용(P0) | 낮음 | Obligation만 | 의무 누락/조기 만료 | deadline 충족률·의무 미충족률 메트릭 |
| C | precheck 최소 구현 – 이미 적용(P0) | 중 | 예약/의존성 표면 | false accept/false reject | 겹침·블록충돌 유닛테스트(단일/다중 plane) |
| D | 다중 plane 예약(Reserve All Targets) – 이미 적용(P0) | 낮음 | AddressManager | 경합/타임라인 왜곡 | 모든 대상 plane의 available_at 상승 확인 |
| E | observe_states(now) 시간 반영 – 이미 적용(P0) | 낮음 | 정책 가중 | 분포 드리프트 | now 기준 버킷 변화 스냅샷 비교 |
| F | BusySlot 목적 재정의/정리 | 낮음 | 리포팅 | 불필요 메모리 | 유지 시 활용 지표 정의(plane util, overlap) |
| G | observe_states 비율 산식 개선(plane busy, pgm/read ratio 정확화) | 중 | 정책 가중 | 편향된 샘플 | 예약표 기반 가동률 추정·단위테스트 |
| H | 훅 스펙 단순화(START/MID/END 3상 기본형) | 중 | Hook 생성/분포 | 훅 밀도 변화→분포변형 | 구버전 호환: 미지정 시 3상 자동 유도 |
| I | addr.select 다중 plane/인터리브 반환 | 중 | 선택/예약 | 주소 불일치, 예약 누락 | 반환형 고정(List[Address]) + fanout 옵션 |
| J | 의무 타깃 처리 로직(순차 read/pgm, cache read↔dout 오프셋) | 높음(필수) | Obligation/주소 상태 | 잘못된 타깃·의무 미충족 | source-op 트래커·오프셋 함수·회귀테스트 |
| K | 정책 선택 로직: phase-조건 가중으로 단순화 | 낮음 | SPE | 가중 오남용 | 단일 테이블로 시나리오 재현 검증 |
| L | 의무 vs 정책 우선순위(부스팅/하드슬롯) 보강 | 중 | SPE/스케줄 | 의무 마감 소실 | boost window/hard-slot 시나리오 테스트 |
| M | op.movable 필요성 재검토 | 낮음 | 재배치 | 영향 적음 | 후순위(재배치 도입 시 활성) |
| N | 연속 예약·의존성(erase/pgm/read 금지 규칙 강화) | 높음(필수) | dep-check | 순서 위반·데이터 무결성 붕괴 | 블록/페이지 스코프 락·그래프 검사 |
| O | 훅 시간 해상도(quantize) | 낮음 | 이벤트 큐 | 근소한 시간 흔들림 | 전역 SIM_RES_US 도입·회귀 로그 비교 |
| P | plane interleave read 최적화(look-ahead) | 중 | Scheduler | 기대보다 낮은 병렬성 | look-ahead K 제한·전후 util 비교 |
| Q | addr.select vs 의무 타깃 통합 인터페이스 | 낮음 | 선택 API | 코드 중복 | get_targets(kind, source_op=None) 어댑터 |
| R | make_phase_hooks 인자 정리(op.kind로 cfg 조회) | 낮음 | Hook 생성 | 유지보수성 | 내부 조회로 일원화·테스트 동일성 |
| S | duration 계산 래퍼/StateSeq.times 전환 대비 | 중 | Scheduler | dur 오산 | get_op_duration 래퍼 도입·단위테스트 |

필수 개선: J(의무 타깃 처리), N(연속 예약·의존성 강화) — 위험은 높지만, 시퀀스 정합성에 핵심이라 상향.

2) 실행 플랜 (우선순위·병행 가능성 반영)
Step 1 — 저위험/고효율 안정화 (즉시)
- O 훅/이벤트 시간 quantize (전역 SIM_RES_US)
- S get_op_duration(op) 래퍼 도입, _schedule_operation에서 사용
- R make_phase_hooks(op, start, die, plane)로 시그니처 단순화(내부에서 CFG["op_specs"][op.kind.name] 조회)
- G(부분) observe_states의 plane_busy_frac를 available_at(now) > now ? high : low로 최소 보정 (정확 산식은 Step 3)

리스크: 낮음 / 효과: 결정적 타이밍 안정, 유지보수성↑
Step 2 — 의무/정책 충돌 최소화 (필수)
- L 의무 부스팅/하드슬롯 반영: deadline - now <= boost_window일 때 의무 우선 반환. hard_slot=True면 horizon 무시하고 반환(단 precheck는 유지)
- Q get_targets(kind, source_op=None) 어댑터로 의무/정책 타깃 경로 통합
- K 정책 선택을 phase-조건 테이블(START/MID/END)로 단순화

리스크: 중 / 효과: 의무 미충족률↓, 분포 제어 용이
Step 3 — 정합성 강화 (필수·고위험 단계)
- J 의무 타깃 처리 로직:
  - (a) Sequential READ/PGM: page += 1 추적(소스 op 메타 보관)
  - (b) Cache READ→DOUT: DOUT 타깃 = cache-read의 page - 1
  - 소스 op → 의무 op로 타깃 변환 함수(pure function) 도입
- N 의존성/연속 예약:
  - 블록 스코프 락(ERASE ↔ PGM/READ 동시 금지), 페이지 스코프 락(PGM ↔ READ)
  - precheck에 스코프 별 충돌 검사 추가
  - 간단한 의존성 그래프(before/after, scope)로 사이클/위반 검출

리스크: 높음 / 완화: 단계별 게이트(READ/PGM만→ERASE확장), 풍부한 단위테스트
Step 4 — 정책·관측 개선 (중위험)
- I 다중 plane fanout/interleave 지원(반환형 유지, 옵션 추가)
- G(완전) 예약표 기반 가동률 계산(윈도우 커버리지 근사)
- H 훅 3상 기본형 지원(구스펙 호환)
- P READ look-ahead 재배치(효율↑, 정합성 체크 이중검증)

Step 5 — 정리/리포팅
- F BusySlot 활용 확정(유지 시 메트릭) 또는 제거
- 문서/메트릭: 의무 미충족률, accept ratio, plane util, 리젝션 사유 분포

3) 지금 당장 적용할 소규모 패치(요약)
아래 4개는 코드 영향 작고 안정화 효과 큼 — Step 1 즉시 적용:
1. 시간 quantize

```python
SIM_RES_US = 0.01
def quantize(t): return round(t / SIM_RES_US) * SIM_RES_US

# Scheduler._push, OP_START/END, PHASE_HOOK enqueue 시점에 t=quantize(t)
# make_phase_hooks(...) 내부에서 h.time_us = quantize(h.time_us)

```

2. duration 래퍼

```python
def get_op_duration(op): return sum(seg.dur_us for seg in op.states)
# _schedule_operation: dur = get_op_duration(op)

```

3. make_phase_hooks 시그 단순화

```python
def make_phase_hooks(op, start_us, die, plane):
    cfg_op = CFG["op_specs"][op.kind.name]
    ...

```

(호출부에서 cfg 인자 제거)
4. observe_states(now) 최소 보정

```python
def observe_states(die, plane, now_us):
    busy = self.available_at(die, plane) > now_us
    plane_busy_frac = "high" if busy else "low"
    ...

```

원하면 위 4개는 현 통합본에 바로 붙인 코드로 넘겨줄게.

4) 단위테스트 체크리스트 (각 단계 완료 기준)
- 의무 충족률: READ→DOUT 95%+ (horizon/boost 설정 하)
- accept ratio: 훅 대비 스케줄 비율 상승(기준선 대비 +X%)
- 겹침 금지: 같은 block에 ERASE와 READ/PGM 동시 금지 케이스 통과
- 시간 안정성: quantize 전후 동일 시퀀스(seed 고정) 여부
- 분포 안정성: phase별 READ/PROGRAM 비율이 설정 가중과 일치(±허용오차)

다음 메시지에서 Step 1 패치 적용 통합본을 바로 제공할게. 원하면 **Step 2(의무 부스팅·타깃 어댑터·phase-조건 가중)**까지 묶어서 내줄 수도 있어.

## 👤 User

그 전에 phase-조건 별 확률 분포를 어떻게 구현할 건지 확인하고 넘어가자. 내가 의도한 바는 operation-phase 가 곱해진 조건에서의 확률이야. 예를 들면, { "READ.ISSE": { "READ": 0.0, "PROGRAM": 0.0, ...}, "READ.CORE_BUSY": { ...}, "PROGRAM.ISSUE": {...}, ... } 이런 형태야. 너의 계획과 나의 설명이 맞는지 컨펌해줘.

## 🤖 Assistant

맞아—네가 의도한 “operation×phase(=현재 훅의 연산/스테이트/포지션) 조건에서의 확률로 다음 operation을 샘플링” 방식을 그대로 쓸 거야. 나는 이걸 phase-조건 분포 테이블로 구현하고, 존재하면 그걸 1순위로, 없으면 점진적 백오프로 처리하려 했어.
아래처럼 정리할게.
합의되는 모델
- 훅 라벨을 "{CURR_OP}.{STATE}.{POS}"로 표준화

예: READ.CORE_BUSY.START, PROGRAM.ISSUE.END

(POS는 START/MID/END; 네가 원하면 POS 없는 2-튜플도 지원)
- 분포 테이블은 “현재 훅 컨텍스트 → 다음 op 분포”를 매핑:
- 샘플링 우선순위(백오프):
  1. OP.STATE.POS (가장 구체)
  2. OP.STATE
  3. STATE (옵션)
  4. DEFAULT

(해당 분포의 합이 0이거나 키 미존재면 다음 단계로 백오프)
- Obligation 우선: 기한 임박 의무가 있으면 먼저 처리(가능 시 바로 반환); 없을 때만 위 분포로 샘플.
- DOUT: 기본은 의무로만 발생(분포 테이블엔 0으로 두거나 키 생략). 필요하면 포함 가능.

구현 포인트 (간단 패치 스케치)
1) 훅 라벨 파싱

```python
def parse_hook_key(label: str):
    # e.g., "READ.CORE_BUSY.START" -> ("READ","CORE_BUSY","START")
    parts = label.split(".")
    if len(parts) >= 3:
        return parts[0], parts[1], parts[2]
    if len(parts) == 2:
        return parts[0], parts[1], None
    return None, None, None  # BOOT/REFILL 같은 특수 훅은 DEFAULT로

```

2) 분포 가져오기(백오프 포함)

```python
def get_phase_dist(cfg, hook_label: str):
    op, state, pos = parse_hook_key(hook_label)
    pc = cfg.get("phase_conditional", {})
    # 후보 키들: 가장 구체 -> 일반 -> 디폴트
    keys = []
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    if state:                keys.append(state)   # 선택 사항 (원하면 사용)
    keys.append("DEFAULT")
    for k in keys:
        dist = pc.get(k)
        if dist and sum(dist.values()) > 0:
            return dist
    return None  # 최종 백오프는 기존 가중 방식

```

3) PolicyEngine.propose 내부의 선택 로직 교체

```python
# 의무 우선(현행 유지)
ob = self.obl.pop_urgent(...); ...
# 없으면 phase-조건 분포 시도
dist = get_phase_dist(self.cfg, hook.label)
if dist:
    # 필요 시 DOUT 제외
    items = [(name, p) for name,p in dist.items() if name in self.cfg["op_specs"]]
    total = sum(p for _,p in items)
    if total > 0:
        r = random.random() * total
        acc = 0.0
        pick = items[-1][0]
        for name, p in items:
            acc += p
            if r <= acc:
                pick = name; break
        kind = OpKind[pick]
        targets = self.addr.select(kind, hook.die, hook.plane)
        if targets and self.addr.precheck(kind, targets, start_hint=earliest_start):
            op = build_operation(kind, self.cfg["op_specs"][pick], targets)
            op.meta["source"] = "policy.phase_conditional"
            return op
# 백오프: 기존의 곱셈 가중(_score) 방식으로 시도

```

이렇게 하면 **너의 의도(“현재 훅의 OP×STATE(×POS) 조건 분포”)**가 최우선으로 적용되고, 설정이 비어있거나 0합일 때만 기존 가중 곱 방식으로 자연스럽게 내려가.

권장 스키마 (Config에 추가)

```yaml
phase_conditional:
  READ.ISSUE:
    READ: 0.00
    PROGRAM: 0.80
    ERASE: 0.20
  READ.CORE_BUSY.START:
    READ: 0.05
    PROGRAM: 0.85
    ERASE: 0.10
  PROGRAM.ISSUE:
    READ: 0.50
    PROGRAM: 0.25
    ERASE: 0.25
  DEFAULT:
    READ: 0.60
    PROGRAM: 0.30
    ERASE: 0.10

```

주의/테스트
- 키 표준화: 훅 라벨과 테이블 키 모두 대문자 & 공백 없이(CORE_BUSY)로 맞추자. (질문 예의 READ.ISSE는 READ.ISSUE로 교정)
- 합 1.0 강제 X: 합이 1이 아니어도 가중치로 취급(정규화 없이 룰렛).
- 기록: 어떤 키로 선택됐는지 op.meta["phase_key_used"] 저장 → 분포 튜닝/검증 시각화.

이 구조면 네가 원한 “operation-phase 곱 조건 분포”가 그대로 반영돼. 원하면 지금 통합본에 이 로직을 바로 붙여서 업데이트해줄게.

## 👤 User

업데이트 해줘.

## 🤖 Assistant

아래는 phase-조건 분포(현재 훅의 OP.STATE(.POS) 조건에서 다음 operation 확률을 직접 지정) 를 통합한 업데이트 버전 단일 파일입니다.
- CFG["phase_conditional"] 추가
- 훅 라벨 파싱 → OP.STATE.POS/OP.STATE → DEFAULT 순 백오프
- PolicyEngine.propose가 의무 우선 → phase-조건 분포 → (백오프) 기존 가중 방식 순으로 선택
- 선택된 phase 키는 op.meta["phase_key_used"]에 기록

파일명 예: nandsim_demo_p0_phase.py

```python
# nandsim_demo_p0_phase.py — P0 통합본 + Phase-Conditional 분포
# - Event-jump Scheduler
# - Phase Hook 생성(스케줄러)
# - PolicyEngine: obligation 우선 → "OP.STATE(.POS)" 분포 → 가중(score) 백오프
# - AddressManager: state snapshot(now), precheck/reserve with multi-plane
# - 간단 통계: propose calls / scheduled ops

from __future__ import annotations
import heapq, random
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple, Set

# ---------------------------- Config ----------------------------

CFG = {
    "rng_seed": 12345,
    "policy": {
        "queue_refill_period_us": 3.0,
        "lookahead_k": 4,
        "run_until_us": 150.0,
    },
    "weights": {  # (phase-conditional 없을 때 백오프용)
        "base": {  # class=host only for demo
            "host": {
                "READ": 0.85,
                "PROGRAM": 0.10,
                "ERASE": 0.05,
                "SR": 0.00,
                "RESET": 0.00,
                "DOUT": 0.00,  # obligation-driven only
            }
        },
        "g_state": {  # very light demo weights
            "pgmable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.8},
            "readable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.9},
        },
        "g_local": {"plane_busy_frac": {"low": 1.2, "mid": 1.0, "high": 0.9}},
        "g_phase": {
            "READ": {"START_NEAR": 1.2, "MID_NEAR": 0.9, "END_NEAR": 1.2},
            "PROGRAM": {"START_NEAR": 1.1, "MID_NEAR": 1.0, "END_NEAR": 0.9},
            "ERASE": {"START_NEAR": 0.9, "MID_NEAR": 1.1, "END_NEAR": 1.1},
            "SR": {"START_NEAR": 1.0, "MID_NEAR": 1.0, "END_NEAR": 1.0},
            "RESET": {"START_NEAR": 1.0, "MID_NEAR": 1.0, "END_NEAR": 1.0},
        },
    },
    "mixture": {"classes": {"host": 1.0}},  # host-only for demo
    # phase-conditional: 훅 컨텍스트(OP.STATE 또는 OP.STATE.POS) → 다음 op 분포
    "phase_conditional": {
        "READ.ISSUE":              {"READ": 0.00, "PROGRAM": 0.80, "ERASE": 0.20},
        "READ.CORE_BUSY.START":    {"READ": 0.05, "PROGRAM": 0.85, "ERASE": 0.10},
        "READ.CORE_BUSY.MID":      {"READ": 0.10, "PROGRAM": 0.70, "ERASE": 0.20},
        "READ.DATA_OUT.START":     {"READ": 0.60, "PROGRAM": 0.25, "ERASE": 0.15},
        "PROGRAM.ISSUE":           {"READ": 0.50, "PROGRAM": 0.25, "ERASE": 0.25},
        "PROGRAM.CORE_BUSY.END":   {"READ": 0.60, "PROGRAM": 0.10, "ERASE": 0.30},
        "DEFAULT":                 {"READ": 0.60, "PROGRAM": 0.30, "ERASE": 0.10},
    },
    "op_specs": {
        "READ": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 8.0, "std": 1.5, "min": 2.0}},
                {"name": "DATA_OUT", "dist": {"kind": "normal", "mean": 2.0, "std": 0.4, "min": 0.5}},
            ],
            "hooks": [
                {"when": "STATE_START", "states": ["ISSUE", "CORE_BUSY", "DATA_OUT"], "jitter_us": 0.1},
                {"when": "STATE_MID", "states": ["CORE_BUSY"], "jitter_us": 0.2},
                {"when": "STATE_END", "states": ["DATA_OUT"], "jitter_us": 0.1},
            ],
            "phase_offset_us": {"default": 0.0},
        },
        "DOUT": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.2}},
                {"name": "DATA_OUT", "dist": {"kind": "normal", "mean": 1.0, "std": 0.2, "min": 0.2}},
            ],
            "hooks": [
                {"when": "STATE_START", "states": ["DATA_OUT"], "jitter_us": 0.05},
                {"when": "STATE_END", "states": ["DATA_OUT"], "jitter_us": 0.05},
            ],
            "phase_offset_us": {"default": 0.0},
        },
        "PROGRAM": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 20.0, "std": 3.0, "min": 8.0}},
            ],
            "hooks": [{"when": "STATE_END", "states": ["CORE_BUSY"], "jitter_us": 0.2}],
            "phase_offset_us": {"default": 0.0},
        },
        "ERASE": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 40.0, "std": 5.0, "min": 15.0}},
            ],
            "hooks": [{"when": "STATE_END", "states": ["CORE_BUSY"], "jitter_us": 0.2}],
            "phase_offset_us": {"default": 0.0},
        },
    },
    "obligations": [
        {
            "issuer": "READ",
            "require": "DOUT",
            "window_us": {"kind": "normal", "mean": 6.0, "std": 1.5, "min": 1.0},
            "priority_boost": {"start_us_before_deadline": 2.5, "boost_factor": 2.0, "hard_slot": True},
        }
    ],
    "priority": {
        "order": ["HOST", "READ", "DOUT", "ERASE", "PROGRAM_NEW", "PROGRAM_TARGET", "SR", "RESET"],
        "starvation_aging_alpha": 0.01,
    },
    "topology": {"dies": 1, "planes_per_die": 2, "blocks_per_plane": 4, "pages_per_block": 16},
}

# ---------------------------- Models ----------------------------

class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)

@dataclass
class BusySlot:
    start_us: float
    end_us: float
    op: Operation

def _addr_str(a: Address)->str:
    return f"(d{a.die},p{a.plane},b{a.block},pg{a.page})"

# ---------------------------- Utility: Distributions & Phase Keys ----------------------------

def sample_dist(d: Dict[str, Any]) -> float:
    k = d["kind"]
    if k == "fixed":
        return float(d["value"])
    if k == "normal":
        m, s = d["mean"], d["std"]
        mn = d.get("min", 0.0)
        v = random.gauss(m, s)
        return max(v, mn)
    if k == "exp":
        lam = d["lambda"]
        return random.expovariate(lam)
    raise ValueError(f"unknown dist kind: {k}")

def rand_jitter(ampl_us: float) -> float:
    if ampl_us<=0: return 0.0
    return random.uniform(-ampl_us, ampl_us)

def parse_hook_key(label: str):
    # e.g., "READ.CORE_BUSY.START" -> ("READ","CORE_BUSY","START")
    parts = label.split(".")
    if len(parts) >= 3:
        return parts[0], parts[1], parts[2]
    if len(parts) == 2:
        return parts[0], parts[1], None
    return None, None, None  # BOOT/REFILL 등

def get_phase_dist(cfg: Dict[str,Any], hook_label: str):
    op, state, pos = parse_hook_key(hook_label)
    pc = cfg.get("phase_conditional", {})
    candidates = []
    if op and state and pos: candidates.append(f"{op}.{state}.{pos}")
    if op and state:         candidates.append(f"{op}.{state}")
    candidates.append("DEFAULT")
    for key in candidates:
        dist = pc.get(key)
        if dist and sum(dist.values()) > 0:
            return dist, key
    return None, None

# ---------------------------- OpSpec: build ops & hooks ----------------------------

def build_operation(kind: OpKind, cfg_op: Dict[str, Any], targets: List[Address]) -> Operation:
    states=[]
    for s in cfg_op["states"]:
        dur = sample_dist(s["dist"])
        states.append(StateSeg(name=s["name"], dur_us=dur))
    return Operation(kind=kind, targets=targets, states=states)

def make_phase_hooks(op: Operation, start_us: float, cfg_op: Dict[str, Any], die:int, plane:int) -> List[PhaseHook]:
    hooks_cfg = cfg_op.get("hooks", [])
    offset = cfg_op.get("phase_offset_us",{}).get("default",0.0)
    base_t = start_us + offset
    hooks=[]
    cur = base_t
    for seg in op.states:
        seg_start = cur
        seg_mid   = cur + seg.dur_us*0.5
        seg_end   = cur + seg.dur_us
        for rule in hooks_cfg:
            if seg.name not in rule["states"]:
                continue
            jitter = rule.get("jitter_us", 0.0)
            if rule["when"]=="STATE_START":
                hooks.append(PhaseHook(time_us=seg_start + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.START", die=die, plane=plane))
            elif rule["when"]=="STATE_MID":
                hooks.append(PhaseHook(time_us=seg_mid   + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.MID",   die=die, plane=plane))
            elif rule["when"]=="STATE_END":
                hooks.append(PhaseHook(time_us=seg_end   + rand_jitter(jitter), label=f"{op.kind.name}.{seg.name}.END",   die=die, plane=plane))
        cur = seg_end
    return hooks

# ---------------------------- Address Manager ----------------------------

class AddressManager:
    def __init__(self, cfg: Dict[str, Any]):
        topo = cfg["topology"]
        self.dies = topo["dies"]
        self.planes = topo["planes_per_die"]
        # plane availability absolute times
        self.available: Dict[Tuple[int,int], float] = {(0,p): 0.0 for p in range(self.planes)}
        # rotating cursors per plane
        self.cursors: Dict[Tuple[int,int], List[int]] = {(0,p): [0,0,0] for p in range(self.planes)}  # [block, next_pgm_page, next_rd_page]
        self.pages_per_block = topo["pages_per_block"]
        self.blocks_per_plane = topo["blocks_per_plane"]
        # simplistic programmed set per plane
        self.programmed: Dict[Tuple[int,int], Set[Tuple[int,int]]] = {(0,p): set() for p in range(self.planes)}
        # reservation table per plane: list of (start,end,block)
        self.resv: Dict[Tuple[int,int], List[Tuple[float,float,Optional[int]]]] = {(0,p): [] for p in range(self.planes)}

    # ---- observation / selection / checks ----

    def available_at(self, die:int, plane:int) -> float:
        return self.available[(die,plane)]

    def observe_states(self, die:int, plane:int, now_us: float):
        prog = len(self.programmed[(die,plane)])
        # naive buckets for demo
        pgmable_ratio  = "mid" if prog < 10 else "low"
        readable_ratio = "mid" if prog > 0 else "low"
        plane_busy_frac = "high" if self.available_at(die,plane) > now_us else "low"
        return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls": "host"},
                {"plane_busy_frac": plane_busy_frac})

    def select(self, kind: OpKind, die:int, plane:int) -> List[Address]:
        if kind == OpKind.READ:
            prog = sorted(self.programmed[(die,plane)])
            tgt = prog[0] if prog else (0,0)
            return [Address(die, plane, block=tgt[0], page=tgt[1])]
        if kind == OpKind.DOUT:
            raise RuntimeError("DOUT selection must be provided by obligation targets")
        if kind == OpKind.PROGRAM:
            b, pgm_p, _ = self.cursors[(die,plane)]
            addr = Address(die, plane, block=b, page=pgm_p)
            # advance cursor
            pgm_p += 1
            if pgm_p >= self.pages_per_block:
                pgm_p = 0
                b = (b+1) % self.blocks_per_plane
            self.cursors[(die,plane)] = [b, pgm_p, self.cursors[(die,plane)][2]]
            return [addr]
        if kind == OpKind.ERASE:
            b = self.cursors[(die,plane)][0]
            return [Address(die, plane, block=b, page=None)]
        return [Address(die, plane, block=0, page=0)]

    def precheck(self, kind: OpKind, targets: List[Address], start_hint: float) -> bool:
        """Minimal feasibility check: time overlap + simple block rule."""
        MIN_GUARD = 0.0
        end_hint = start_hint + MIN_GUARD
        # 1) time overlap across all planes in targets
        seen_planes = set()
        for t in targets:
            key = (t.die, t.plane)
            if key in seen_planes: 
                continue
            seen_planes.add(key)
            for (s,e,_) in self.resv[key]:
                if not (end_hint <= s or e <= start_hint):
                    return False
        # 2) simple block rule (placeholder)
        return True

    # ---- reserve / commit ----

    def reserve(self, die:int, plane:int, start:float, end:float, block: Optional[int]=None):
        self.available[(die,plane)] = max(self.available[(die,plane)], end)
        self.resv[(die,plane)].append((start, end, block))

    def commit(self, op: Operation):
        t = op.targets[0]
        key = (t.die, t.plane)
        if op.kind == OpKind.PROGRAM and t.page is not None:
            self.programmed[key].add((t.block, t.page))
        elif op.kind == OpKind.ERASE:
            # erase whole block
            self.programmed[key] = {pp for pp in self.programmed[key] if pp[0] != t.block}

# ---------------------------- Obligation Manager ----------------------------

@dataclass(order=True)
class _ObHeapItem:
    deadline_us: float
    seq: int
    ob: "Obligation" = field(compare=False)

@dataclass
class Obligation:
    require: OpKind
    targets: List[Address]
    deadline_us: float
    boost_factor: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg_list: List[Dict[str,Any]]):
        self.specs = cfg_list
        self.heap: List[_ObHeapItem] = []
        self._seq = 0

    def on_commit(self, op: Operation, now_us: float):
        for spec in self.specs:
            if spec["issuer"] == op.kind.name:
                dt = sample_dist(spec["window_us"])
                ob = Obligation(
                    require = OpKind[spec["require"]],
                    targets = op.targets,
                    deadline_us = now_us + dt,
                    boost_factor = spec["priority_boost"]["boost_factor"],
                    hard_slot = spec["priority_boost"].get("hard_slot", False),
                )
                heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=self._seq, ob=ob))
                self._seq += 1
                print(f"[{now_us:7.2f} us] OBLIG  created: {op.kind.name} -> {ob.require.name} by {ob.deadline_us:7.2f} us, target={_addr_str(ob.targets[0])}")

    def pop_urgent(self, now_us: float, die:int, plane:int,
                   horizon_us: float, earliest_start: float) -> Optional[Obligation]:
        """Return earliest-deadline obligation for this (die,plane) that we still can start by earliest_start."""
        if not self.heap: 
            return None
        kept: List[_ObHeapItem] = []
        chosen: Optional[Obligation] = None
        while self.heap and not chosen:
            item = heapq.heappop(self.heap)
            ob = item.ob
            tgt = ob.targets[0]
            same_plane = (tgt.die == die and tgt.plane == plane)
            in_horizon = ((ob.deadline_us - now_us) <= max(horizon_us, 0.0)) or ob.hard_slot
            feasible_time = (earliest_start <= ob.deadline_us)  # coarse feasibility
            if same_plane and in_horizon and feasible_time:
                chosen = ob
                break
            kept.append(item)
        for it in kept:
            heapq.heappush(self.heap, it)
        return chosen

# ---------------------------- Policy Engine ----------------------------

class PolicyEngine:
    def __init__(self, cfg, addr_mgr: AddressManager, obl_mgr: ObligationManager):
        self.cfg = cfg
        self.addr = addr_mgr
        self.obl = obl_mgr

    def _score(self, op_name: str, phase_label: str, global_state: Dict[str,str], local_state: Dict[str,str]) -> float:
        w = self.cfg["weights"]["base"]["host"].get(op_name, 0.0)
        w *= self.cfg["weights"]["g_state"]["pgmable_ratio"].get(global_state["pgmable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_state"]["readable_ratio"].get(global_state["readable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_local"]["plane_busy_frac"].get(local_state["plane_busy_frac"], 1.0)
        near = "MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w *= self.cfg["weights"]["g_phase"].get(op_name, {}).get(near, 1.0)
        return w

    def _roulette(self, dist: Dict[str, float], allow: set) -> Optional[str]:
        items = [(name, p) for name, p in dist.items() if name in allow and p > 0.0]
        if not items: 
            return None
        total = sum(p for _, p in items)
        r = random.random() * total
        acc = 0.0
        pick = items[-1][0]
        for name, p in items:
            acc += p
            if r <= acc:
                pick = name; break
        return pick

    def propose(self, now_us: float, hook: PhaseHook,
                global_state: Dict[str,str], local_state: Dict[str,str],
                earliest_start: float) -> Optional[Operation]:
        # 0) Obligation first (plane/time filtered)
        ob = self.obl.pop_urgent(now_us, hook.die, hook.plane,
                                 horizon_us=10.0, earliest_start=earliest_start)
        if ob:
            if self.addr.precheck(ob.require, ob.targets, start_hint=earliest_start):
                cfg_op = self.cfg["op_specs"][ob.require.name]
                op = build_operation(ob.require, cfg_op, ob.targets)
                op.meta["source"]="obligation"
                op.meta["phase_key_used"]="(obligation)"
                return op
            # else: could attempt alternative targets (omitted in demo)

        # 1) Phase-conditional distribution (OP.STATE.POS → OP.STATE → DEFAULT)
        allow = set(self.cfg["op_specs"].keys()) - {"DOUT"}  # DOUT는 의무 기본
        dist, used_key = get_phase_dist(self.cfg, hook.label)
        if dist:
            pick = self._roulette(dist, allow)
            if pick:
                kind = OpKind[pick]
                targets = self.addr.select(kind, hook.die, hook.plane)
                if targets and self.addr.precheck(kind, targets, start_hint=earliest_start):
                    op = build_operation(kind, self.cfg["op_specs"][pick], targets)
                    op.meta["source"]="policy.phase_conditional"
                    op.meta["phase_key_used"]=used_key
                    return op
            # dist가 있어도 타깃/사전검사 실패 시 score 백오프 시도

        # 2) Backoff: 기존 곱셈 가중(score) 방식
        cand = []
        for name in ["READ", "PROGRAM", "ERASE"]:
            s = self._score(name, hook.label, global_state, local_state)
            if s>0: cand.append((name, s))
        if not cand: return None
        total = sum(s for _,s in cand)
        r = random.random()*total
        acc=0.0
        pick = cand[-1][0]
        for name, s in cand:
            acc += s
            if r <= acc:
                pick=name; break

        kind = OpKind[pick]
        targets = self.addr.select(kind, hook.die, hook.plane)
        if not targets:
            return None
        if not self.addr.precheck(kind, targets, start_hint=earliest_start):
            return None
        op = build_operation(kind, self.cfg["op_specs"][pick], targets)
        op.meta["source"]="policy.score_backoff"
        op.meta["phase_key_used"]="(score_backoff)"
        return op

# ---------------------------- Scheduler ----------------------------

class Scheduler:
    def __init__(self, cfg, addr_mgr: AddressManager, policy_engine: PolicyEngine, obl_mgr: ObligationManager):
        self.cfg=cfg; self.addr=addr_mgr; self.SPE=policy_engine; self.obl=obl_mgr
        self.now=0.0
        self.ev=[]  # (time, seq, type, payload)
        self._seq=0
        self.stat_propose_calls = 0
        self.stat_scheduled = 0
        self._push(0.0, "QUEUE_REFILL", None)
        # Bootstrap hooks per plane
        for plane in range(self.addr.planes):
            self._push(0.0, "PHASE_HOOK", PhaseHook(0.0, "BOOT.START", 0, plane))

    def _push(self, t: float, typ: str, payload: Any):
        heapq.heappush(self.ev, (t, self._seq, typ, payload)); self._seq+=1

    def _unique_plane_keys(self, targets: List[Address]) -> List[Tuple[int,int,int]]:
        # (die, plane, block) tuples deduped
        s=set()
        for a in targets:
            s.add((a.die, a.plane, a.block))
        return list(s)

    def _start_time_for_targets(self, targets: List[Address]) -> float:
        # start cannot be earlier than any involved plane's availability
        planes = {(a.die, a.plane) for a in targets}
        avail = [self.addr.available_at(d,p) for (d,p) in planes]
        return max([self.now] + avail)

    def _schedule_operation(self, op: Operation):
        start = self._start_time_for_targets(op.targets)
        dur = sum(seg.dur_us for seg in op.states)
        end  = start + dur
        # reserve for all involved planes
        for d,p,b in self._unique_plane_keys(op.targets):
            self.addr.reserve(d, p, start, end, block=b)
        # events
        self._push(start, "OP_START", op)
        self._push(end,   "OP_END",   op)
        # hooks for each involved plane
        for d,p,_ in self._unique_plane_keys(op.targets):
            hooks = make_phase_hooks(op, start, self.cfg["op_specs"][op.kind.name], d, p)
            for h in hooks:
                self._push(h.time_us, "PHASE_HOOK", h)
        first = op.targets[0]
        print(f"[{self.now:7.2f} us] SCHED  {op.kind.name:7s} on targets={len(op.targets)} start={start:7.2f} end={end:7.2f} 1st={_addr_str(first)} src={op.meta.get('source')} key={op.meta.get('phase_key_used')}")
        self.stat_scheduled += 1

    def run_until(self, t_end: float):
        while self.ev and self.ev[0][0] <= t_end:
            self.now, _, typ, payload = heapq.heappop(self.ev)
            if typ=="QUEUE_REFILL":
                # seed hooks to keep flow
                for plane in range(self.addr.planes):
                    self._push(self.now, "PHASE_HOOK", PhaseHook(self.now, "REFILL.NUDGE", 0, plane))
                nxt = self.now + self.cfg["policy"]["queue_refill_period_us"]
                self._push(nxt, "QUEUE_REFILL", None)

            elif typ=="PHASE_HOOK":
                hook: PhaseHook = payload
                earliest_start = self.addr.available_at(hook.die, hook.plane)
                global_state, local_state = self.addr.observe_states(hook.die, hook.plane, self.now)
                self.stat_propose_calls += 1
                op = self.SPE.propose(self.now, hook, global_state, local_state, earliest_start)
                if op:
                    self._schedule_operation(op)
                else:
                    # no viable op at this hook; that's fine
                    pass

            elif typ=="OP_START":
                op: Operation = payload
                first = op.targets[0]
                print(f"[{self.now:7.2f} us] START  {op.kind.name:7s} target={_addr_str(first)}")

            elif typ=="OP_END":
                op: Operation = payload
                first = op.targets[0]
                print(f"[{self.now:7.2f} us] END    {op.kind.name:7s} target={_addr_str(first)}")
                # commit state first
                self.addr.commit(op)
                # then obligations
                self.obl.on_commit(op, self.now)

        # summary
        print(f"\n=== Stats ===")
        print(f"propose calls : {self.stat_propose_calls}")
        print(f"scheduled ops : {self.stat_scheduled}")
        if self.stat_propose_calls:
            rate = 100.0 * self.stat_scheduled / self.stat_propose_calls
            print(f"accept ratio  : {rate:.1f}%")

# ---------------------------- Main ----------------------------

def main():
    random.seed(CFG["rng_seed"])
    addr = AddressManager(CFG)
    obl  = ObligationManager(CFG["obligations"])
    spe  = PolicyEngine(CFG, addr, obl)
    sch  = Scheduler(CFG, addr, spe, obl)
    run_until = CFG["policy"]["run_until_us"]
    print("=== NAND Sequence Generator Demo (P0 + Phase-Conditional) ===")
    sch.run_until(run_until)
    print("=== Done ===")

if __name__ == "__main__":
    main()

```

메모
- CFG["phase_conditional"]에서 정의되지 않은 훅은 자동으로 DEFAULT → (없거나 합이 0이면) 기존 가중(score) 방식으로 백오프합니다.
- DOUT은 여전히 의무(READ→DOUT) 로만 발생하도록 필터링되어 있어요. 필요하면 분포에 넣을 수도 있지만, 현재 구조에서는 의무 우선 규칙이 자연스럽습니다.
- 어떤 phase 키가 실제로 쓰였는지는 key=... 로 로그에 표시됩니다.

원하면 여기에 시간 양자화(quantize), duration 래퍼, fanout/interleave 옵션까지 이어서 묶어줄게.

## 👤 User

묶어서 제공해줘.

## 🤖 Assistant

좋아—요청한 항목을 한 파일에 모두 묶은 통합본이야.  

포함된 개선사항:
- Phase-조건 분포(훅 라벨 OP.STATE(.POS) → 다음 op 확률)
- 시간 양자화(SIM_RES_US, quantize)
- duration 래퍼(get_op_duration)
- multi-plane fanout / interleave (config 기반, AddressManager.select(..., fanout, interleave))

파일명 예: nandsim_demo_p1_bundle.py

```python
# nandsim_demo_p1_bundle.py — Phase-conditional + Quantize + Duration wrapper + Multi-plane fanout/interleave
# Stdlib only.

from __future__ import annotations
import heapq, random
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple, Set

# ---------------------------- Simulation Resolution ----------------------------
SIM_RES_US = 0.01
def quantize(t: float) -> float:
    return round(t / SIM_RES_US) * SIM_RES_US

# ---------------------------- Config ----------------------------

CFG = {
    "rng_seed": 12345,
    "policy": {
        "queue_refill_period_us": 3.0,
        "lookahead_k": 4,
        "run_until_us": 180.0,
    },
    # backoff weights (phase-conditional 미존재/0합일 때 사용)
    "weights": {
        "base": {"host": {"READ": 0.85, "PROGRAM": 0.10, "ERASE": 0.05, "SR": 0.00, "RESET": 0.00, "DOUT": 0.00}},
        "g_state": {"pgmable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.8},
                    "readable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.9}},
        "g_local": {"plane_busy_frac": {"low": 1.2, "mid": 1.0, "high": 0.9}},
        "g_phase": {
            "READ": {"START_NEAR": 1.2, "MID_NEAR": 0.9, "END_NEAR": 1.2},
            "PROGRAM": {"START_NEAR": 1.1, "MID_NEAR": 1.0, "END_NEAR": 0.9},
            "ERASE": {"START_NEAR": 0.9, "MID_NEAR": 1.1, "END_NEAR": 1.1},
            "SR": {"START_NEAR": 1.0, "MID_NEAR": 1.0, "END_NEAR": 1.0},
            "RESET": {"START_NEAR": 1.0, "MID_NEAR": 1.0, "END_NEAR": 1.0},
        },
    },
    "mixture": {"classes": {"host": 1.0}},  # demo: host only
    # 현재 훅 컨텍스트(OP.STATE 또는 OP.STATE.POS) → 다음 op 확률
    "phase_conditional": {
        "READ.ISSUE":              {"READ": 0.00, "PROGRAM": 0.80, "ERASE": 0.20},
        "READ.CORE_BUSY.START":    {"READ": 0.05, "PROGRAM": 0.85, "ERASE": 0.10},
        "READ.CORE_BUSY.MID":      {"READ": 0.10, "PROGRAM": 0.70, "ERASE": 0.20},
        "READ.DATA_OUT.START":     {"READ": 0.60, "PROGRAM": 0.25, "ERASE": 0.15},
        "PROGRAM.ISSUE":           {"READ": 0.50, "PROGRAM": 0.25, "ERASE": 0.25},
        "PROGRAM.CORE_BUSY.END":   {"READ": 0.60, "PROGRAM": 0.10, "ERASE": 0.30},
        "DEFAULT":                 {"READ": 0.60, "PROGRAM": 0.30, "ERASE": 0.10},
    },
    # fanout / interleave 정책 (phase별 override 지원)
    "selection": {
        "defaults": {
            "READ":    {"fanout": 1, "interleave": True},
            "PROGRAM": {"fanout": 1, "interleave": True},
            "ERASE":   {"fanout": 1, "interleave": False},
        },
        # OP.STATE(.POS) → {fanout, interleave} override
        "phase_overrides": {
            "READ.CORE_BUSY.START": {"fanout": 2, "interleave": True},  # 예: CORE_BUSY 시작엔 2-plane READ
        }
    },
    "op_specs": {
        "READ": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 8.0, "std": 1.5, "min": 2.0}},
                {"name": "DATA_OUT", "dist": {"kind": "normal", "mean": 2.0, "std": 0.4, "min": 0.5}},
            ],
            "hooks": [
                {"when": "STATE_START", "states": ["ISSUE", "CORE_BUSY", "DATA_OUT"], "jitter_us": 0.1},
                {"when": "STATE_MID", "states": ["CORE_BUSY"], "jitter_us": 0.2},
                {"when": "STATE_END", "states": ["DATA_OUT"], "jitter_us": 0.1},
            ],
            "phase_offset_us": {"default": 0.0},
        },
        "DOUT": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.2}},
                {"name": "DATA_OUT", "dist": {"kind": "normal", "mean": 1.0, "std": 0.2, "min": 0.2}},
            ],
            "hooks": [
                {"when": "STATE_START", "states": ["DATA_OUT"], "jitter_us": 0.05},
                {"when": "STATE_END", "states": ["DATA_OUT"], "jitter_us": 0.05},
            ],
            "phase_offset_us": {"default": 0.0},
        },
        "PROGRAM": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 20.0, "std": 3.0, "min": 8.0}},
            ],
            "hooks": [{"when": "STATE_END", "states": ["CORE_BUSY"], "jitter_us": 0.2}],
            "phase_offset_us": {"default": 0.0},
        },
        "ERASE": {
            "states": [
                {"name": "ISSUE", "dist": {"kind": "fixed", "value": 0.4}},
                {"name": "CORE_BUSY", "dist": {"kind": "normal", "mean": 40.0, "std": 5.0, "min": 15.0}},
            ],
            "hooks": [{"when": "STATE_END", "states": ["CORE_BUSY"], "jitter_us": 0.2}],
            "phase_offset_us": {"default": 0.0},
        },
    },
    "obligations": [
        {
            "issuer": "READ",
            "require": "DOUT",
            "window_us": {"kind": "normal", "mean": 6.0, "std": 1.5, "min": 1.0},
            "priority_boost": {"start_us_before_deadline": 2.5, "boost_factor": 2.0, "hard_slot": True},
        }
    ],
    "priority": {
        "order": ["HOST", "READ", "DOUT", "ERASE", "PROGRAM_NEW", "PROGRAM_TARGET", "SR", "RESET"],
        "starvation_aging_alpha": 0.01,
    },
    "topology": {"dies": 1, "planes_per_die": 4, "blocks_per_plane": 8, "pages_per_block": 16},
}

# ---------------------------- Models ----------------------------

class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)

@dataclass
class BusySlot:
    start_us: float
    end_us: float
    op: Operation

def _addr_str(a: Address)->str:
    return f"(d{a.die},p{a.plane},b{a.block},pg{a.page})"

# ---------------------------- Utility ----------------------------

def sample_dist(d: Dict[str, Any]) -> float:
    k = d["kind"]
    if k == "fixed":
        return float(d["value"])
    if k == "normal":
        m, s = d["mean"], d["std"]
        mn = d.get("min", 0.0)
        v = random.gauss(m, s)
        return max(v, mn)
    if k == "exp":
        lam = d["lambda"]
        return random.expovariate(lam)
    raise ValueError(f"unknown dist kind: {k}")

def rand_jitter(ampl_us: float) -> float:
    if ampl_us<=0: return 0.0
    return random.uniform(-ampl_us, ampl_us)

def parse_hook_key(label: str):
    # e.g., "READ.CORE_BUSY.START" -> ("READ","CORE_BUSY","START")
    parts = label.split(".")
    if len(parts) >= 3:
        return parts[0], parts[1], parts[2]
    if len(parts) == 2:
        return parts[0], parts[1], None
    return None, None, None  # BOOT/REFILL 등 비정형 훅

def get_phase_dist(cfg: Dict[str,Any], hook_label: str):
    op, state, pos = parse_hook_key(hook_label)
    pc = cfg.get("phase_conditional", {})
    candidates = []
    if op and state and pos: candidates.append(f"{op}.{state}.{pos}")
    if op and state:         candidates.append(f"{op}.{state}")
    candidates.append("DEFAULT")
    for key in candidates:
        dist = pc.get(key)
        if dist and sum(dist.values()) > 0:
            return dist, key
    return None, None

def get_phase_selection_override(cfg: Dict[str,Any], hook_label: str, kind_name: str):
    # fanout/interleave 결정: phase override > defaults
    op, state, pos = parse_hook_key(hook_label)
    po = cfg.get("selection", {}).get("phase_overrides", {})
    keys = []
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    for k in keys:
        val = po.get(k)
        if val:
            f = int(val.get("fanout", 1))
            iv = bool(val.get("interleave", True))
            return f, iv
    dflt = cfg.get("selection", {}).get("defaults", {}).get(kind_name, {"fanout":1,"interleave":True})
    return int(dflt.get("fanout",1)), bool(dflt.get("interleave", True))

def get_op_duration(op: Operation) -> float:
    # wrapper: 현재는 상대 duration 합, 추후 StateSeq.times(절대)로 대체 가능
    return sum(seg.dur_us for seg in op.states)

# ---------------------------- OpSpec: build ops & hooks ----------------------------

def build_operation(kind: OpKind, cfg_op: Dict[str, Any], targets: List[Address]) -> Operation:
    states=[]
    for s in cfg_op["states"]:
        dur = sample_dist(s["dist"])
        states.append(StateSeg(name=s["name"], dur_us=dur))
    return Operation(kind=kind, targets=targets, states=states)

def make_phase_hooks(cfg: Dict[str,Any], op: Operation, start_us: float, die:int, plane:int) -> List[PhaseHook]:
    cfg_op = cfg["op_specs"][op.kind.name]
    hooks_cfg = cfg_op.get("hooks", [])
    offset = cfg_op.get("phase_offset_us",{}).get("default",0.0)
    base_t = start_us + offset
    hooks=[]
    cur = base_t
    for seg in op.states:
        seg_start = cur
        seg_mid   = cur + seg.dur_us*0.5
        seg_end   = cur + seg.dur_us
        for rule in hooks_cfg:
            if seg.name not in rule["states"]:
                continue
            jitter = rule.get("jitter_us", 0.0)
            if rule["when"]=="STATE_START":
                hooks.append(PhaseHook(time_us=quantize(seg_start + rand_jitter(jitter)), label=f"{op.kind.name}.{seg.name}.START", die=die, plane=plane))
            elif rule["when"]=="STATE_MID":
                hooks.append(PhaseHook(time_us=quantize(seg_mid   + rand_jitter(jitter)), label=f"{op.kind.name}.{seg.name}.MID",   die=die, plane=plane))
            elif rule["when"]=="STATE_END":
                hooks.append(PhaseHook(time_us=quantize(seg_end   + rand_jitter(jitter)), label=f"{op.kind.name}.{seg.name}.END",   die=die, plane=plane))
        cur = seg_end
    return hooks

# ---------------------------- Address Manager ----------------------------

class AddressManager:
    def __init__(self, cfg: Dict[str, Any]):
        topo = cfg["topology"]
        self.cfg = cfg
        self.dies = topo["dies"]
        self.planes = topo["planes_per_die"]
        self.pages_per_block = topo["pages_per_block"]
        self.blocks_per_plane = topo["blocks_per_plane"]

        self.available: Dict[Tuple[int,int], float] = {(0,p): 0.0 for p in range(self.planes)}
        self.cursors: Dict[Tuple[int,int], List[int]] = {(0,p): [0,0,0] for p in range(self.planes)}  # [block, next_pgm_page, next_rd_page]
        self.programmed: Dict[Tuple[int,int], Set[Tuple[int,int]]] = {(0,p): set() for p in range(self.planes)}
        self.resv: Dict[Tuple[int,int], List[Tuple[float,float,Optional[int]]]] = {(0,p): [] for p in range(self.planes)}

    # ---- observation / selection / checks ----

    def available_at(self, die:int, plane:int) -> float:
        return self.available[(die,plane)]

    def observe_states(self, die:int, plane:int, now_us: float):
        prog = len(self.programmed[(die,plane)])
        pgmable_ratio  = "mid" if prog < 10 else "low"
        readable_ratio = "mid" if prog > 0 else "low"
        plane_busy_frac = "high" if self.available_at(die,plane) > now_us else "low"
        return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls": "host"},
                {"plane_busy_frac": plane_busy_frac})

    def _plane_ring(self, start_plane:int, fanout:int, interleave:bool) -> List[int]:
        # interleave=True면 start_plane부터 시계방향으로 fanout개 선택
        if fanout <= 1:
            return [start_plane]
        ring = []
        P = self.planes
        idx = start_plane
        for _ in range(fanout):
            ring.append(idx)
            idx = (idx + 1) % P  # 간단 인접 분산
        return ring

    def select(self, kind: OpKind, die:int, plane:int, fanout:int=1, interleave:bool=True) -> List[Address]:
        planes = self._plane_ring(plane, fanout, interleave)
        targets: List[Address] = []
        for pl in planes:
            if kind == OpKind.READ:
                prog = sorted(self.programmed[(die,pl)])
                tgt = prog[0] if prog else (0,0)
                targets.append(Address(die, pl, block=tgt[0], page=tgt[1]))
            elif kind == OpKind.DOUT:
                raise RuntimeError("DOUT selection must be provided by obligation targets")
            elif kind == OpKind.PROGRAM:
                b, pgm_p, _ = self.cursors[(die,pl)]
                targets.append(Address(die, pl, block=b, page=pgm_p))
                # advance cursor
                pgm_p += 1
                if pgm_p >= self.pages_per_block:
                    pgm_p = 0
                    b = (b+1) % self.blocks_per_plane
                self.cursors[(die,pl)] = [b, pgm_p, self.cursors[(die,pl)][2]]
            elif kind == OpKind.ERASE:
                b = self.cursors[(die,pl)][0]
                targets.append(Address(die, pl, block=b, page=None))
            else:
                targets.append(Address(die, pl, block=0, page=0))
        return targets

    def precheck(self, kind: OpKind, targets: List[Address], start_hint: float) -> bool:
        """Minimal feasibility check: time overlap + simple block rule placeholder."""
        start_hint = quantize(start_hint)
        end_hint = start_hint  # guard 0 for now
        seen_planes = set()
        for t in targets:
            key = (t.die, t.plane)
            if key in seen_planes: 
                continue
            seen_planes.add(key)
            for (s,e,_) in self.resv[key]:
                if not (end_hint <= s or e <= start_hint):
                    return False
        # TODO: extend with scope rules (block/page conflicts)
        return True

    def reserve(self, die:int, plane:int, start:float, end:float, block: Optional[int]=None):
        start = quantize(start); end = quantize(end)
        self.available[(die,plane)] = max(self.available[(die,plane)], end)
        self.resv[(die,plane)].append((start, end, block))

    def commit(self, op: Operation):
        t = op.targets[0]
        key = (t.die, t.plane)
        if op.kind == OpKind.PROGRAM and t.page is not None:
            self.programmed[key].add((t.block, t.page))
        elif op.kind == OpKind.ERASE:
            self.programmed[key] = {pp for pp in self.programmed[key] if pp[0] != t.block}

# ---------------------------- Obligation Manager ----------------------------

@dataclass(order=True)
class _ObHeapItem:
    deadline_us: float
    seq: int
    ob: "Obligation" = field(compare=False)

@dataclass
class Obligation:
    require: OpKind
    targets: List[Address]
    deadline_us: float
    boost_factor: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg_list: List[Dict[str,Any]]):
        self.specs = cfg_list
        self.heap: List[_ObHeapItem] = []
        self._seq = 0

    def on_commit(self, op: Operation, now_us: float):
        for spec in self.specs:
            if spec["issuer"] == op.kind.name:
                dt = sample_dist(spec["window_us"])
                ob = Obligation(
                    require = OpKind[spec["require"]],
                    targets = op.targets,
                    deadline_us = quantize(now_us + dt),
                    boost_factor = spec["priority_boost"]["boost_factor"],
                    hard_slot = spec["priority_boost"].get("hard_slot", False),
                )
                heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=self._seq, ob=ob))
                self._seq += 1
                print(f"[{now_us:7.2f} us] OBLIG  created: {op.kind.name} -> {ob.require.name} by {ob.deadline_us:7.2f} us, target={_addr_str(ob.targets[0])}")

    def pop_urgent(self, now_us: float, die:int, plane:int,
                   horizon_us: float, earliest_start: float) -> Optional[Obligation]:
        """Earliest-deadline obligation for this (die,plane) feasible at earliest_start."""
        if not self.heap: 
            return None
        kept: List[_ObHeapItem] = []
        chosen: Optional[Obligation] = None
        now_us = quantize(now_us)
        earliest_start = quantize(earliest_start)
        while self.heap and not chosen:
            item = heapq.heappop(self.heap)
            ob = item.ob
            tgt = ob.targets[0]
            same_plane = (tgt.die == die and tgt.plane == plane)
            in_horizon = ((ob.deadline_us - now_us) <= max(horizon_us, 0.0)) or ob.hard_slot
            feasible_time = (earliest_start <= ob.deadline_us)
            if same_plane and in_horizon and feasible_time:
                chosen = ob
                break
            kept.append(item)
        for it in kept:
            heapq.heappush(self.heap, it)
        return chosen

# ---------------------------- Policy Engine ----------------------------

class PolicyEngine:
    def __init__(self, cfg, addr_mgr: AddressManager, obl_mgr: ObligationManager):
        self.cfg = cfg
        self.addr = addr_mgr
        self.obl = obl_mgr

    def _score(self, op_name: str, phase_label: str, global_state: Dict[str,str], local_state: Dict[str,str]) -> float:
        w = self.cfg["weights"]["base"]["host"].get(op_name, 0.0)
        w *= self.cfg["weights"]["g_state"]["pgmable_ratio"].get(global_state["pgmable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_state"]["readable_ratio"].get(global_state["readable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_local"]["plane_busy_frac"].get(local_state["plane_busy_frac"], 1.0)
        near = "MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w *= self.cfg["weights"]["g_phase"].get(op_name, {}).get(near, 1.0)
        return w

    def _roulette(self, dist: Dict[str, float], allow: set) -> Optional[str]:
        items = [(name, p) for name, p in dist.items() if name in allow and p > 0.0]
        if not items: 
            return None
        total = sum(p for _, p in items)
        r = random.random() * total
        acc = 0.0
        pick = items[-1][0]
        for name, p in items:
            acc += p
            if r <= acc:
                pick = name; break
        return pick

    def propose(self, now_us: float, hook: PhaseHook,
                global_state: Dict[str,str], local_state: Dict[str,str],
                earliest_start: float) -> Optional[Operation]:
        # 0) Obligation 우선 (plane/time 필터)
        ob = self.obl.pop_urgent(now_us, hook.die, hook.plane,
                                 horizon_us=10.0, earliest_start=earliest_start)
        if ob:
            if self.addr.precheck(ob.require, ob.targets, start_hint=earliest_start):
                cfg_op = self.cfg["op_specs"][ob.require.name]
                op = build_operation(ob.require, cfg_op, ob.targets)
                op.meta["source"]="obligation"
                op.meta["phase_key_used"]="(obligation)"
                return op

        # 1) Phase-conditional 분포 시도
        allow = set(self.cfg["op_specs"].keys()) - {"DOUT"}  # DOUT은 의무 기본
        dist, used_key = get_phase_dist(self.cfg, hook.label)
        fanout, interleave = get_phase_selection_override(self.cfg, hook.label, "<DEFAULT>")
        if dist:
            pick = self._roulette(dist, allow)
            if pick:
                fanout, interleave = get_phase_selection_override(self.cfg, hook.label, pick)
                kind = OpKind[pick]
                targets = self.addr.select(kind, hook.die, hook.plane, fanout=fanout, interleave=interleave)
                if targets and self.addr.precheck(kind, targets, start_hint=earliest_start):
                    op = build_operation(kind, self.cfg["op_specs"][pick], targets)
                    op.meta["source"]="policy.phase_conditional"
                    op.meta["phase_key_used"]=used_key
                    op.meta["fanout"]=fanout; op.meta["interleave"]=interleave
                    return op
            # 실패 시 score 백오프

        # 2) Backoff: 기존 곱셈 가중(score)
        cand = []
        for name in ["READ", "PROGRAM", "ERASE"]:
            s = self._score(name, hook.label, global_state, local_state)
            if s>0: cand.append((name, s))
        if not cand: return None
        total = sum(s for _,s in cand)
        r = random.random()*total
        acc=0.0
        pick = cand[-1][0]
        for name, s in cand:
            acc += s
            if r <= acc:
                pick=name; break

        kind = OpKind[pick]
        fanout, interleave = get_phase_selection_override(self.cfg, hook.label, pick)
        targets = self.addr.select(kind, hook.die, hook.plane, fanout=fanout, interleave=interleave)
        if not targets:
            return None
        if not self.addr.precheck(kind, targets, start_hint=earliest_start):
            return None
        op = build_operation(kind, self.cfg["op_specs"][pick], targets)
        op.meta["source"]="policy.score_backoff"
        op.meta["phase_key_used"]="(score_backoff)"
        op.meta["fanout"]=fanout; op.meta["interleave"]=interleave
        return op

# ---------------------------- Scheduler ----------------------------

class Scheduler:
    def __init__(self, cfg, addr_mgr: AddressManager, policy_engine: PolicyEngine, obl_mgr: ObligationManager):
        self.cfg=cfg; self.addr=addr_mgr; self.SPE=policy_engine; self.obl=obl_mgr
        self.now=0.0
        self.ev=[]  # (time, seq, type, payload)
        self._seq=0
        self.stat_propose_calls = 0
        self.stat_scheduled = 0
        self._push(0.0, "QUEUE_REFILL", None)
        # Bootstrap hooks per plane
        for plane in range(self.addr.planes):
            self._push(0.0, "PHASE_HOOK", PhaseHook(0.0, "BOOT.START", 0, plane))

    def _push(self, t: float, typ: str, payload: Any):
        t = quantize(t)
        heapq.heappush(self.ev, (t, self._seq, typ, payload)); self._seq+=1

    def _unique_plane_keys(self, targets: List[Address]) -> List[Tuple[int,int,int]]:
        s=set()
        for a in targets:
            s.add((a.die, a.plane, a.block))
        return list(s)

    def _start_time_for_targets(self, targets: List[Address]) -> float:
        planes = {(a.die, a.plane) for a in targets}
        avail = [self.addr.available_at(d,p) for (d,p) in planes]
        return quantize(max([self.now] + avail))

    def _schedule_operation(self, op: Operation):
        start = self._start_time_for_targets(op.targets)
        dur = get_op_duration(op)
        end  = quantize(start + dur)
        # reserve for all involved planes
        for d,p,b in self._unique_plane_keys(op.targets):
            self.addr.reserve(d, p, start, end, block=b)
        # events
        self._push(start, "OP_START", op)
        self._push(end,   "OP_END",   op)
        # hooks for each involved plane
        for d,p,_ in self._unique_plane_keys(op.targets):
            hooks = make_phase_hooks(self.cfg, op, start, d, p)
            for h in hooks:
                self._push(h.time_us, "PHASE_HOOK", h)
        first = op.targets[0]
        print(f"[{self.now:7.2f} us] SCHED  {op.kind.name:7s} tgt={len(op.targets)} start={start:7.2f} end={end:7.2f} 1st={_addr_str(first)} src={op.meta.get('source')} key={op.meta.get('phase_key_used')} fanout={op.meta.get('fanout')}")

        self.stat_scheduled += 1

    def run_until(self, t_end: float):
        t_end = quantize(t_end)
        while self.ev and self.ev[0][0] <= t_end:
            self.now, _, typ, payload = heapq.heappop(self.ev)
            if typ=="QUEUE_REFILL":
                for plane in range(self.addr.planes):
                    self._push(self.now, "PHASE_HOOK", PhaseHook(self.now, "REFILL.NUDGE", 0, plane))
                nxt = quantize(self.now + self.cfg["policy"]["queue_refill_period_us"])
                self._push(nxt, "QUEUE_REFILL", None)

            elif typ=="PHASE_HOOK":
                hook: PhaseHook = payload
                earliest_start = self.addr.available_at(hook.die, hook.plane)
                global_state, local_state = self.addr.observe_states(hook.die, hook.plane, self.now)
                self.stat_propose_calls += 1
                op = self.SPE.propose(self.now, hook, global_state, local_state, earliest_start)
                if op:
                    self._schedule_operation(op)

            elif typ=="OP_START":
                op: Operation = payload
                first = op.targets[0]
                print(f"[{self.now:7.2f} us] START  {op.kind.name:7s} target={_addr_str(first)}")

            elif typ=="OP_END":
                op: Operation = payload
                first = op.targets[0]
                print(f"[{self.now:7.2f} us] END    {op.kind.name:7s} target={_addr_str(first)}")
                self.addr.commit(op)
                self.obl.on_commit(op, self.now)

        print(f"\n=== Stats ===")
        print(f"propose calls : {self.stat_propose_calls}")
        print(f"scheduled ops : {self.stat_scheduled}")
        if self.stat_propose_calls:
            rate = 100.0 * self.stat_scheduled / self.stat_propose_calls
            print(f"accept ratio  : {rate:.1f}%")

# ---------------------------- Main ----------------------------

def main():
    random.seed(CFG["rng_seed"])
    addr = AddressManager(CFG)
    obl  = ObligationManager(CFG["obligations"])
    spe  = PolicyEngine(CFG, addr, obl)
    sch  = Scheduler(CFG, addr, spe, obl)
    run_until = CFG["policy"]["run_until_us"]
    print("=== NAND Sequence Generator Demo (Bundled: phase+quantize+fanout) ===")
    sch.run_until(run_until)
    print("=== Done ===")

if __name__ == "__main__":
    main()

```

사용 방법

```bash
python3 nandsim_demo_p1_bundle.py

```

무엇이 달라졌나 (짧게)
- CFG["phase_conditional"]로 훅 컨텍스트 기반 확률을 최우선 적용, 실패 시 기존 가중(score)로 백오프.
- CFG["selection"]의 defaults와 phase_overrides로 fanout/interleave 제어.
- 이벤트/훅/커밋/의무 데드라인에 시간 양자화 적용으로 타이밍 안정성↑.
- _schedule_operation은 get_op_duration을 사용, 훗날 StateSeq.times로 교체 가능.

다음으로 진행할 때는:
- 의무 타깃 변환 로직(sequential/cached read에 따른 주소 오프셋)과
- 블록/페이지 스코프 의존성 룰(ERASE↔PGM/READ, PGM↔READ 동시 금지)

을 붙이면 정합성이 한층 올라가. 원하면 그 두 가지도 바로 패치본으로 이어서 내줄게.

## 👤 User

=== Stats ===
propose calls : 376
scheduled ops : 370
accept ratio  : 98.4%
=== Done ===
accept ration 가 좀 떨어지긴 했지만, 아직까진 좋아. 
두 가지 진행하기 전에 리뷰하고 가자. 우선 의무 타깃 변환 로직의 대상에 대해 정하고 가자. Sequential read 란, host 의 요청에 의해서 여러 page 를 순차적으로 읽는 동작이야. 예를 들어 20 page 를 순차적으로 읽을 수 있어. 방법 중 하나는 obligation heap 에 모두 push 해 두는 거야. 이 방식의 risk 는 중간에 해당 block 을 policy 에 의해서 erase/program/read 못하는 상황이 발생하는거야. 내 목적은 최대한 host 의 요청을 들어주면서 policy 제안도 할 수 있는 방식이야. 그러기 위해선 obligation 과 policy 의 우선 순위를 조정해야 되겠지. 이처럼 가능한 방법들과, 그것들의 risk 를 정리해봐.

## 🤖 Assistant

좋아. **“Host Sequential READ(연속 페이지 읽기)”**를 어떻게 모델링/스케줄링할지에 대해, 가능한 전략과 각 리스크/완화책을 비교 정리하고, 권장안까지 제시할게. 목표는 **Host SLA(순차 읽기 완주)**와 Policy 제안 자유도를 동시에 확보하는 것.

0) 전제 정리
- 입력: Host가 (block=B, start=P0, length=L) 형태로 Sequential READ 세션을 요청.
- 결과: 페이지 P0..P0+L-1에 대해 READ→DOUT(또는 cache READ→DOUT 규칙) 페어가 순차적으로 등장해야 함.
- 제약: 중간에 같은 block B로의 ERASE/PROGRAM은 원칙적으로 금지(데이터 일관/현실성).
- 목표: Host 우선을 지키되, 다른 block/plane에서는 Policy(GC/PGM 등)가 최대한 병행 가능.

1) 전략 옵션 비교
A. Eager-Per-Page Obligations (전체 페이지를 의무로 한 번에 heap에 투입)
- 방법: 세션 생성 시, READ(B,P0) .. READ(B,P0+L-1)를 전부 Obligation으로 push. 각 READ 커밋 시 해당 페이지의 DOUT 의무를 추가.
- 장점
  - 구현 단순. 의무정책(데드라인 부스팅/하드슬롯) 재사용.
  - 스케줄러가 자유롭게 재배치(같은 block 내 순서만 보장하면 됨).
- 리스크
  - 의무 폭증 → 큐 압박: 타 리소스(다른 plane/block)에서 정책 오퍼가 상대적으로 밀릴 수 있음(우선순위 역전).
  - 중간 상태 변화: 긴 세션 중간에 GC 정책이 해당 block을 건드리려 하면 충돌(실제론 금지해야 함).
  - 데드라인/순서 관리 복잡: 페이지 i보다 j를 먼저 잡는 의사결정(병행/재배치)이 Host의 순차 지연을 키울 수 있음.
- 완화책
  - 같은 block에 대해 soft-freeze(ERASE/PROGRAM 금지) 락.
  - 의무 데드라인을 “증가열”로 부여(i < j면 dl_i < dl_j) → 순서 자연 유도.
  - heap 사이즈 상한 + aging으로 정책 오퍼 기아 방지.

B. Lazy Sliding-Window Obligations (권장)
- 방법: 세션을 Session 객체로 보관하고, 윈도우 크기 W(예: 2~4 페이지)만큼만 의무를 앞단에 유지. READ가 끝나면 다음 페이지 의무를 보충(push).
- 장점
  - 큐 부하/의무 난립 완화: 항상 W개만 활성.
  - 정책 병행 여지↑: 의무 압력이 낮아 다른 block엔 정책 오퍼가 더 자유로움.
  - 순차성·SLA 제어: 페이지별 데드라인/슬랙을 관리해 적절히 부스팅.
- 리스크
  - 윈도우가 너무 작으면 I/O 깊이↓ → Throughput 저하.
  - 너무 크면 A와 같은 압박으로 회귀.
- 완화책
  - W는 plane 가용/예상 READ 지연 기반 적응적 튜닝(예: plane 유휴 비율↑ → W↑).
  - 세션 단위 **soft-freeze(lock)**로 block 충돌 차단.
  - Slack-aware 우선순위(아래 §3): 데드라인-예상소요시간 기준.

C. Composite/Macro Obligation (한 세션=하나의 매크로)
- 방법: 세션 전체를 CompositeObligation으로 모델링. 내부적으로 페이지 i를 순서대로만 배출(강한 순차). 필요시 OP_START/END에 따라 다음 페이지 자동 배출.
- 장점
  - 순서 보장/일관성 최상: 정책 개입으로 순서 깨질 여지↓.
  - 스케줄링 추론이 쉬움(“현재 세션이 배출한 것만 처리”).
- 리스크
  - 병렬성/유연성↓: 다른 block/plane로의 분산 최적화 어렵고, 중간 정책 오퍼 개입 여지 낮음.
  - 구현 복잡: 매크로 내부 상태기계 + 훅 연동.
- 완화책
  - 내부도 윈도우 W로 배출하도록 섞어 B와 유사한 구조로 완화.

D. Hard Reservation(강 락) + 정책 자유
- 방법: 세션 수명 동안 block B를 hard-reserve(ERASE/PROGRAM 절대 금지), READ만 허용. 다른 block/plane엔 정책 자유.
- 장점
  - Host 순차성 보장(데이터 무결).
  - 구현 단순(락/언락만).
- 리스크
  - GC/PGM 정책 유연성 손실: 특정 block에 대한 정책 진척이 중단, 장기적으로 GC 압력↑.
- 완화책
  - TTL/타임아웃: 너무 오래 잡고 있으면 자동 다운그레이드→soft-freeze.
  - “긴 세션은 분할”: L이 큰 요청은 여러 sub-session으로 분할해서 락 기간 짧게.

E. Soft Freeze + Slack-aware Priority (권장 보조기법)
- 방법: 세션 block에는 soft-freeze 태그(ERASE/PROGRAM Weight↓, READ↑)만 걸고, 실제 스케줄은 slack(=deadline−earliest_start−est_cost) 기반으로 Host 의무의 부스팅을 동적으로 적용. Slack이 임계 이하면 Host 우선, 여유면 Policy 허용.
- 장점
  - 균형 잡힌 공존: Host SLA를 지키되, Policy도 idle time에 적극 수행.
  - GC/PGM을 다른 block으로 돌리는 유도 효과.
- 리스크
  - 슬랙 추정 부정확 시 SLA 위반/과도부스팅.
- 완화책
  - 보수적 추정(READ 지연 상계 사용) + 실행 통계로 온라인 보정.

2) 권장 조합 (현 프레임에 가장 잘 맞는 방식)

B. Lazy Sliding-Window + E. Soft Freeze + Slack-aware Priority  

(필요 시 D 하드락을 ‘예외 케이스’로 제한적으로 사용)

이유
- 지금 구조(이벤트 훅 + ObligationManager + precheck)에서 윈도우 기반 보충이 자연스럽고, 큐·우선순위의 압력 제어가 용이.
- soft-freeze로 데이터 무결/충돌 위험을 크게 낮추면서도, 다른 block/plane에선 정책 오퍼를 적극 허용.
- 슬랙 기반 우선순위로 Host 일변도 기아를 방지.

3) 의무 vs. 정책 우선순위 규칙(권장 상세)
1. 세션 생성 시:
  - SeqReadSession{block=B, next=P0, end=P0+L-1, W} 생성.
  - fill_window()로 최대 W개의 READ 의무를 push(데드라인은 증가열).
  - AddressManager에 block=B soft-freeze 태그(ERASE/PROGRAM weight↓, precheck에서 경고/거절 옵션).
2. propose()에서 선택 순서:
  - (a) 급한 의무: deadline - now <= boost_window 또는 hard_slot → 즉시 우선.
  - (b) 슬랙 기반 비교: 다음 READ 의무의 slack이 ≤ slack_threshold면 Host 의무 우선, 아니면 정책 후보 허용.
  - (c) 정책 후보: 단, soft-freeze block은 타겟에서 제외(precheck/weight에서 컷).
  - (d) READ 완료 시: 해당 페이지의 DOUT 의무 push(Δt 분포). 그리고 세션 fill_window()로 다음 READ 보충.
3. 종료:
  - next > end면 세션 종료, soft-freeze 해제.

4) 캐시 리드/시퀀셜 타깃 변환 규칙 (의무 타깃 변환 로직)
- Sequential READ
  - 원본: READ(B, page=k) 커밋
  - DOUT 의무: DOUT(B, page=k) (일반 READ-DOUT)
- Cache READ 시나리오 (네가 언급: cache read 먼저, DOUT 나중; DOUT 주소 page-1)
  - 원본: CACHE_READ(B, page=k) 커밋
  - DOUT 의무: DOUT(B, page=k-1)
- PGM/READ 시퀀스 오프셋
  - Sequential PROGRAM: PROGRAM(B, page=k) 커밋 후, k := k+1로 Session 포인터 진행
  - (필요시) READ 세션과의 충돌은 block soft-freeze로 차단

구현 팁: ObligationTranslator를 넣어 source-op → required-op로 타깃 변환을 순수 함수로 관리:

```python
def translate_obligation(source_op, spec)->List[Address]:
    if spec.require == "DOUT" and source_op.kind == "CACHE_READ":
        return [Address(B, plane, block=source.block, page=source.page-1)]
    # default: same address

```

5) 리스크/완화 요약 표

| 전략 | 주요 리스크 | 증상 | 완화 |
| --- | --- | --- | --- |
| A. Eager 전량 push | 큐 압박, 정책 기아, 순서 지연 | accept ratio는 높아도 정책 커밋↓ | soft-freeze, 증가열 데드라인, heap 상한 |
| B. Lazy Window ✅ | W 선택 부적절 | Throughput 저하 or 큐 압박 | W 적응형, plane 유휴율 기반 조정 |
| C. Composite Macro | 병렬성↓, 구현 복잡 | 정책 제안 기회↓ | 내부 윈도우화, 예외적 적용 |
| D. Hard Reservation | GC/PGM 유연성↓ | 장기적 GC 압력↑ | TTL/Timeout, sub-session 분할 |
| E. Soft Freeze ✅ | 슬랙 추정 오차 | Host 지연 or 과도한 Host 우선 | 보수적 추정, 실행 통계로 보정 |

6) 바로 적용할 구현 계획 (Step-by-step)
1. Session 모델 추가
  - SeqReadSession{block, next, end, window, deadlines[], soft_freeze=True}
  - API: fill_window(now), on_read_commit(page), is_done()
2. ObligationManager 확장
  - on_host_req_seqread(B,P0,L) → Session 생성 + fill_window()
  - on_commit(READ(B,k)) → DOUT(B,k) 의무 push + session.on_read_commit(k) → fill_window()
3. AddressManager soft-freeze
  - block 단위 태그: soft_freeze_blocks={B: ttl}
  - precheck()와 policy weight에서 ERASE/PROGRAM의 거절/패널티 적용
4. SPE 우선순위 로직
  - pop_urgent() → boost window/hard-slot 반영(이미 일부 있음)
  - 슬랙 계산: slack = deadline - earliest_start - est_read_cost
  - slack <= T면 Host 의무 우선, 아니면 policy 허용
  - policy 후보는 soft-freeze block 제외
5. 윈도우 W 튜닝
  - 초기 W=2~4 → 메트릭 기반 조정: Host 지연/accept ratio/plane util 보고 자동 보정

7) 결론 (권고)
- Lazy Sliding-Window + Soft Freeze + Slack-aware Priority 조합으로 가자.
- 캐시리드/순차오프셋은 ObligationTranslator로 중앙집중 처리.
- Hard Reservation은 예외적으로(긴 세션/타임아웃 기준)만 사용.

원하면, 위 설계를 기준으로 Session/Translator를 붙인 P2 패치 코드(데모 수준)까지 한 번에 제공할게.

## 👤 User

좋아. 그런데, 한가지 관점을 추가하자. 결국 내가 하고 싶은 건, 시간 순으로 진행되는 nand sequence 의 output 을 일정한 format 으로 정의하고, 그것을 ATE 가 제공하는 pattern 파일로 변환하는거야. 지금 event 기반의 로직의 장점은 policy 랑 obligation 을 튜닝할 수 있다는 장점이 있어. 하지만 실제로 필요한 것은
- nand sequence 를 시간순 나열해서 output 을 생성
- timeline 에서 die, plane 이 별도로 존재하지 않고 통합된 하나의 sequence 가 존재
- idle time 도 모두 하나의 operation 으로 취급. 예) nop
- 모든 operation 에는 고유한 duration 이 존재. 절대적 resolution 은 없음. nop 도 duration 이 있고, duration 단위를 곱하여 duration 을 확장
이 조건에 맞춰서 현재의 시스템 구조를 평가하고, 계속 이어나가도 괜찮은건지 알려줘

## 🤖 Assistant

핵심부터 결론: 지금의 이벤트 기반 구조를 유지해도, 네가 원하는 “단일 글로벌 시퀀스(Die/Plane 통합) + NOP 포함 + 가변 duration 단위” 출력은 충분히 달성 가능해.  

다만 출력용으로 두 개의 레이어를 추가하면 구조가 깔끔해져:
1. BusResource(인터페이스 자원) 게이팅 레이어 – “버스(채널)”를 실제로 점유하는 상태 구간만 전역 상호배타로 관리
2. GlobalTimelineBuilder(글로벌 타임라인 투영기) – 버스에 나타나는 이벤트를 시간순으로 모아 단일 시퀀스로 직렬화, 갭에는 NOP 삽입, 마지막에 단위 스케일링(ATE 패턴 변환용)

아래에 상세 평가와 변경 포인트/리스크/실행 계획을 정리했어.

1) 요구사항과 현재 구조의 정합성
요구사항 ↔ 현재 구조
- “시간순 나열된 하나의 시퀀스”

→ 현재는 per-plane로 OP_START/OP_END가 동시 다발로 존재. Bus를 점유하는 state만 전역으로 취합하면 하나의 버스 시퀀스로 수렴 가능.
- “die/plane 구분 없는 통합 시퀀스”

→ 내부 스케줄은 die/plane-aware로 유지(현 구조 그대로), 출력 시점에 die/plane 정보는 메타데이터로만 보존하고 단일 스트림으로 직렬화.
- “Idle도 NOP로 취급, 모든 op는 duration 가짐”

→ 현재 StateSeg에 duration 존재. 버스 공백 구간을 계산하여 NOP(duration)을 삽입하면 요건 충족.
- “절대 해상도 없음, NOP duration 확장으로 길이 조절”

→ 내부는 μs 등 연속시간으로 두고, Export 단계에서 TU(Time Unit) 선택 후 dur_units = round(duration/TU)로 벡터화. 필요 시 누적오차 보정용 NOP 보상(±1 unit) 삽입.

따라서 스케줄러/정책/의무 로직은 유지하되, “버스에 보이는 것만”을 전역 타임라인으로 투영하면 된다.

2) 반드시 넣어야 하는 구조 변경(덧씌우기)
(A) BusResource 게이팅 (중요)
- 왜? 두 plane에서 동시에 READ.ISSUE(버스 사용) 같은 버스 구간이 겹치면 단일 시퀀스로 불가능.
- 방법: op_specs.states[*]에 bus 사용 플래그 추가(예: bus: true/false).
  - 예) READ: ISSUE(bus=true), CORE_BUSY(false), DATA_OUT(true)
  - PROGRAM/ERASE: 보통 ISSUE(true), CORE_BUSY(false)
  - DOUT: DATA_OUT(true)
- 스케줄 시점:
  - Operation 예약과 동시에 bus=true인 구간을 분리하여 BusResource에 별도 예약(전역 단일 리소스).
  - 또는 “의무(DOUT)”처럼 후단 버스 구간은 별도 Operation(=DOUT)으로 이미 분리되어 있으니, ISSUE 순간만 BusResource로 보장해도 실용적으로 충분.
- precheck 확장: earliest_start에서 버스 점유 가능 시각도 고려(= bus_available_at).

이렇게 하면 “후보 제안(propose)” 단계에서 겹침 거절률이 크게 낮아지고, 나중 Export 직렬화 시 충돌이 사라짐.

(B) GlobalTimelineBuilder (출력 파이프라인)
- 입력: 스케줄 결과의 이벤트/타임라인(각 Operation의 state 절대 시각)
- 처리:
  1. 모든 Operation의 bus=true state구간을 **(t_start, t_end, kind, meta)**로 수확
  2. 시간 오름차순 정렬 후 인접/중첩 정리(겹침은 BusResource 게이팅으로 원천 차단됨)
  3. 갭 → NOP 삽입: gap = next.start - prev.end가 양수면 NOP(gap)
  4. 벡터화: Export 설정의 TU를 선택 → units = round(duration/TU)
    - 누적오차 보정: 누적 frac을 관리하여 일정 임계 초과 시 NOP ±1 unit 삽입
- 출력: List[SeqItem], 예:
- 이 SeqItem[]을 ATE 변환기(예: CSV→STIL/WGL 변환기)에 전달.

3) Export(ATE) 관점의 설계 포인트
- TU(Time Unit) 선택
  - 기본은 내부 단위(μs)에서 소수점 없는 벡터 유닛으로 바꾸기 위한 스케일.
  - 전략: TU = clamp(min_seg_duration/κ, TU_min, TU_max) (κ=2~4), 너무 작으면 패턴 길이 폭증, 너무 크면 타이밍 손실↑.
  - 누적 오차 보정: fractional drift가 ±0.5 unit 근접 시 NOP로 미세 보정.
- 심볼 세트(예: NAND ONFI 호환 추상 심볼)
  - CMD(opcode), ADDR(n), DIN(n), DOUT(n), WAIT(tR/tPROG), SR, RESET, NOP
  - 여기서 WAIT은 내부 busy를 버스상에서는 NOP로 통합해도 되지만, 의미성 유지 위해 분리 권장(변환기에서 매핑).
- die/plane 매개변수
  - 출력 시퀀스에는 노출하지 않되, ADDR 인코딩 또는 meta에 저장. 변환기에서 주소 비트에 반영.

4) 리스크와 대응

| 리스크 | 원인 | 영향 | 대응 |
| --- | --- | --- | --- |
| 버스 구간 겹침 | 다중 plane에서 동시에 ISSUE/DOUT | 단일 시퀀스 불가 | BusResource 게이팅으로 상호배타 예약 |
| 출력 해상도 손실 | TU가 너무 큼 | 타이밍 왜곡 | TU 자동 선택 + 오차 누적 보정 NOP |
| 의무 데드라인 위반 | 버스 혼잡으로 DOUT 지연 | READ→DOUT SLA 저하 | 슬랙 기반 부스팅 + BusResource 선점 가중 |
| 패턴 길이 폭증 | 너무 작은 TU / 과도 NOP | ATE 파일 비대 | TU 하한/상한, NOP 압축(연속 NOP 병합) |
| 정책 기아 | Host 연속 읽기 세션 집중 | GC/PGM 정체 | Sliding-window(W 제한) + soft-freeze만 적용 |

5) 필요한 설정(YAML/CFG) 확장안

```yaml
export:
  tu_us: 0.01             # ATE time unit(예: 10ns)
  nop_symbol: NOP
  wait_as_nop: true       # WAIT을 NOP로 납작화할지
  drift_correction: true  # 누적 오차 보정 활성화

op_specs:
  READ:
    states:
      - {name: ISSUE,     bus: true,  dist: {...}}
      - {name: CORE_BUSY, bus: false, dist: {...}}
      - {name: DATA_OUT,  bus: true,  dist: {...}}
  PROGRAM:
    states:
      - {name: ISSUE,     bus: true,  dist: {...}}
      - {name: CORE_BUSY, bus: false, dist: {...}}
  ERASE:
    states:
      - {name: ISSUE,     bus: true,  dist: {...}}
      - {name: CORE_BUSY, bus: false, dist: {...}}
  DOUT:
    states:
      - {name: ISSUE,     bus: false, dist: {...}}   # 필요시
      - {name: DATA_OUT,  bus: true,  dist: {...}}

```

6) 구현 스케치 (핵심 메서드)
6.1 BusResource (전역 자원)

```python
class BusResource:
    def __init__(self): self.resv = []  # [(start,end)]
    def available_at(self, t0):
        # t0 이후 첫 비가용 구간을 피해서 earliest start 반환(간단버전은 마지막 end)
        return self.resv[-1][1] if self.resv else t0
    def precheck(self, start, end):
        return all(end <= s or e <= start for (s,e) in self.resv)
    def reserve(self, start, end):
        self.resv.append((start,end))

```

- 스케줄러에서 bus=true 세그먼트를 알면 그 구간만 따로 BusResource에 precheck+reserve.

6.2 GlobalTimelineBuilder

```python
def build_global_timeline(ops, cfg):
    # 1) bus=true 세그먼트 수확
    segs = []
    for op in ops:
        t = op.abs_start
        for s in op.states:
            start, end = t, t + s.dur_us
            if s.bus: segs.append((start, end, op, s))
            t = end
    segs.sort(key=lambda x: x[0])

    # 2) NOP 삽입 + 벡터화
    tu = cfg["export"]["tu_us"]
    items=[]
    tcur=None
    drift=0.0
    for (s,e,op,seg) in segs:
        if tcur is None: tcur = s
        if s > tcur:
            # gap -> NOP
            gap = s - tcur
            units = round((gap + drift)/tu)
            drift += gap - units*tu
            if units>0: items.append(SeqItem("NOP", units, {}))
            tcur = s
        dur = e - s
        units = round((dur + drift)/tu)
        drift += dur - units*tu
        if units>0:
            sym, meta = to_symbol(seg, op)  # CMD/ADDR/DIN/DOUT/…
            items.append(SeqItem(sym, units, meta))
        tcur = e
    return compress_nop(items)  # 연속 NOP 병합

```

to_symbol()은 op.kind/state에 따라 버스에 실리는 심볼과 **메타(opcode/addr/len)**를 구성.

7) 계속 이 구조로 가도 되나? → Yes, with two add-ons
- 정책/의무 튜닝 장점은 그대로 유지.
- BusResource + GlobalTimelineBuilder를 얹어 출력 요구(단일 시퀀스, NOP 포함, 가변 duration)에 정확히 부합.
- 내부 병렬성(plane interleave)은 그대로 살리고, 버스 노출 레벨에서만 직렬화하면 ATE 변환에 적합한 “한 줄짜리” 타임라인이 나온다.

8) 실행 계획(간단 To-Do)
P0 (바로)
1. op_specs.states[*].bus: bool 도입, 기본값 채움
2. BusResource 추가, Scheduler._schedule_operation에서 bus=true 세그먼트 사전검사/예약
3. GlobalTimelineBuilder 초안 구현 + export.tu_us 설정 + NOP 삽입/벡터화/오차보정
4. 통계: bus utilization, NOP 비율, drift 누적

P1  

5. to_symbol() 매핑 테이블 정리(CMD/ADDR/DIN/DOUT/WAIT/NOP)  

6. 슬랙 기반 의무 부스팅에 bus_available_at 반영
P2  

7. ATE 변환기 어댑터(CSV→목표 포맷(STIL/WGL 등))  

8. 회귀: seed 고정 시 패턴 동일성 보장

한 줄 요약
- 현 이벤트 구조는 그대로 두고, (1) Bus 점유 구간을 전역 자원으로 게이팅하고 (2) 버스에 비치는 이벤트만 모아 NOP를 채워 넣는 글로벌 타임라인을 만들면, 네가 원하는 **ATE 패턴 변환용 “하나의 시퀀스”**를 안정적으로 뽑아낼 수 있어.

## 👤 User

계획은 좋아. 여기서 2가지 추가해서 검토하자. multi-plane 동작, 그리고 erase, program CORE_BUSY 에 의 모든 plane 점유야. 세부내용은 아래 참조. 
- multi-plane read, multi-plane pgm, multi-plane erase 동작 추가
- multi-plane 동작은 target plane 이 동시에 여러개이고, ISSUE 시에 plane address 를 (0,1,2,3) 또는 (0,2,3) 으로 전달.
- multi-plane target plane 이 모두 CORE_BUSY 로 점유됨. page 어드레스는 multi-plane 내에서는 동일해야 하고, CORE_BUSY 중간에 SR, RESET 등은 허용 가능해
- sequential multi-plane read, program 도 가능해야 함
- erase, program 이 시작되면 CORE_BUSY 상태가 target die 내 모든 plane 이 동일한 상태로 점유됨.
검토 시작해

## 🤖 Assistant

좋아. 멀티‑플레인 동작과 ERASE/PROGRAM의 die‑wide CORE_BUSY 점유를 넣었을 때의 일관된 의미론(semantics), 스케줄링/사전검사/선택/Export(ATE 변환)까지의 설계 변경점을 정리하고, 위험·완화책과 구현 스텝+코드 스케치까지 제시할게.

1) 합의할 동작 의미(운영 규칙)
1.1 연산별 점유 범위(Scope)와 페이지 제약

| Op | ISSUE 버스 사용 | CORE_BUSY 점유 범위 | 페이지 동기화 | 비고 |
| --- | --- | --- | --- | --- |
| READ (multi-plane) | 단일 ISSUE (plane list: 예 PL={0,1,2,3}) | plane‑set만 점유 | 동일 page 필수 | CORE_BUSY 중에도 SR/RESET 허용(버스만 상호배타) |
| PROGRAM (multi-plane) | 단일 ISSUE (plane list) | die‑wide 점유 (타겟 die의 모든 plane) | 동일 page 필수 | 내부 동기화 요구. SR/RESET 허용 |
| ERASE (multi-plane) | 단일 ISSUE (plane list 또는 block list) | die‑wide 점유 | page 없음 | SR/RESET 허용 |
| DOUT | DATA_OUT 버스 사용 | 없음 | READ와 동일 주소 | 멀티‑플레인 READ 뒤 DOUT은 per plane 또는 묶음 모두 지원 가능(옵션) |
| SR/RESET | 버스 사용 | 없음 | - | 언제든 발행 가능(단, 버스는 상호배타) |

핵심: PROGRAM/ERASE는 CORE_BUSY 동안 die 내 모든 plane이 점유. READ는 선택 plane‑set만 점유.

2) Config 스키마 확장(필수)
2.1 상태별 버스 플래그 + 점유 범위(scope) + 페이지 동기화

```yaml
op_specs:
  READ:
    scope: PLANE_SET              # CORE_BUSY 점유 범위
    page_equal_required: true
    states:
      - {name: ISSUE,     bus: true,  dist: {...}}
      - {name: CORE_BUSY, bus: false, dist: {...}}
      - {name: DATA_OUT,  bus: true,  dist: {...}}

  PROGRAM:
    scope: DIE_WIDE
    page_equal_required: true
    states:
      - {name: ISSUE,     bus: true,  dist: {...}}
      - {name: CORE_BUSY, bus: false, dist: {...}}

  ERASE:
    scope: DIE_WIDE
    page_equal_required: false
    states:
      - {name: ISSUE,     bus: true,  dist: {...}}
      - {name: CORE_BUSY, bus: false, dist: {...}}

  DOUT:
    scope: NONE
    page_equal_required: true
    states:
      - {name: ISSUE,     bus: false, dist: {...}}
      - {name: DATA_OUT,  bus: true,  dist: {...}}

```

2.2 멀티‑플레인 선택 정책(phase override 포함)

```yaml
selection:
  defaults:
    READ:    {fanout: 1, interleave: true}
    PROGRAM: {fanout: 2, interleave: true}      # 멀티‑플레인 시도
    ERASE:   {fanout: 2, interleave: false}
  phase_overrides:
    "READ.CORE_BUSY.START": {fanout: 4, interleave: true}

```

2.3 Export(ATE) 관련

```yaml
export:
  tu_us: 0.01
  nop_symbol: NOP
  wait_as_nop: true
  drift_correction: true
  dout_grouping: "per_plane"     # or "plane_set"

```

3) 스케줄러/선택/사전검사 변경점
3.1 Operation 메타(필드) 확장
- op.meta["plane_list"] = [0,2,3] (ISSUE 시 전달용)
- op.meta["scope"] ∈ {PLANE_SET, DIE_WIDE, NONE}
- op.targets: List[Address]는 plane‑set 전체 주소(모든 plane에 동일 page 보장)

3.2 AddressManager: 멀티‑플레인 타깃 계획(plan) API

fanout을 원하는 값에서 가능한 값으로 자동 강등(degrade)하며 페이지 동기화를 만족시키는 plane‑set/주소를 반환. 실패하면 None.

```python
def plan_multipane(self, kind: OpKind, die:int, start_plane:int, desired_fanout:int, interleave:bool):
    # 1) 후보 plane 링 만들기 (start_plane부터 최대 desired_fanout)
    ring = self._plane_ring(start_plane, desired_fanout, interleave)

    # 2) READ: 모든 후보 plane들에서 "공통으로 읽을 수 있는 page"를 찾음
    #    PROGRAM: 모든 후보 plane의 "next_pgm_page"가 동일한 subset 선택
    #    ERASE: block 단위 선택(페이지 동기화 불필요)
    plane_set, page, blocks = self._find_aligned_subset(kind, die, ring)

    if not plane_set:
        return None  # degrade 실패

    # 3) Address 리스트 구성(READ/PROGRAM: 동일 page, ERASE: 대상 block)
    targets = ...
    scope = DIE_WIDE if kind in {PROGRAM, ERASE} else PLANE_SET
    return targets, plane_set, scope

```

_find_aligned_subset은 페이지 동기화를 만족하는 최대 subset을 고르는 탐욕(greedy) 알고리즘. 안 맞으면 fanout을 1까지 줄이며 시도.

3.3 precheck() 확장 (시간/충돌/스코프)

```python
def precheck(self, kind, targets, start_hint, scope) -> bool:
    # 시간 겹침: scope==DIE_WIDE면 die의 모든 plane 예약과 비교,
    # scope==PLANE_SET이면 targets의 plane들과 비교
    # 충돌 룰: 같은 block에 ERASE와 READ/PROGRAM 동시 금지, PROGRAM↔READ 동시 금지, 등

```

3.4 reserve() 확장

```python
def reserve(self, op, start, end):
    if op.meta["scope"]=="DIE_WIDE":
        for p in all_planes_of_die(op.targets[0].die):
            self._reserve_plane(die, p, start, end, block=None)  # CORE_BUSY 점유
    # bus=true 구간은 BusResource에 별도 예약(아래 §3.5)
    # plane-set scope는 targets의 plane만

```

3.5 BusResource(전역 버스) 게이팅
- op_specs.states[*].bus: true 구간만 전역 단일 자원으로 precheck/reserve.
- SR/RESET은 bus만 사용 → 언제든 발행 가능(버스만 상호배타로 보장).

3.6 PolicyEngine.propose 변경
- pick 이후 선택 단계에서 plan_multipane(...) 호출 → targets, plane_set, scope 수령
- 불가 시 fanout을 자동 낮춰 재시도 → 그래도 안 되면 다른 op로 백오프

4) Obligation/Session 확장 (Sequential multi‑plane)
4.1 Sequential multi‑plane READ/PROGRAM 세션
- SeqSession(kind, die, plane_set, block, next_page, end_page, window W)
- fill_window()가 multi‑plane READ(or PROGRAM) 의무를 페이지 단위로 W개 앞당겨 생성(각 의무는 하나의 연산으로 plane‑set 전체를 목표)
- READ 커밋 시 DOUT 의무 생성:
  - export.dout_grouping == "per_plane" 이면 plane별 DOUT 의무 push
  - "plane_set"이면 묶음 DOUT 의무 push

이렇게 하면 페이지 동기화 요구를 세션이 책임지고, 정책 오퍼와 공존하면서도 Host 순차성 보장(윈도우 W로 압력 제어).

5) Export(ATE) 빌더 영향
- 글로벌 타임라인은 bus=true 구간만 추출 → 시간순 정렬 → 갭은 NOP 삽입.
- 멀티‑플레인 ISSUE/DATA_OUT은 하나의 심볼로 내보내되, meta.plane_list(또는 mask)를 포함:
- PROGRAM/ERASE의 CORE_BUSY는 bus를 쓰지 않으므로 WAIT/NOP로 표현(설정에 따라 WAIT 유지 또는 NOP 압축).
- TU 스케일/누적오차 보정/연속 NOP 병합은 기존 설계 그대로.

6) 리스크 & 완화

| 리스크 | 내용 | 영향 | 완화 |
| --- | --- | --- | --- |
| 페이지 동기화 실패 | candidate plane들 page 불일치 | propose 거절↑ | plan_multipane이 fanout 자동 강등, 세션 모드에서는 내부 포인터 동기화 |
| die‑wide 점유로 병렬성↓ | PROGRAM/ERASE가 die 전체 막음 | 처리량 저하 | 정책 가중에서 READ 우선, PROGRAM/ERASE는 비혼잡 구간/다른 die에서 수행 |
| 버스 혼잡 | 멀티‑플레인 DOUT/ISSUE가 길어짐 | 의무 데드라인 위험 | BusResource 선점 가중 + 슬랙 기반 부스팅 |
| Export 길이 폭증 | 다수 NOP/세밀 TU | 파일 비대 | TU 자동 선택 + NOP 병합 + wait_as_nop=false 선택지 |
| SR/RESET 난입 타이밍 | CORE_BUSY 중 SR/RESET | 오해석 | “버스만 상호배타”를 명확화, 타임라인에 SR/RESET 심볼 그대로 노출 |

7) 구현 스텝(증분, 실패 위험 낮게)
Step 1 — 데이터 모델 & precheck/예약 스코프
- op_specs.*.scope, page_equal_required, states[*].bus 반영
- Operation.meta["scope"] 채우기
- AddressManager.precheck/reserve가 scope별 검사/예약 수행

Step 2 — 멀티‑플레인 선택기
- plan_multipane(kind, die, start_plane, fanout, interleave) -> (targets, plane_set, scope) or None
- PolicyEngine.propose에서 위 선택기를 사용(자동 강등 포함)

Step 3 — BusResource 게이팅
- states[*].bus==true 구간만 별도 전역 자원으로 precheck/reserve
- earliest_start 계산에 BusResource 반영(ISSUE/DATA_OUT 앞당김/지연)

Step 4 — 세션 & 의무(선택)
- SeqSession(READ/PROGRAM) + sliding window W, DOUT grouping 옵션
- ObligationManager에 on_host_req_seq*/on_commit 경로 추가

Step 5 — Export 빌더
- bus=true 구간 수확 → NOP 삽입 → TU 스케일 → ATE 패턴 변환(심볼 매핑 표)

8) 코드 스케치(핵심 인터페이스)
8.1 scope/페이지 동기화 정보

```python
from enum import Enum
class Scope(Enum): NONE=0; PLANE_SET=1; DIE_WIDE=2

# build_operation 후:
op.meta["scope"] = Scope[self.cfg["op_specs"][op.kind.name]["scope"]]
op.meta["plane_list"] = sorted({a.plane for a in targets})

```

8.2 plan_multipane()

```python
def plan_multipane(self, kind, die, start_plane, desired_fanout, interleave):
    ring = self._plane_ring(start_plane, desired_fanout, interleave)
    # try largest → smallest
    for f in range(desired_fanout, 0, -1):
        cand = ring[:f]
        ok, page, blocks = self._check_alignment(kind, die, cand)
        if not ok: continue
        targets = self._make_targets(kind, die, cand, page, blocks)
        scope = Scope.DIE_WIDE if kind in (OpKind.PROGRAM, OpKind.ERASE) else Scope.PLANE_SET
        return targets, cand, scope
    return None

```

8.3 precheck()/reserve() 스코프 처리

```python
def precheck(self, kind, targets, start_hint, scope):
    planes = self._all_planes_of_die(targets[0].die) if scope==Scope.DIE_WIDE \
             else {(t.die,t.plane) for t in targets}
    # 시간 겹침 검사(예약표)
    # block/page 충돌 룰 검사
    return True

def reserve(self, op, start, end):
    planes = self._all_planes_of_die(op.targets[0].die) if op.meta["scope"]==Scope.DIE_WIDE \
             else {(t.die,t.plane) for t in op.targets}
    for (d,p) in planes:
        self._reserve_plane(d,p,start,end)
    # bus=true 세그먼트는 BusResource에도 별도 예약

```

8.4 PolicyEngine.propose에서 사용

```python
fanout, interleave = get_phase_selection_override(cfg, hook.label, pick)
plan = self.addr.plan_multipane(kind, hook.die, hook.plane, fanout, interleave)
if not plan: 
    # 자동 강등 모두 실패 → 다른 op로 백오프
targets, plane_set, scope = plan
if not self.addr.precheck(kind, targets, earliest_start, scope): 
    return None
op = build_operation(kind, cfg["op_specs"][pick], targets)
op.meta["scope"] = scope.name
op.meta["plane_list"] = plane_set

```

9) 결론
- 현 이벤트 기반 구조를 유지하면서,

**(i) 연산별 CORE_BUSY 점유 범위(scope)**와 (ii) 멀티‑플레인 페이지 동기화를 선택기(plan_multipane) + 사전검사(precheck) + **예약(reserve)**에 반영하면,

멀티‑플레인 READ/PROGRAM/ERASE, sequential multi‑plane까지 일관되게 지원 가능.
- Export는 bus=true 구간만 모아 전역 단일 시퀀스로 직렬화하고, NOP 채움 + TU 스케일로 ATE 패턴 변환 요구를 그대로 충족.

원하면 위 스펙대로 **작동하는 최소 패치(코드)**를 현재 통합본에 이어붙여 줄게. (plan_multipane / scope-aware precheck & reserve / BusResource 스텁 / Export 빌더 초안)

## 👤 User

_find_aligned_subset 은 greedy 방식은 문제가 있어. 다양한 동작이 나오게끔 하는 것이 목표야. 그리고 multi-plane 동작은, ATE pattern 구현시 하나의 operation 으로 취급해야돼. 나중에 GlobalTimelineBuilder 를 통해서 변환하는 동작이 꽤 복잡해 질수도 있기 때문에. “SIN_READ”, “MUL_READ” 이런식으로 별개로 구분해서 처리하는 건 어떤 거 같아? risk 를 평가해줘

## 🤖 Assistant

좋은 포인트야. 멀티‑플레인 동작을 ATE에서도 “하나의 오퍼레이션”으로 취급하려면, 내부 표현과 출력 심볼 모두에서 단일 개체성을 유지해야 해.  

여기서 선택지가 둘이고, 각각의 리스크를 정리하면 아래와 같아.

옵션 1) OpKind를 쪼개기: SIN_READ, MUL_READ, SIN_PROGRAM, MUL_PROGRAM, SIN_ERASE, MUL_ERASE …
의도: 멀티/싱글을 다른 연산 타입으로 명시한다. (정책/phase 분포, Export 심볼도 명확)
장점
- 명시성↑: phase 조건 분포, 로깅, ATE 변환 시 “MUL_READ” 같은 심볼을 그대로 사용 → 가독성·분석 용이.
- 튜닝 분리 용이: 싱글/멀티를 전혀 다르게 샘플링하고 싶을 때 직접 제어 가능.

리스크
1. 구성(컨피그) 폭증
  - phase_conditional 키가 READ 계열에서 두 배 이상으로 늘고(START/MID/END × SIN/MUL), PROGRAM/ERASE도 동일.
  - 훅 조건 조합이 많을수록 스파스해지고 운영/튜닝 난이도↑.
2. 중복/표류 위험
  - op_specs(state/hook) 정의가 SIN/MUL로 이중화 → 시간이 지나면 사양이 어긋날 수 있음(한쪽만 수정되는 드리프트).
3. 의무/의존성 로직 중복
  - READ→DOUT 의무, die‑wide CORE_BUSY 처리, precheck/예약 스코프 등 두 계열 모두에 반복 구현 필요.
4. 선택 실패/강등 핸들링 복잡
  - MUL_READ를 뽑았는데 정렬 가능한 plane‑set을 못 찾으면 SIN_READ로 degrade 하는 분기 필요.
  - 이때 “이미 MUL을 선택했다”는 정책 의미가 흔들림.

종합 리스크: 중~높음. 운영/튜닝 테이블이 커지고, 구현 중복과 드리프트 관리 비용이 큼.

옵션 2) 단일 OpKind + ‘가산성(arity)’ 메타: READ/PROGRAM/ERASE는 그대로, op.meta.arity와 plane_list로 멀티/싱글 구분
의도: 내부는 단일 연산 모델을 유지(의무/의존성/스케줄링 로직 재사용), Export에서 **심볼만 ‘SIN_’/‘MUL_’**로 매핑.
장점
- 구현·유지보수 안정: precheck/예약/의무/스코프 로직을 한 번만 작성. 드리프트 위험↓.
- 컨피그 관리 용이: phase_conditional은 **기존 키(READ/PROGRAM/ERASE)**로 유지, 대신 별도 ‘arity 분포’(fanout 분포)를 둬 제어.
- degrade 단순: 멀티 정렬 실패 시 아리스티만 줄이면 됨(여전히 READ).

리스크
1. 정책 튜닝 표현력 저하?
  - “MUL_READ만 특별하게” 같은 요구를 표현하려면 별도 arity 분포 테이블이 필요.
2. Export 가시성
  - 로그/리포트에서 ‘MUL_*’를 보고 싶으면 Export/로깅에서 alias 매핑을 해야 함.

종합 리스크: 낮음. 내부 일관성이 높고, 구성 폭발을 막을 수 있음. Export/로깅 레이어에서만 alias 처리.

옵션 3) 하이브리드(권장): 가짜 연산명(에일리어스) 지원
- 정책/분포에서는 SIN_READ/MUL_READ 키를 써도 되게 하고, 내부에서는 이를 에일리어스 → 기본 연산 + arity로 즉시 해석.
  - 예: MUL_READ  → {base:"READ",  arity:≥2}

SIN_READ  → {base:"READ",  arity:1}

MUL_PROGRAM → {base:"PROGRAM", arity:≥2, scope:DIE_WIDE}
- op_specs/의무/precheck/예약/스코프 로직은 **기본 연산(READ/PROGRAM/ERASE)**만 대상으로 유지.
- Export 시에는 op.meta.arity>1 → "MUL_*" 심볼, 아니면 "SIN_*".

장점
- 옵션 1의 명시성 + 옵션 2의 내부 단순성을 모두 취득.
- 정책 테이블에서 튜닝 문법이 직관적(MUL_READ 키 직접 기입)인데, 내부는 중복 구현 없음.
- 정렬 실패 시 alias 해석 단계에서 자연스럽게 arity 강등 재시도 → 정책 의미 유지.

리스크
- 에일리어스 해석 계층의 복잡도(작지만 존재):
  - 에일리어스→기본 연산, arity/fanout 범위, scope(DIE_WIDE/PLANE_SET), page_equal 규칙 매핑.
  - 잘못된 매핑 시 의미 오염 → 테스트 케이스 필수(MUL→SIN 강등, die‑wide 예약 확인 등).

종합 리스크: 낮음~중간. 로컬 복잡도만 증가하고, 전체 시스템 복잡도는 억제.

“greedy _find_aligned_subset 문제”와의 관계
- 옵션 1(쪼개기)는 선택 실패 시 의미 위반 가능성이 커서 더 위험.
- 옵션 2/3에서는, 샘플링‑우선 전략(비탐욕)으로 다양성 확보:
  - 2‑패스 샘플링: (a) plane‑set 후보를 확률적으로 먼저 뽑고, (b) 가능한 page를 샘플 → 불가면 다른 plane‑set으로 재시도(최대 N회), 마지막에 arity 강등.
  - 팬아웃 분포: phase/상황별로 fanout 확률을 명시(예: READ.CORE_BUSY.START에서 4‑plane 확률↑).
  - 다양성 드라이버: 최근 사용된 plane‑set/페이지를 회피하는 penalty를 가중치에 반영.

이렇게 하면 greedy가 아니어도 다양한 멀티‑플레인 패턴을 안정적으로 발생.

ATE/Export 측면 리스크 비교

| 항목 | 옵션 1(쪼개기) | 옵션 2(arity 메타) | 옵션 3(에일리어스) |
| --- | --- | --- | --- |
| 심볼 명확성 | 최고 (MUL_* 직방) | 중 (매핑 필요) | 높음 (내부 매핑 후 심볼 명확) |
| 변환 로직 난이도 | 낮음 | 낮음 | 낮음 |
| 타임라인 단일화 | 동일(버스 구간만 취합) | 동일 | 동일 |
| NOP/WAIT 처리 | 동일 | 동일 | 동일 |

셋 다 Export 난이도는 비슷하지만, 옵션 3이 설정의 직관과 내부 일관성을 동시에 만족.

권장안 (결론)
- **옵션 3: “에일리어스 기반 단일 모델”**로 가자.
  - 정책/분포/로그/Export에서는 SIN_READ/MUL_READ/MUL_PROGRAM/MUL_ERASE 등을 그대로 쓸 수 있고,
  - 내부는 기본 OpKind(READ/PROGRAM/ERASE) + meta.arity + meta.plane_list + scope로 단일 구현 유지.
  - 정렬 실패/강등은 에일리어스 해석(선택기)에서 처리하되, 정책 의미 보존을 위해 강등 로그와 카운터를 필수로 남김.

구현 메모 (간단 스펙)
- 에일리어스 테이블
- phase_conditional는 SIN_READ/MUL_READ 키를 허용.

→ PolicyEngine에서 에일리어스이면 해석→기본 op + fanout 목표로 변환.
- **선택기(plan_multipane)**는 샘플링 방식(비탐욕) + 최대 시도 N + 강등.
- precheck/reserve는 이미 scope(PLANE_SET/DIE_WIDE)별로 동작(앞서 설계).

리스크 요약(에일리어스 방식)
- 구성 폭증: 낮음 — 테이블은 늘지만 코드 중복 없음, 분포 조작도 직관적.
- 구현 중복/표류: 낮음 — 내부 로직 재사용.
- 선택 실패/강등: 중간 — 에일리어스 해석부에 국한, 로그/메트릭로 관리 가능.
- Export 복잡도: 낮음 — arity>1이면 MUL_* 심볼로 내보내기.

최종 판단: 네 요구(ATE에서 멀티‑플레인=“하나의 오퍼레이션”)를 정면으로 만족하면서, 시스템 복잡도를 최소화하려면 **에일리어스 기반 단일 모델(옵션 3)**이 가장 안전하고, 튜닝/테스트/유지 측면에서 리스크가 가장 낮다.

원하면, 지금 통합본에 에일리어스 파서 + 비탐욕 선택기 + 강등 로깅을 바로 넣은 패치 버전으로 제공할게.

## 👤 User

좋아. 제공해줘

## 🤖 Assistant

아래는 에일리어스 기반 멀티‑플레인 지원 + die‑wide CORE_BUSY 점유 + BusResource 게이팅을 통합한 단일 파일이에요.  

포함 사항:
- Op 에일리어스: SIN_READ / MUL_READ / SIN_PROGRAM / MUL_PROGRAM / SIN_ERASE / MUL_ERASE

→ 내부에선 기본 OpKind(READ/PROGRAM/ERASE) + meta.arity, meta.plane_list, meta.scope 로 일원화
- 비탐욕 멀티‑플레인 선택기(plan_multipane): 랜덤 샘플링 + 자동 강등(degrade), 페이지 동기화 조건 준수
- die‑wide CORE_BUSY: PROGRAM/ERASE 는 die 전체 plane 점유
- BusResource(전역 버스) 게이팅: states[*].bus=true 구간은 전역 상호배타 예약/검사
- phase‑conditional 분포에서 MUL_* / SIN_* 키 사용 가능(내부에서 해석)
- precheck/reserve가 scope(PLANE_SET / DIE_WIDE) 에 맞게 동작
- 기존 기능(phase 확률, quantize, fanout/interleave override, obligation READ→DOUT 등) 유지

파일명 예: nandsim_p2_alias_mplane.py

```python
# nandsim_p2_alias_mplane.py
# - Alias-based multi-plane ops (SIN_*/MUL_* → base op + arity)
# - Non-greedy multi-plane planner with degrade
# - DIE_WIDE CORE_BUSY for PROGRAM/ERASE
# - Global BusResource gating for bus=true state segments
# - Phase-conditional policy + backoff score policy
# - Quantized event time, obligation READ→DOUT
# Stdlib only.

from __future__ import annotations
import heapq, random
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple, Set

# ---------------------------- Simulation Resolution ----------------------------
SIM_RES_US = 0.01
def quantize(t: float) -> float:
    return round(t / SIM_RES_US) * SIM_RES_US

# ---------------------------- Config ----------------------------
CFG = {
    "rng_seed": 12345,
    "policy": {
        "queue_refill_period_us": 3.0,
        "run_until_us": 180.0,
        "planner_max_tries": 8,       # 비탐욕 시도 횟수
    },
    # phase-conditional: 훅(OP.STATE(.POS)) → 다음 op 분포(에일리어스 키 허용)
    "phase_conditional": {
        "READ.ISSUE":                {"MUL_PROGRAM": 0.20, "SIN_PROGRAM": 0.10, "SIN_READ": 0.35, "MUL_READ": 0.25, "SIN_ERASE": 0.10},
        "READ.CORE_BUSY.START":      {"MUL_READ": 0.60, "SIN_READ": 0.20, "SIN_PROGRAM": 0.10, "SIN_ERASE": 0.10},
        "READ.DATA_OUT.START":       {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.20, "SIN_ERASE": 0.10},
        "PROGRAM.ISSUE":             {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.15, "SIN_ERASE": 0.15},
        "PROGRAM.CORE_BUSY.END":     {"SIN_READ": 0.55, "MUL_READ": 0.25, "SIN_PROGRAM": 0.10, "SIN_ERASE": 0.10},
        "ERASE.ISSUE":               {"SIN_PROGRAM": 0.40, "MUL_PROGRAM": 0.20, "SIN_READ": 0.30, "MUL_READ": 0.10},
        "ERASE.CORE_BUSY.END":       {"SIN_READ": 0.60, "MUL_READ": 0.20, "SIN_PROGRAM": 0.15, "MUL_PROGRAM": 0.05},
        "DEFAULT":                   {"SIN_READ": 0.55, "SIN_PROGRAM": 0.30, "SIN_ERASE": 0.15},
    },
    # backoff weights (phase-conditional 실패 시 사용)
    "weights": {
        "base": {"host": {"READ": 0.85, "PROGRAM": 0.10, "ERASE": 0.05, "SR": 0.00, "RESET": 0.00, "DOUT": 0.00}},
        "g_state": {"pgmable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.8},
                    "readable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.9}},
        "g_local": {"plane_busy_frac": {"low": 1.2, "mid": 1.0, "high": 0.9}},
        "g_phase": {
            "READ": {"START_NEAR": 1.2, "MID_NEAR": 0.9, "END_NEAR": 1.2},
            "PROGRAM": {"START_NEAR": 1.1, "MID_NEAR": 1.0, "END_NEAR": 0.9},
            "ERASE": {"START_NEAR": 0.9, "MID_NEAR": 1.1, "END_NEAR": 1.1},
        },
    },
    "selection": {
        "defaults": {
            "READ":    {"fanout": 1, "interleave": True},
            "PROGRAM": {"fanout": 2, "interleave": True},
            "ERASE":   {"fanout": 2, "interleave": False},
        },
        "phase_overrides": {
            "READ.CORE_BUSY.START": {"fanout": 4, "interleave": True},
        }
    },
    "op_specs": {
        "READ": {
            "scope": "PLANE_SET",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 8.0, "std": 1.5, "min": 2.0}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "normal", "mean": 2.0, "std": 0.4, "min": 0.5}},
            ],
        },
        "PROGRAM": {
            "scope": "DIE_WIDE",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 20.0, "std": 3.0, "min": 8.0}},
            ],
        },
        "ERASE": {
            "scope": "DIE_WIDE",
            "page_equal_required": False,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 40.0, "std": 5.0, "min": 15.0}},
            ],
        },
        "DOUT": {
            "scope": "NONE",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": False, "dist": {"kind": "fixed",  "value": 0.2}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "normal", "mean": 1.0, "std": 0.2, "min": 0.2}},
            ],
        },
    },
    "obligations": [
        {
            "issuer": "READ",
            "require": "DOUT",
            "window_us": {"kind": "normal", "mean": 6.0, "std": 1.5, "min": 1.0},
            "priority_boost": {"start_us_before_deadline": 2.5, "boost_factor": 2.0, "hard_slot": True},
        }
    ],
    "topology": {"dies": 1, "planes_per_die": 4, "blocks_per_plane": 8, "pages_per_block": 16},
    "export": {"tu_us": 0.01, "nop_symbol": "NOP", "wait_as_nop": True, "drift_correction": True},
}

# ---------------------------- Alias mapping ----------------------------
OP_ALIAS = {
    "SIN_READ":    {"base": "READ",    "fanout": ("eq", 1)},
    "MUL_READ":    {"base": "READ",    "fanout": ("ge", 2)},
    "SIN_PROGRAM": {"base": "PROGRAM", "fanout": ("eq", 1)},
    "MUL_PROGRAM": {"base": "PROGRAM", "fanout": ("ge", 2)},
    "SIN_ERASE":   {"base": "ERASE",   "fanout": ("eq", 1)},
    "MUL_ERASE":   {"base": "ERASE",   "fanout": ("ge", 2)},
}

# ---------------------------- Models ----------------------------
class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

class Scope(Enum):
    NONE=0; PLANE_SET=1; DIE_WIDE=2

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float
    bus: bool = False

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)  # scope, plane_list, arity, alias_used, etc.

# ---------------------------- Utility ----------------------------
def sample_dist(d: Dict[str, Any]) -> float:
    k = d["kind"]
    if k == "fixed":
        return float(d["value"])
    if k == "normal":
        m, s = d["mean"], d["std"]
        mn = d.get("min", 0.0)
        v = random.gauss(m, s)
        return max(v, mn)
    if k == "exp":
        lam = d["lambda"]
        return random.expovariate(lam)
    raise ValueError(f"unknown dist kind: {k}")

def parse_hook_key(label: str):
    parts = label.split(".")
    if len(parts) >= 3: return parts[0], parts[1], parts[2]
    if len(parts) == 2: return parts[0], parts[1], None
    return None, None, None

def get_phase_dist(cfg: Dict[str,Any], hook_label: str):
    op, state, pos = parse_hook_key(hook_label)
    pc = cfg.get("phase_conditional", {})
    candidates = []
    if op and state and pos: candidates.append(f"{op}.{state}.{pos}")
    if op and state:         candidates.append(f"{op}.{state}")
    candidates.append("DEFAULT")
    for key in candidates:
        dist = pc.get(key)
        if dist and sum(dist.values()) > 0:
            return dist, key
    return None, None

def roulette_pick(dist: Dict[str, float], allow: set) -> Optional[str]:
    items = [(name, p) for name, p in dist.items() if name in allow and p > 0.0]
    if not items: return None
    total = sum(p for _, p in items)
    r = random.random()*total
    acc=0.0
    pick = items[-1][0]
    for name, p in items:
        acc += p
        if r <= acc:
            pick = name; break
    return pick

def resolve_alias(name: str) -> Tuple[str, Optional[Tuple[str,int]]]:
    """returns (base_name, fanout_constraint or None)"""
    if name in OP_ALIAS:
        base = OP_ALIAS[name]["base"]
        return base, OP_ALIAS[name]["fanout"]
    return name, None

# ---------------------------- OpSpec & builders ----------------------------
def build_operation(kind: OpKind, cfg_op: Dict[str, Any], targets: List[Address]) -> Operation:
    states=[]
    for s in cfg_op["states"]:
        dur = sample_dist(s["dist"])
        states.append(StateSeg(name=s["name"], dur_us=dur, bus=bool(s.get("bus", False))))
    return Operation(kind=kind, targets=targets, states=states)

def get_op_duration(op: Operation) -> float:
    return sum(seg.dur_us for seg in op.states)

# ---------------------------- Address / Bus Managers ----------------------------
class AddressManager:
    def __init__(self, cfg: Dict[str, Any]):
        topo = cfg["topology"]
        self.cfg = cfg
        self.dies = topo["dies"]
        self.planes = topo["planes_per_die"]
        self.pages_per_block = topo["pages_per_block"]
        self.blocks_per_plane = topo["blocks_per_plane"]

        self.available: Dict[Tuple[int,int], float] = {(0,p): 0.0 for p in range(self.planes)}  # plane availability
        self.cursors: Dict[Tuple[int,int], List[int]] = {(0,p): [0,0,0] for p in range(self.planes)}  # [block, next_pgm_page, next_rd_page]
        self.programmed: Dict[Tuple[int,int], Set[Tuple[int,int]]] = {(0,p): set() for p in range(self.planes)}  # (block,page) programmed pages
        self.resv: Dict[Tuple[int,int], List[Tuple[float,float,Optional[int]]]] = {(0,p): [] for p in range(self.planes)}  # per-plane (start,end,block)

        # Global bus reservation (ISSUE/DATA_OUT etc)
        self.bus_resv: List[Tuple[float,float]] = []  # [(start,end)] sorted by insertion time

    # ---- observation ----
    def available_at(self, die:int, plane:int) -> float:
        return self.available[(die,plane)]

    def earliest_start_for_scope(self, die:int, scope: Scope, plane_set: Optional[List[int]]=None) -> float:
        if scope == Scope.DIE_WIDE:
            planes = list(range(self.planes))
        elif scope == Scope.PLANE_SET and plane_set is not None:
            planes = plane_set
        else:
            planes = [plane_set[0]] if plane_set else [0]
        return max(self.available[(die,p)] for p in planes)

    def observe_states(self, die:int, plane:int, now_us: float):
        prog = len(self.programmed[(die,plane)])
        pgmable_ratio  = "mid" if prog < 10 else "low"
        readable_ratio = "mid" if prog > 0 else "low"
        plane_busy_frac = "high" if self.available_at(die,plane) > now_us else "low"
        return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls": "host"},
                {"plane_busy_frac": plane_busy_frac})

    # ---- bus segments helpers ----
    def bus_segments_for_op(self, op: Operation) -> List[Tuple[float,float]]:
        """relative offsets from op start for bus=true states"""
        segs=[]
        t=0.0
        for s in op.states:
            s0, s1 = t, t + s.dur_us
            if s.bus: segs.append((s0, s1))
            t = s1
        return segs

    def bus_precheck(self, start_hint: float, segs: List[Tuple[float,float]]) -> bool:
        """Check global bus availability for absolute segments"""
        for (off0, off1) in segs:
            a0, a1 = quantize(start_hint + off0), quantize(start_hint + off1)
            for (s,e) in self.bus_resv:
                if not (a1 <= s or e <= a0):
                    return False
        return True

    def bus_reserve(self, start_time: float, segs: List[Tuple[float,float]]):
        for (off0, off1) in segs:
            a0, a1 = quantize(start_time + off0), quantize(start_time + off1)
            self.bus_resv.append((a0,a1))

    # ---- planner: non-greedy multi-plane selection with degrade ----
    def _random_plane_sets(self, fanout:int, tries:int, start_plane:int) -> List[List[int]]:
        P = list(range(self.planes))
        out=[]
        for _ in range(tries):
            # bias: include start_plane with higher chance
            cand = set(random.sample(P, min(fanout, len(P))))
            if start_plane not in cand and random.random()<0.6:
                cand.pop() if len(cand)>0 else None
                cand.add(start_plane)
            out.append(sorted(cand))
        # unique
        uniq=[]
        seen=set()
        for ps in out:
            key=tuple(ps)
            if key not in seen and len(ps)==fanout:
                uniq.append(ps); seen.add(key)
        return uniq

    def _pages_present(self, die:int, plane:int) -> Set[int]:
        return {p for (_,p) in self.programmed[(die,plane)]}

    def plan_multipane(self, kind: OpKind, die:int, start_plane:int, desired_fanout:int, interleave:bool) -> Optional[Tuple[List[Address], List[int], Scope]]:
        if desired_fanout < 1: desired_fanout = 1
        tries = self.cfg["policy"]["planner_max_tries"]
        # degrade loop
        for f in range(desired_fanout, 0, -1):
            # candidate plane-sets
            candidates = self._random_plane_sets(f, tries, start_plane)
            for plane_set in candidates:
                # alignment per kind
                if kind == OpKind.READ:
                    # page must be common across planes (block may differ)
                    commons = None
                    for pl in plane_set:
                        pages = self._pages_present(die, pl)
                        commons = pages if commons is None else (commons & pages)
                        if not commons:
                            break
                    if not commons:
                        continue
                    page = random.choice(sorted(list(commons)))
                    targets=[]
                    for pl in plane_set:
                        # choose any block that has page
                        blks = [b for (b,p) in self.programmed[(die,pl)] if p==page]
                        blk = blks[0] if blks else 0
                        targets.append(Address(die, pl, block=blk, page=page))
                    scope = Scope.PLANE_SET

                elif kind == OpKind.PROGRAM:
                    # next_pgm_page must match across planes
                    ok=True
                    nxt=[]
                    for pl in plane_set:
                        b, pgm_p, _ = self.cursors[(die,pl)]
                        nxt.append(pgm_p)
                    ok = len(set(nxt))==1
                    if not ok:
                        continue
                    page = nxt[0]
                    targets=[]
                    for pl in plane_set:
                        b, pgm_p, _ = self.cursors[(die,pl)]
                        targets.append(Address(die, pl, block=b, page=page))
                    scope = Scope.DIE_WIDE  # die-wide CORE_BUSY

                elif kind == OpKind.ERASE:
                    targets=[]
                    for pl in plane_set:
                        b = self.cursors[(die,pl)][0]
                        targets.append(Address(die, pl, block=b, page=None))
                    scope = Scope.DIE_WIDE  # die-wide CORE_BUSY

                else:
                    continue

                return targets, plane_set, scope
        return None

    # ---- precheck / reserve / commit ----
    def precheck(self, kind: OpKind, targets: List[Address], start_hint: float, scope: Scope) -> bool:
        """Time overlap + simple block/page conflict (scope-aware)."""
        start_hint = quantize(start_hint); end_hint = start_hint  # guard = 0
        die = targets[0].die
        # choose planes to check (scope)
        if scope == Scope.DIE_WIDE:
            planes = {(die,p) for p in range(self.planes)}
        else:
            planes = {(t.die, t.plane) for t in targets}
        # time overlap
        for (d,p) in planes:
            for (s,e,_) in self.resv[(d,p)]:
                if not (end_hint <= s or e <= start_hint):
                    return False
        # simple block/page conflict rules (placeholder; extend in next step)
        # e.g., forbid ERASE with READ/PROGRAM on same block overlapping window
        return True

    def reserve(self, op: Operation, start: float, end: float):
        """scope-aware plane reservation; also update available times."""
        die = op.targets[0].die
        start = quantize(start); end = quantize(end)
        if op.meta.get("scope") == "DIE_WIDE":
            planes = [(die,p) for p in range(self.planes)]
        else:
            planes = [(t.die, t.plane) for t in op.targets]
        for (d,p) in planes:
            self.available[(d,p)] = max(self.available[(d,p)], end)
            self.resv[(d,p)].append((start, end, None))

    def commit(self, op: Operation):
        # update address state for PROGRAM/ERASE
        # (READ does not change programmed set)
        for t in op.targets:
            key = (t.die, t.plane)
            if op.kind == OpKind.PROGRAM and t.page is not None:
                self.programmed[key].add((t.block, t.page))
                # advance cursor
                b, pgm_p, rd = self.cursors[(t.die, t.plane)]
                pgm_p = (pgm_p + 1)
                if pgm_p >= self.pages_per_block:
                    pgm_p = 0
                    b = (b+1) % self.blocks_per_plane
                self.cursors[(t.die, t.plane)] = [b, pgm_p, rd]
            elif op.kind == OpKind.ERASE:
                # clear all pages in block
                self.programmed[key] = {pp for pp in self.programmed[key] if pp[0] != t.block]

# ---------------------------- Obligation Manager ----------------------------
@dataclass(order=True)
class _ObHeapItem:
    deadline_us: float
    seq: int
    ob: "Obligation" = field(compare=False)

@dataclass
class Obligation:
    require: OpKind
    targets: List[Address]
    deadline_us: float
    boost_factor: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg_list: List[Dict[str,Any]]):
        self.specs = cfg_list
        self.heap: List[_ObHeapItem] = []
        self._seq = 0

    def on_commit(self, op: Operation, now_us: float):
        # READ 종료 → DOUT 의무 (op.targets 전체를 그대로 사용 = plane-set 단일 오퍼레이션)
        for spec in self.specs:
            if spec["issuer"] == op.kind.name:
                dt = sample_dist(spec["window_us"])
                ob = Obligation(
                    require = OpKind[spec["require"]],
                    targets = op.targets,  # 그대로 전달 → DOUT도 plane-set 하나의 op
                    deadline_us = quantize(now_us + dt),
                    boost_factor = spec["priority_boost"]["boost_factor"],
                    hard_slot = spec["priority_boost"].get("hard_slot", False),
                )
                heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=self._seq, ob=ob))
                self._seq += 1
                first = op.targets[0]
                print(f"[{now_us:7.2f} us] OBLIG  created: {op.kind.name} -> {ob.require.name} by {ob.deadline_us:7.2f} us, target(d0,p{first.plane}) page={first.page}")

    def pop_urgent(self, now_us: float, die:int, plane:int,
                   horizon_us: float, earliest_start: float) -> Optional[Obligation]:
        if not self.heap: return None
        kept: List[_ObHeapItem] = []
        chosen: Optional[Obligation] = None
        now_us = quantize(now_us)
        earliest_start = quantize(earliest_start)
        while self.heap and not chosen:
            item = heapq.heappop(self.heap)
            ob = item.ob
            # obligation plane-set includes this plane?
            plane_list = {a.plane for a in ob.targets}
            same_die = (ob.targets[0].die == die)
            same_plane = plane in plane_list
            in_horizon = ((ob.deadline_us - now_us) <= max(horizon_us, 0.0)) or ob.hard_slot
            feasible_time = (earliest_start <= ob.deadline_us)
            if same_die and same_plane and in_horizon and feasible_time:
                chosen = ob; break
            kept.append(item)
        for it in kept:
            heapq.heappush(self.heap, it)
        return chosen

# ---------------------------- Policy Engine ----------------------------
class PolicyEngine:
    def __init__(self, cfg, addr_mgr: AddressManager, obl_mgr: ObligationManager):
        self.cfg = cfg
        self.addr = addr_mgr
        self.obl = obl_mgr
        self.stats = {"alias_degrade": 0}

    def _score(self, op_name: str, phase_label: str, global_state: Dict[str,str], local_state: Dict[str,str]) -> float:
        w = self.cfg["weights"]["base"]["host"].get(op_name, 0.0)
        w *= self.cfg["weights"]["g_state"]["pgmable_ratio"].get(global_state["pgmable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_state"]["readable_ratio"].get(global_state["readable_ratio"], 1.0)
        w *= self.cfg["weights"]["g_local"]["plane_busy_frac"].get(local_state["plane_busy_frac"], 1.0)
        near = "MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w *= self.cfg["weights"]["g_phase"].get(op_name, {}).get(near, 1.0)
        return w

    def _fanout_from_alias(self, base_name: str, alias_constraint: Optional[Tuple[str,int]], hook_label: str) -> Tuple[int,bool]:
        # phase override or defaults
        fanout, interleave = get_phase_selection_override(self.cfg, hook_label, base_name)
        if alias_constraint:
            mode, val = alias_constraint
            if mode == "eq":
                fanout = val
            elif mode == "ge":
                fanout = max(fanout, val)
        fanout = max(1, fanout)
        return fanout, interleave

    def propose(self, now_us: float, hook: PhaseHook,
                global_state: Dict[str,str], local_state: Dict[str,str],
                earliest_start: float) -> Optional[Operation]:
        die, hook_plane = hook.die, hook.plane

        # 0) Obligation first
        ob = self.obl.pop_urgent(now_us, die, hook_plane, horizon_us=10.0, earliest_start=earliest_start)
        if ob:
            # Build op for bus check
            cfg_op = self.cfg["op_specs"][ob.require.name]
            op = build_operation(ob.require, cfg_op, ob.targets)
            # scope/meta
            op.meta["scope"] = self.cfg["op_specs"][op.kind.name]["scope"]
            op.meta["plane_list"] = sorted({a.plane for a in op.targets})
            op.meta["arity"] = len(op.meta["plane_list"])
            # earliest start for scope set
            scope = Scope[op.meta["scope"]]
            plane_set = op.meta["plane_list"]
            start_hint = self.addr.earliest_start_for_scope(die, scope, plane_set)
            if self.addr.precheck(op.kind, op.targets, start_hint, scope) and \
               self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op)):
                op.meta["source"]="obligation"; op.meta["phase_key_used"]="(obligation)"; return op
            # else: cannot service obligation now → let scheduler try later (no force)

        # 1) Phase-conditional distribution (allow alias keys)
        allow = set(list(OP_ALIAS.keys()) + ["READ","PROGRAM","ERASE"])
        dist, used_key = get_phase_dist(self.cfg, hook.label)
        if dist:
            pick = roulette_pick(dist, allow)
            if pick:
                base_name, alias_const = resolve_alias(pick)
                try_kind = OpKind[base_name]
                fanout, interleave = self._fanout_from_alias(base_name, alias_const, hook.label)
                # multi-plane planning with degrade
                planned = self.addr.plan_multipane(try_kind, die, hook_plane, fanout, interleave)
                if not planned and fanout>1:
                    # degrade to single-plane
                    self.stats["alias_degrade"] += 1
                    planned = self.addr.plan_multipane(try_kind, die, hook_plane, 1, interleave)
                if planned:
                    targets, plane_set, scope = planned
                    cfg_op = self.cfg["op_specs"][base_name]
                    op = build_operation(try_kind, cfg_op, targets)
                    op.meta["scope"] = cfg_op["scope"]
                    op.meta["plane_list"] = plane_set
                    op.meta["arity"] = len(plane_set)
                    op.meta["alias_used"] = pick
                    op.meta["fanout_req"] = fanout
                    op.meta["interleave"] = interleave
                    # scope-aware start hint (across plane_set or die-wide)
                    start_hint = self.addr.earliest_start_for_scope(die, scope, plane_set)
                    if self.addr.precheck(try_kind, targets, start_hint, scope) and \
                       self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op)):
                        op.meta["source"]="policy.phase_conditional"; op.meta["phase_key_used"]=used_key
                        return op
                # dist 있었지만 실패 → score backoff로

        # 2) Backoff: score policy (single-plane default)
        cand=[]
        for name in ["READ","PROGRAM","ERASE"]:
            s=self._score(name, hook.label, global_state, local_state)
            if s>0: cand.append((name,s))
        if not cand: return None
        total=sum(s for _,s in cand)
        r=random.random()*total; acc=0.0; pick=cand[-1][0]
        for name,s in cand:
            acc+=s
            if r<=acc: pick=name; break
        try_kind=OpKind[pick]
        # single-plane plan
        planned = self.addr.plan_multipane(try_kind, die, hook_plane, 1, True)
        if not planned: return None
        targets, plane_set, scope = planned
        cfg_op = self.cfg["op_specs"][pick]
        op = build_operation(try_kind, cfg_op, targets)
        op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=plane_set; op.meta["arity"]=len(plane_set)
        start_hint = self.addr.earliest_start_for_scope(die, scope, plane_set)
        if not (self.addr.precheck(try_kind, targets, start_hint, scope) and \
                self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op))):
            return None
        op.meta["source"]="policy.score_backoff"; op.meta["phase_key_used"]="(score_backoff)"
        return op

# ---------------------------- Scheduler (with Bus gating) ----------------------------
def _addr_str(a: Address)->str:
    return f"(d{a.die},p{a.plane},b{a.block},pg{a.page})"

class Scheduler:
    def __init__(self, cfg, addr: AddressManager, spe: PolicyEngine, obl: ObligationManager):
        self.cfg=cfg; self.addr=addr; self.SPE=spe; self.obl=obl
        self.now=0.0
        self.ev=[]  # (time, seq, type, payload)
        self._seq=0
        self.stat_propose_calls=0; self.stat_scheduled=0
        self._push(0.0, "QUEUE_REFILL", None)
        for plane in range(self.addr.planes):
            self._push(0.0, "PHASE_HOOK", PhaseHook(0.0, "BOOT.START", 0, plane))

    def _push(self, t: float, typ: str, payload: Any):
        heapq.heappush(self.ev, (quantize(t), self._seq, typ, payload)); self._seq+=1

    def _start_time_for_op(self, op: Operation) -> float:
        die = op.targets[0].die
        scope = Scope[op.meta.get("scope","PLANE_SET")]
        plane_set = [a.plane for a in op.targets]
        # plane availability
        t_planes = self.addr.earliest_start_for_scope(die, scope, plane_set)
        # and bus availability (shift to avoid conflicts if needed)
        segs = self.addr.bus_segments_for_op(op)
        t = max(self.now, t_planes)
        # (간단) 충돌 시에는 propose 단계에서 이미 걸렀다고 가정 → t 그대로
        return quantize(t)

    def _schedule_operation(self, op: Operation):
        start = self._start_time_for_op(op)
        dur = get_op_duration(op)
        end = quantize(start + dur)
        # reserve: scope-aware
        self.addr.reserve(op, start, end)
        # reserve bus
        self.addr.bus_reserve(start, self.addr.bus_segments_for_op(op))
        # events & hooks
        self._push(start, "OP_START", op)
        self._push(end,   "OP_END",   op)
        # phase hooks: per plane
        for t in op.targets:
            # Label은 op.kind 기반; 훅은 bus 여부와 무관하게 생성(정책 트리거 용)
            hooks=[]
            cur = start
            for s in op.states:
                # START
                hooks.append(PhaseHook(cur, f"{op.kind.name}.{s.name}.START", t.die, t.plane))
                # MID (only for "CORE_BUSY" as example)
                if s.name=="CORE_BUSY":
                    hooks.append(PhaseHook(cur + s.dur_us*0.5, f"{op.kind.name}.{s.name}.MID", t.die, t.plane))
                # END
                hooks.append(PhaseHook(cur + s.dur_us, f"{op.kind.name}.{s.name}.END", t.die, t.plane))
                cur += s.dur_us
            for h in hooks:
                self._push(h.time_us, "PHASE_HOOK", h)

        first = op.targets[0]
        print(f"[{self.now:7.2f} us] SCHED  {op.kind.name:7s} arity={op.meta.get('arity')} scope={op.meta.get('scope')} start={start:7.2f} end={end:7.2f} 1st={_addr_str(first)} src={op.meta.get('source')} alias={op.meta.get('alias_used')}")

        self.stat_scheduled += 1

    def run_until(self, t_end: float):
        t_end = quantize(t_end)
        while self.ev and self.ev[0][0] <= t_end:
            self.now, _, typ, payload = heapq.heappop(self.ev)

            if typ=="QUEUE_REFILL":
                for plane in range(self.addr.planes):
                    self._push(self.now, "PHASE_HOOK", PhaseHook(self.now, "REFILL.NUDGE", 0, plane))
                self._push(self.now + self.cfg["policy"]["queue_refill_period_us"], "QUEUE_REFILL", None)

            elif typ=="PHASE_HOOK":
                hook: PhaseHook = payload
                earliest_start = self.addr.available_at(hook.die, hook.plane)
                global_state, local_state = self.addr.observe_states(hook.die, hook.plane, self.now)
                self.stat_propose_calls += 1
                op = self.SPE.propose(self.now, hook, global_state, local_state, earliest_start)
                if op:
                    self._schedule_operation(op)

            elif typ=="OP_START":
                op: Operation = payload
                first = op.targets[0]
                print(f"[{self.now:7.2f} us] START  {op.kind.name:7s} arity={op.meta.get('arity')} target={_addr_str(first)}")

            elif typ=="OP_END":
                op: Operation = payload
                first = op.targets[0]
                print(f"[{self.now:7.2f} us] END    {op.kind.name:7s} arity={op.meta.get('arity')} target={_addr_str(first)}")
                self.addr.commit(op)
                self.obl.on_commit(op, self.now)

        print(f"\n=== Stats ===")
        print(f"propose calls : {self.stat_propose_calls}")
        print(f"scheduled ops : {self.stat_scheduled}")
        if self.stat_propose_calls:
            rate = 100.0 * self.stat_scheduled / self.stat_propose_calls
            print(f"accept ratio  : {rate:.1f}%")
        print(f"alias degrade : {self.SPE.stats.get('alias_degrade',0)}")

# ---------------------------- Selection helpers (phase overrides) ----------------------------
def get_phase_selection_override(cfg: Dict[str,Any], hook_label: str, kind_name: str):
    op, state, pos = parse_hook_key(hook_label)
    po = cfg.get("selection", {}).get("phase_overrides", {})
    keys = []
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    for k in keys:
        val = po.get(k)
        if val:
            f = int(val.get("fanout", 1))
            iv = bool(val.get("interleave", True))
            return f, iv
    dflt = cfg.get("selection", {}).get("defaults", {}).get(kind_name, {"fanout":1,"interleave":True})
    return int(dflt.get("fanout",1)), bool(dflt.get("interleave", True))

# ---------------------------- Main ----------------------------
def main():
    random.seed(CFG["rng_seed"])
    addr = AddressManager(CFG)
    obl  = ObligationManager(CFG["obligations"])
    spe  = PolicyEngine(CFG, addr, obl)
    sch  = Scheduler(CFG, addr, spe, obl)
    print("=== NAND Sequence Generator (Alias + Multi-plane + DIE_WIDE + Bus) ===")
    sch.run_until(CFG["policy"]["run_until_us"])
    print("=== Done ===")

if __name__ == "__main__":
    main()

```

변경 포인트 요약
- 에일리어스 지원: phase_conditional 분포에서 MUL_READ 같은 키를 직접 사용해도 됩니다. 내부에선 resolve_alias가 기본 연산 + fanout 제약으로 바꿉니다.
- 비탐욕 플래너: plan_multipane가 랜덤 plane‑set을 여러 번 시도하고, 페이지 동기화가 불가하면 fanout을 1까지 자동 강등합니다. 강등 건수는 alias degrade로 통계를 찍습니다.
- die‑wide CORE_BUSY: PROGRAM/ERASE는 예약 시 die의 모든 plane에 대해 시간 점유를 설정합니다.
- 버스 게이팅: op_specs.states[*].bus가 True인 구간은 전역 BusResource로 precheck/reserve. ISSUE/DATA_OUT 충돌을 사전 차단합니다.
- DOUT 의무: READ가 끝나면 plane‑set 단일 오퍼레이션으로 DOUT 의무를 생성합니다(Export에서 하나의 MUL_DOUT으로 처리하기 쉬움).

원하면 여기에 **GlobalTimelineBuilder(ATE 패턴 변환; NOP 채움/단위 스케일/드리프트 보정)**도 바로 붙여서 내줄게.

## 👤 User

우선, 동작도 하나 추가하고 phase_conditional 값들도 변경하자. 
- SR 동작 추가. 모든 phase, 즉 CORE_BUSY 에서도 동작 가능
- ERASE.CORE_BUSY, PROGRAM.CORE_BUSY 에서 READ,PROGRAM,ERASE 모두 동작 불가능
- MUL_READ.CORE_BUSY 에서는 READ,ERASE,PROGRAM 모두 불가
- SIN_READ.CORE_BUSY 에서는 MUL_READ 불가. SIN_READ 가능. ERASE, PROGRAM 불가
- DOUT 시에는 동작 끝날때까지 모든 동작 불가
CFG 뿐만 아니라, 구현 로직도 변경해야 한다면, risk 를 평가해줘. CFG 를 통해서 제약 사항들을 구현하는 것을 우선 순위로 하자.

## 🤖 Assistant

아래는 요청한 제약을 CFG 위주로 반영하고, 필요한 최소한의 **구현 로직(런타임 배타 규칙)**을 추가한 통합본이에요.  

포함 사항:
- SR 동작 추가(모든 phase에서 가능)
- phase_conditional 갱신:
  - PROGRAM.CORE_BUSY, ERASE.CORE_BUSY → SR만 허용
  - MUL_READ.CORE_BUSY → SR만 허용
  - SIN_READ.CORE_BUSY → SIN_READ 또는 SR만 허용, MUL_READ/ERASE/PROGRAM 불가
- DOUT 진행 중엔 “전역 정지(ALL 금지)”: 어떤 동작도 불가( SR 포함 )
- 런타임 배타(ExclusionManager): CFG의 constraints.exclusions를 읽어, 스케줄 시점에 코어 바쁜 구간/출력 구간에 대한 금지 윈도우를 등록하고, 제안 시점에 허용 여부를 체크
- 훅 라벨이 READ의 경우 SIN_READ / MUL_READ로 분기(phase 조건과 정확히 매칭)

파일명 예: nandsim_p3_constraints.py

```python
# nandsim_p3_constraints.py
# - SR op added (any phase)
# - Phase-conditional distributions updated for CORE_BUSY rules
# - DOUT: global freeze (no ops allowed) via runtime exclusions
# - ExclusionManager: config-driven runtime blocking windows
# - Alias-based READ labels in hooks: SIN_READ / MUL_READ
# - Multi-plane planner + DIE_WIDE CORE_BUSY + Bus gating + Quantize

from __future__ import annotations
import heapq, random
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple, Set

SIM_RES_US = 0.01
def quantize(t: float) -> float:
    return round(t / SIM_RES_US) * SIM_RES_US

# ---------------------------- Config ----------------------------
CFG = {
    "rng_seed": 12345,
    "policy": {
        "queue_refill_period_us": 3.0,
        "run_until_us": 180.0,
        "planner_max_tries": 8,
    },
    # phase-conditional: 훅(OP.STATE(.POS)) → 다음 op 분포
    #  - CORE_BUSY 제약 반영
    "phase_conditional": {
        # 기본 분포(일부 예시)
        "READ.ISSUE":                {"MUL_PROGRAM": 0.15, "SIN_PROGRAM": 0.10, "SIN_READ": 0.35, "MUL_READ": 0.25, "SIN_ERASE": 0.15, "SR": 0.00},
        "READ.CORE_BUSY.START":      {"MUL_READ": 0.50, "SIN_READ": 0.20, "SIN_PROGRAM": 0.10, "SIN_ERASE": 0.10, "SR": 0.10},
        "READ.DATA_OUT.START":       {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.15, "SIN_ERASE": 0.10, "SR": 0.05},
        "PROGRAM.ISSUE":             {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.15, "SIN_ERASE": 0.10, "SR": 0.05},
        "PROGRAM.CORE_BUSY.END":     {"SIN_READ": 0.55, "MUL_READ": 0.25, "SIN_PROGRAM": 0.10, "SIN_ERASE": 0.05, "SR": 0.05},
        "ERASE.ISSUE":               {"SIN_PROGRAM": 0.40, "MUL_PROGRAM": 0.20, "SIN_READ": 0.25, "MUL_READ": 0.10, "SR": 0.05},
        "ERASE.CORE_BUSY.END":       {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.10, "MUL_PROGRAM": 0.05, "SR": 0.15},

        # === 규칙 반영: CORE_BUSY 중 허용/금지 ===
        # PROGRAM/ERASE 의 CORE_BUSY 중에는 READ/PROGRAM/ERASE 모두 금지 → SR만 허용
        "PROGRAM.CORE_BUSY":         {"SR": 1.0},
        "ERASE.CORE_BUSY":           {"SR": 1.0},
        # MUL_READ 의 CORE_BUSY 중에는 READ/PROGRAM/ERASE 모두 금지 → SR만 허용
        "MUL_READ.CORE_BUSY":        {"SR": 1.0},
        # SIN_READ 의 CORE_BUSY 중에는 SIN_READ/SR만 허용, MUL_READ/PROGRAM/ERASE 금지
        "SIN_READ.CORE_BUSY":        {"SIN_READ": 0.6, "SR": 0.4},

        "DEFAULT":                   {"SIN_READ": 0.55, "SIN_PROGRAM": 0.25, "SIN_ERASE": 0.10, "SR": 0.10},
    },

    "weights": {  # 백오프용
        "base": {"host": {"READ": 0.70, "PROGRAM": 0.15, "ERASE": 0.05, "SR": 0.10, "RESET": 0.00, "DOUT": 0.00}},
        "g_state": {"pgmable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.8},
                    "readable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.9}},
        "g_local": {"plane_busy_frac": {"low": 1.2, "mid": 1.0, "high": 0.9}},
        "g_phase": {
            "READ": {"START_NEAR": 1.2, "MID_NEAR": 0.9, "END_NEAR": 1.2},
            "PROGRAM": {"START_NEAR": 1.1, "MID_NEAR": 1.0, "END_NEAR": 0.9},
            "ERASE": {"START_NEAR": 0.9, "MID_NEAR": 1.1, "END_NEAR": 1.1},
            "SR": {"START_NEAR": 1.1, "MID_NEAR": 1.1, "END_NEAR": 1.1},
        },
    },

    "selection": {
        "defaults": {
            "READ":    {"fanout": 1, "interleave": True},
            "PROGRAM": {"fanout": 2, "interleave": True},
            "ERASE":   {"fanout": 2, "interleave": False},
            "SR":      {"fanout": 1, "interleave": True},
        },
        "phase_overrides": {
            "READ.CORE_BUSY.START": {"fanout": 4, "interleave": True},
        }
    },

    "op_specs": {
        "READ": {
            "scope": "PLANE_SET",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 8.0, "std": 1.5, "min": 2.0}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "normal", "mean": 2.0, "std": 0.4, "min": 0.5}},
            ],
        },
        "PROGRAM": {
            "scope": "DIE_WIDE",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 20.0, "std": 3.0, "min": 8.0}},
            ],
        },
        "ERASE": {
            "scope": "DIE_WIDE",
            "page_equal_required": False,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 40.0, "std": 5.0, "min": 15.0}},
            ],
        },
        "DOUT": {
            "scope": "NONE",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": False, "dist": {"kind": "fixed",  "value": 0.2}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "normal", "mean": 1.0, "std": 0.2, "min": 0.2}},
            ],
        },
        "SR": {
            "scope": "NONE",
            "page_equal_required": False,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.2}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "fixed",  "value": 0.3}},
            ],
        },
    },

    # 런타임 배타 규칙(스케줄 시 윈도우 등록 → 제안 시 허용 검사)
    "constraints": {
        "exclusions": [
            # PROGRAM CORE_BUSY 동안: READ/PROGRAM/ERASE 금지 (die 스코프)
            {"when": {"op": "PROGRAM", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},
            # ERASE CORE_BUSY 동안: READ/PROGRAM/ERASE 금지 (die 스코프)
            {"when": {"op": "ERASE", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},
            # MUL_READ CORE_BUSY 동안: READ/PROGRAM/ERASE 금지 (die 스코프)
            {"when": {"op": "READ", "alias": "MUL", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},
            # SIN_READ CORE_BUSY 동안: MUL_READ/PROGRAM/ERASE 금지(READ 단일은 허용)
            {"when": {"op": "READ", "alias": "SIN", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["ALIAS:MUL_READ", "BASE:PROGRAM", "BASE:ERASE"]},
            # DOUT 전체 구간 동안: 전역 ALL 금지
            {"when": {"op": "DOUT", "states": ["*"]}, "scope": "GLOBAL",
             "blocks": ["ANY"]},
        ]
    },

    "obligations": [
        {
            "issuer": "READ",
            "require": "DOUT",
            "window_us": {"kind": "normal", "mean": 6.0, "std": 1.5, "min": 1.0},
            "priority_boost": {"start_us_before_deadline": 2.5, "boost_factor": 2.0, "hard_slot": True},
        }
    ],

    "topology": {"dies": 1, "planes_per_die": 4, "blocks_per_plane": 8, "pages_per_block": 16},
    "export": {"tu_us": 0.01, "nop_symbol": "NOP", "wait_as_nop": True, "drift_correction": True},
}

# ---------------------------- Alias mapping ----------------------------
OP_ALIAS = {
    "SIN_READ":    {"base": "READ",    "fanout": ("eq", 1)},
    "MUL_READ":    {"base": "READ",    "fanout": ("ge", 2)},
    "SIN_PROGRAM": {"base": "PROGRAM", "fanout": ("eq", 1)},
    "MUL_PROGRAM": {"base": "PROGRAM", "fanout": ("ge", 2)},
    "SIN_ERASE":   {"base": "ERASE",   "fanout": ("eq", 1)},
    "MUL_ERASE":   {"base": "ERASE",   "fanout": ("ge", 2)},
}

# ---------------------------- Models ----------------------------
class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

class Scope(Enum):
    NONE=0; PLANE_SET=1; DIE_WIDE=2

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float
    bus: bool = False

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)

# ---------------------------- Utils ----------------------------
def sample_dist(d: Dict[str, Any]) -> float:
    k = d["kind"]
    if k == "fixed": return float(d["value"])
    if k == "normal":
        m, s, mn = d["mean"], d["std"], d.get("min", 0.0)
        v = random.gauss(m, s); return max(v, mn)
    if k == "exp": return random.expovariate(d["lambda"])
    raise ValueError(f"unknown dist kind: {k}")

def parse_hook_key(label: str):
    parts = label.split(".")
    if len(parts) >= 3: return parts[0], parts[1], parts[2]
    if len(parts) == 2: return parts[0], parts[1], None
    return None, None, None

def get_phase_dist(cfg: Dict[str,Any], hook_label: str):
    op, state, pos = parse_hook_key(hook_label)
    pc = cfg.get("phase_conditional", {})
    keys=[]
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    keys.append("DEFAULT")
    for key in keys:
        dist = pc.get(key)
        if dist and sum(dist.values())>0: return dist, key
    return None, None

def roulette_pick(dist: Dict[str, float], allow: set) -> Optional[str]:
    items=[(n,p) for n,p in dist.items() if n in allow and p>0]
    if not items: return None
    tot=sum(p for _,p in items); r=random.random()*tot; acc=0.0; pick=items[-1][0]
    for n,p in items:
        acc+=p
        if r<=acc: pick=n; break
    return pick

def resolve_alias(name: str) -> Tuple[str, Optional[Tuple[str,int]]]:
    if name in OP_ALIAS: return OP_ALIAS[name]["base"], OP_ALIAS[name]["fanout"]
    return name, None

# ---------------------------- Builders ----------------------------
def build_operation(kind: OpKind, cfg_op: Dict[str, Any], targets: List[Address]) -> Operation:
    states=[]
    for s in cfg_op["states"]:
        states.append(StateSeg(name=s["name"], dur_us=sample_dist(s["dist"]), bus=bool(s.get("bus", False))))
    return Operation(kind=kind, targets=targets, states=states)

def get_op_duration(op: Operation) -> float:
    return sum(seg.dur_us for seg in op.states)

# ---------------------------- Address & Bus Managers ----------------------------
class AddressManager:
    def __init__(self, cfg: Dict[str, Any]):
        topo=cfg["topology"]; self.cfg=cfg
        self.dies=topo["dies"]; self.planes=topo["planes_per_die"]
        self.pages_per_block=topo["pages_per_block"]; self.blocks_per_plane=topo["blocks_per_plane"]
        self.available={(0,p):0.0 for p in range(self.planes)}
        self.cursors={(0,p):[0,0,0] for p in range(self.planes)}  # block, next_pgm, next_rd
        self.programmed={(0,p):set() for p in range(self.planes)}  # (block,page)
        self.resv={(0,p):[] for p in range(self.planes)}           # (start,end,block)
        self.bus_resv: List[Tuple[float,float]] = []

    def available_at(self, die:int, plane:int)->float: return self.available[(die,plane)]

    def earliest_start_for_scope(self, die:int, scope: Scope, plane_set: Optional[List[int]]=None)->float:
        if scope==Scope.DIE_WIDE: planes=list(range(self.planes))
        elif scope==Scope.PLANE_SET and plane_set is not None: planes=plane_set
        else: planes=[plane_set[0]] if plane_set else [0]
        return max(self.available[(die,p)] for p in planes)

    def observe_states(self, die:int, plane:int, now_us: float):
        prog=len(self.programmed[(die,plane)])
        pgmable_ratio="mid" if prog<10 else "low"
        readable_ratio="mid" if prog>0 else "low"
        plane_busy_frac="high" if self.available_at(die,plane)>now_us else "low"
        return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls":"host"},
                {"plane_busy_frac": plane_busy_frac})

    # bus segments (relative offsets)
    def bus_segments_for_op(self, op: Operation)->List[Tuple[float,float]]:
        segs=[]; t=0.0
        for s in op.states:
            if s.bus: segs.append((t, t+s.dur_us))
            t+=s.dur_us
        return segs

    def bus_precheck(self, start_hint: float, segs: List[Tuple[float,float]])->bool:
        for (off0,off1) in segs:
            a0, a1 = quantize(start_hint+off0), quantize(start_hint+off1)
            for (s,e) in self.bus_resv:
                if not (a1<=s or e<=a0): return False
        return True

    def bus_reserve(self, start_time: float, segs: List[Tuple[float,float]]):
        for (off0,off1) in segs:
            self.bus_resv.append((quantize(start_time+off0), quantize(start_time+off1)))

    # planner (non-greedy)
    def _random_plane_sets(self, fanout:int, tries:int, start_plane:int)->List[List[int]]:
        P=list(range(self.planes)); out=[]; 
        for _ in range(tries):
            cand=set(random.sample(P, min(fanout,len(P))))
            if start_plane not in cand and random.random()<0.6:
                if len(cand)>0: cand.pop()
                cand.add(start_plane)
            if len(cand)==fanout: out.append(sorted(cand))
        uniq=[]; seen=set()
        for ps in out:
            k=tuple(ps)
            if k not in seen: uniq.append(ps); seen.add(k)
        return uniq

    def _pages_present(self, die:int, plane:int)->Set[int]:
        return {p for (_,p) in self.programmed[(die,plane)]}

    def plan_multipane(self, kind: OpKind, die:int, start_plane:int, desired_fanout:int, interleave:bool)\
            -> Optional[Tuple[List[Address], List[int], Scope]]:
        if desired_fanout<1: desired_fanout=1
        tries=self.cfg["policy"]["planner_max_tries"]
        for f in range(desired_fanout, 0, -1):
            for plane_set in self._random_plane_sets(f, tries, start_plane):
                if kind==OpKind.READ:
                    commons=None
                    for pl in plane_set:
                        pages=self._pages_present(die,pl)
                        commons=pages if commons is None else (commons & pages)
                        if not commons: break
                    if not commons: continue
                    page=random.choice(sorted(list(commons)))
                    targets=[]
                    for pl in plane_set:
                        blks=[b for (b,p) in self.programmed[(die,pl)] if p==page]
                        blk=blks[0] if blks else 0
                        targets.append(Address(die,pl,blk,page))
                    scope=Scope.PLANE_SET

                elif kind==OpKind.PROGRAM:
                    nxt=[]
                    for pl in plane_set:
                        b, pgm_p, _ = self.cursors[(die,pl)]
                        nxt.append(pgm_p)
                    if len(set(nxt))!=1: continue
                    page=nxt[0]; targets=[]
                    for pl in plane_set:
                        b, pgm_p, _ = self.cursors[(die,pl)]
                        targets.append(Address(die,pl,b,page))
                    scope=Scope.DIE_WIDE

                elif kind==OpKind.ERASE:
                    targets=[]
                    for pl in plane_set:
                        b=self.cursors[(die,pl)][0]
                        targets.append(Address(die,pl,b,None))
                    scope=Scope.DIE_WIDE

                elif kind==OpKind.SR:
                    targets=[Address(die,start_plane,0,None)]
                    scope=Scope.NONE

                else:
                    continue
                return targets, plane_set, scope
        return None

    def precheck_planescope(self, kind: OpKind, targets: List[Address], start_hint: float, scope: Scope)->bool:
        start_hint=quantize(start_hint); end_hint=start_hint
        die=targets[0].die
        if scope==Scope.DIE_WIDE: planes={(die,p) for p in range(self.planes)}
        elif scope==Scope.PLANE_SET: planes={(t.die,t.plane) for t in targets}
        else: planes={(targets[0].die, targets[0].plane)}
        for (d,p) in planes:
            for (s,e,_) in self.resv[(d,p)]:
                if not (end_hint<=s or e<=start_hint): return False
        return True

    def reserve_planescope(self, op: Operation, start: float, end: float):
        die=op.targets[0].die; start=quantize(start); end=quantize(end)
        if op.meta.get("scope")=="DIE_WIDE":
            planes=[(die,p) for p in range(self.planes)]
        elif op.meta.get("scope")=="PLANE_SET":
            planes=[(t.die,t.plane) for t in op.targets]
        else:
            planes=[(op.targets[0].die, op.targets[0].plane)]
        for (d,p) in planes:
            self.available[(d,p)]=max(self.available[(d,p)], end)
            self.resv[(d,p)].append((start,end,None))

    def commit(self, op: Operation):
        for t in op.targets:
            key=(t.die,t.plane)
            if op.kind==OpKind.PROGRAM and t.page is not None:
                self.programmed[key].add((t.block,t.page))
                b, pgm_p, rd = self.cursors[(t.die,t.plane)]
                pgm_p+=1
                if pgm_p>=self.pages_per_block:
                    pgm_p=0; b=(b+1)%self.blocks_per_plane
                self.cursors[(t.die,t.plane)]=[b,pgm_p,rd]
            elif op.kind==OpKind.ERASE:
                self.programmed[key]={pp for pp in self.programmed[key] if pp[0]!=t.block}

# ---------------------------- Exclusion Manager (runtime blocking) ----------------------------
@dataclass
class ExclWindow:
    start: float; end: float
    scope: str              # "GLOBAL" or "DIE"
    die: Optional[int]
    tokens: Set[str]        # e.g., {"ANY"}, {"BASE:READ"}, {"ALIAS:MUL_READ"}

class ExclusionManager:
    def __init__(self, cfg: Dict[str,Any]):
        self.cfg = cfg
        self.global_windows: List[ExclWindow] = []
        self.die_windows: Dict[int, List[ExclWindow]] = {}

    def _state_windows(self, op: Operation, start: float, states: List[str]) -> List[Tuple[float,float]]:
        wins=[]; t=start
        segs=[]
        for s in op.states:
            segs.append((s.name, t, t+s.dur_us)); t+=s.dur_us
        if states==["*"]:
            return [(segs[0][1], segs[-1][2])]
        want=set(states)
        for name, s0, s1 in segs:
            if name in want: wins.append((s0,s1))
        return wins

    def _token_blocks(self, tok: str, op: Operation) -> bool:
        if tok=="ANY": return True
        if tok.startswith("BASE:"):
            base=tok.split(":")[1]
            return op.kind.name==base
        if tok.startswith("ALIAS:"):
            alias=tok.split(":")[1]
            if alias=="MUL_READ": return (op.kind==OpKind.READ and op.meta.get("arity",1)>1)
            if alias=="SIN_READ": return (op.kind==OpKind.READ and op.meta.get("arity",1)==1)
        return False

    def allowed(self, op: Operation, start: float, end: float) -> bool:
        # check global
        for w in self.global_windows:
            if not (end<=w.start or w.end<=start):
                if any(self._token_blocks(tok, op) for tok in w.tokens):
                    return False
        # check die
        die=op.targets[0].die
        for w in self.die_windows.get(die, []):
            if not (end<=w.start or w.end<=start):
                if any(self._token_blocks(tok, op) for tok in w.tokens):
                    return False
        return True

    def register(self, op: Operation, start: float):
        rules = self.cfg.get("constraints",{}).get("exclusions",[])
        die = op.targets[0].die
        for r in rules:
            when=r["when"]; if_op=when.get("op")
            if if_op != op.kind.name: 
                # alias match for READ(SIN/MUL)
                if not (op.kind==OpKind.READ and if_op=="READ"): 
                    continue
            alias_need = when.get("alias")
            if alias_need=="MUL" and not (op.meta.get("arity",1)>1): 
                continue
            if alias_need=="SIN" and not (op.meta.get("arity",1)==1): 
                continue
            states = when.get("states", ["*"])
            windows = self._state_windows(op, start, states)
            scope=r.get("scope","GLOBAL"); tokens=set(r.get("blocks",[]))
            for (s0,s1) in windows:
                w=ExclWindow(start=quantize(s0), end=quantize(s1), scope=scope, die=(die if scope=="DIE" else None), tokens=tokens)
                if scope=="GLOBAL":
                    self.global_windows.append(w)
                else:
                    self.die_windows.setdefault(die,[]).append(w)

# ---------------------------- Obligation Manager ----------------------------
@dataclass(order=True)
class _ObHeapItem:
    deadline_us: float
    seq: int
    ob: "Obligation" = field(compare=False)

@dataclass
class Obligation:
    require: OpKind
    targets: List[Address]
    deadline_us: float
    boost_factor: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg_list: List[Dict[str,Any]]):
        self.specs = cfg_list
        self.heap: List[_ObHeapItem] = []; self._seq=0

    def on_commit(self, op: Operation, now_us: float):
        for spec in self.specs:
            if spec["issuer"] == op.kind.name:
                dt=sample_dist(spec["window_us"])
                ob=Obligation(require=OpKind[spec["require"]], targets=op.targets,
                              deadline_us=quantize(now_us+dt),
                              boost_factor=spec["priority_boost"]["boost_factor"],
                              hard_slot=spec["priority_boost"].get("hard_slot", False))
                heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=self._seq, ob=ob))
                self._seq+=1
                first=op.targets[0]
                print(f"[{now_us:7.2f} us] OBLIG  created: {op.kind.name} -> {ob.require.name} by {ob.deadline_us:7.2f} us, target(d{first.die},p{first.plane})")

    def pop_urgent(self, now_us: float, die:int, plane:int, horizon_us: float, earliest_start: float) -> Optional[Obligation]:
        if not self.heap: return None
        kept=[]; chosen=None
        now_us=quantize(now_us); earliest_start=quantize(earliest_start)
        while self.heap and not chosen:
            item=heapq.heappop(self.heap); ob=item.ob
            plane_list={a.plane for a in ob.targets}
            same_die=(ob.targets[0].die==die); same_plane=(plane in plane_list)
            in_horizon=((ob.deadline_us-now_us)<=max(horizon_us,0.0)) or ob.hard_slot
            feasible=(earliest_start<=ob.deadline_us)
            if same_die and same_plane and in_horizon and feasible: chosen=ob; break
            kept.append(item)
        for it in kept: heapq.heappush(self.heap, it)
        return chosen

# ---------------------------- Policy Engine ----------------------------
class PolicyEngine:
    def __init__(self, cfg, addr: AddressManager, obl: ObligationManager, excl: ExclusionManager):
        self.cfg=cfg; self.addr=addr; self.obl=obl; self.excl=excl
        self.stats={"alias_degrade":0}

    def _score(self, op_name: str, phase_label: str, g: Dict[str,str], l: Dict[str,str]) -> float:
        w=self.cfg["weights"]["base"]["host"].get(op_name,0.0)
        w*=self.cfg["weights"]["g_state"]["pgmable_ratio"].get(g["pgmable_ratio"],1.0)
        w*=self.cfg["weights"]["g_state"]["readable_ratio"].get(g["readable_ratio"],1.0)
        w*=self.cfg["weights"]["g_local"]["plane_busy_frac"].get(l["plane_busy_frac"],1.0)
        near="MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w*=self.cfg["weights"]["g_phase"].get(op_name,{}).get(near,1.0)
        return w

    def _fanout_from_alias(self, base_name: str, alias_constraint: Optional[Tuple[str,int]], hook_label: str)->Tuple[int,bool]:
        fanout, interleave = get_phase_selection_override(self.cfg, hook_label, base_name)
        if alias_constraint:
            mode,val=alias_constraint
            if mode=="eq": fanout=val
            elif mode=="ge": fanout=max(fanout,val)
        return max(1,fanout), interleave

    def _exclusion_ok(self, op: Operation, die:int, plane_set: List[int], start_hint: float) -> bool:
        scope = Scope[op.meta["scope"]]
        # scope-aware earliest start (already computed outside; but ensure not earlier than plane availability)
        start = self.addr.earliest_start_for_scope(die, scope, plane_set)
        dur = get_op_duration(op); end=quantize(start+dur)
        return self.excl.allowed(op, start, end)

    def propose(self, now_us: float, hook: PhaseHook, g: Dict[str,str], l: Dict[str,str], earliest_start: float) -> Optional[Operation]:
        die, hook_plane = hook.die, hook.plane

        # 0) obligation 우선
        ob=self.obl.pop_urgent(now_us, die, hook_plane, horizon_us=10.0, earliest_start=earliest_start)
        if ob:
            cfg_op=self.cfg["op_specs"][ob.require.name]; op=build_operation(ob.require, cfg_op, ob.targets)
            op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=sorted({a.plane for a in ob.targets}); op.meta["arity"]=len(op.meta["plane_list"])
            # gating check: plane, bus, exclusion
            scope=Scope[op.meta["scope"]]; plane_set=op.meta["plane_list"]
            start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
            if self.addr.precheck_planescope(op.kind, op.targets, start_hint, scope)\
               and self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op))\
               and self._exclusion_ok(op, die, plane_set, start_hint):
                op.meta["source"]="obligation"; op.meta["phase_key_used"]="(obligation)"; return op

        # 1) phase-conditional (alias 키 허용 + SR 포함)
        allow=set(list(OP_ALIAS.keys())+["READ","PROGRAM","ERASE","SR"])
        dist, used_key = get_phase_dist(self.cfg, hook.label)
        if dist:
            pick=roulette_pick(dist, allow)
            if pick:
                base, alias_const = resolve_alias(pick)
                kind=OpKind[base]
                # SR은 단일 플레인
                if kind==OpKind.SR:
                    plan=self.addr.plan_multipane(kind, die, hook_plane, 1, True)
                else:
                    fanout, interleave=self._fanout_from_alias(base, alias_const, hook.label)
                    plan=self.addr.plan_multipane(kind, die, hook_plane, fanout, interleave)
                    if not plan and fanout>1:
                        self.stats["alias_degrade"]+=1
                        plan=self.addr.plan_multipane(kind, die, hook_plane, 1, interleave)
                if plan:
                    targets, plane_set, scope=plan
                    cfg_op=self.cfg["op_specs"][base]; op=build_operation(kind, cfg_op, targets)
                    op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=plane_set; op.meta["arity"]=len(plane_set); op.meta["alias_used"]=pick
                    start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
                    if self.addr.precheck_planescope(kind, targets, start_hint, scope)\
                       and self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op))\
                       and self._exclusion_ok(op, die, plane_set, start_hint):
                        op.meta["source"]="policy.phase_conditional"; op.meta["phase_key_used"]=used_key; return op
            # 실패 시 백오프

        # 2) backoff (READ/PROGRAM/ERASE/SR)
        cand=[]
        for name in ["READ","PROGRAM","ERASE","SR"]:
            s=self._score(name, hook.label, g, l)
            if s>0: cand.append((name,s))
        if not cand: return None
        tot=sum(s for _,s in cand); r=random.random()*tot; acc=0.0; pick=cand[-1][0]
        for name,s in cand:
            acc+=s
            if r<=acc: pick=name; break
        kind=OpKind[pick]
        if kind==OpKind.SR:
            plan=self.addr.plan_multipane(kind, die, hook_plane, 1, True)
        else:
            fanout, interleave=get_phase_selection_override(self.cfg, hook.label, pick)
            plan=self.addr.plan_multipane(kind, die, hook_plane, fanout, interleave)
        if not plan: return None
        targets, plane_set, scope=plan
        cfg_op=self.cfg["op_specs"][pick]; op=build_operation(kind, cfg_op, targets)
        op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=plane_set; op.meta["arity"]=len(plane_set)
        start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
        if not (self.addr.precheck_planescope(kind, targets, start_hint, scope)\
                and self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op))\
                and self._exclusion_ok(op, die, plane_set, start_hint)):
            return None
        op.meta["source"]="policy.score_backoff"; op.meta["phase_key_used"]="(score_backoff)"; return op

# ---------------------------- Scheduler ----------------------------
def _addr_str(a: Address)->str: return f"(d{a.die},p{a.plane},b{a.block},pg{a.page})"

class Scheduler:
    def __init__(self, cfg, addr: AddressManager, spe: PolicyEngine, obl: ObligationManager, excl: ExclusionManager):
        self.cfg=cfg; self.addr=addr; self.SPE=spe; self.obl=obl; self.excl=excl
        self.now=0.0; self.ev=[]; self._seq=0
        self.stat_propose_calls=0; self.stat_scheduled=0
        self._push(0.0, "QUEUE_REFILL", None)
        for plane in range(self.addr.planes):
            self._push(0.0, "PHASE_HOOK", PhaseHook(0.0, "BOOT.START", 0, plane))

    def _push(self, t: float, typ: str, payload: Any):
        heapq.heappush(self.ev, (quantize(t), self._seq, typ, payload)); self._seq+=1

    def _start_time_for_op(self, op: Operation) -> float:
        die=op.targets[0].die
        scope=Scope[op.meta.get("scope","PLANE_SET")]
        plane_set=[a.plane for a in op.targets]
        t_planes=self.addr.earliest_start_for_scope(die, scope, plane_set)
        return quantize(max(self.now, t_planes))

    def _label_for_read(self, op: Operation)->str:
        if op.kind!=OpKind.READ: return op.kind.name
        return "MUL_READ" if op.meta.get("arity",1)>1 else "SIN_READ"

    def _schedule_operation(self, op: Operation):
        start=self._start_time_for_op(op); dur=get_op_duration(op); end=quantize(start+dur)
        # plane scope reserve + bus reserve + exclusion windows register
        self.addr.reserve_planescope(op, start, end)
        self.addr.bus_reserve(start, self.addr.bus_segments_for_op(op))
        self.excl.register(op, start)

        # events
        self._push(start, "OP_START", op); self._push(end, "OP_END", op)

        # phase hooks (라벨: READ는 SIN_READ/MUL_READ)
        label_op=self._label_for_read(op)
        for t in op.targets:
            cur=start
            for s in op.states:
                self._push(cur,               "PHASE_HOOK", PhaseHook(cur,               f"{label_op}.{s.name}.START", t.die, t.plane))
                if s.name=="CORE_BUSY": 
                    self._push(cur + s.dur_us*0.5, "PHASE_HOOK", PhaseHook(cur + s.dur_us*0.5, f"{label_op}.{s.name}.MID",   t.die, t.plane))
                self._push(cur + s.dur_us,    "PHASE_HOOK", PhaseHook(cur + s.dur_us,    f"{label_op}.{s.name}.END",   t.die, t.plane))
                cur += s.dur_us

        first=op.targets[0]
        print(f"[{self.now:7.2f} us] SCHED  {op.kind.name:7s} arity={op.meta.get('arity')} scope={op.meta.get('scope')} start={start:7.2f} end={end:7.2f} 1st={_addr_str(first)} src={op.meta.get('source')} alias={op.meta.get('alias_used')}")

        self.stat_scheduled+=1

    def run_until(self, t_end: float):
        t_end=quantize(t_end)
        while self.ev and self.ev[0][0] <= t_end:
            self.now, _, typ, payload = heapq.heappop(self.ev)

            if typ=="QUEUE_REFILL":
                for plane in range(self.addr.planes):
                    self._push(self.now, "PHASE_HOOK", PhaseHook(self.now, "REFILL.NUDGE", 0, plane))
                self._push(self.now + self.cfg["policy"]["queue_refill_period_us"], "QUEUE_REFILL", None)

            elif typ=="PHASE_HOOK":
                hook: PhaseHook = payload
                earliest_start=self.addr.available_at(hook.die, hook.plane)
                g,l=self.addr.observe_states(hook.die, hook.plane, self.now)
                self.stat_propose_calls+=1
                op=self.SPE.propose(self.now, hook, g, l, earliest_start)
                if op: self._schedule_operation(op)

            elif typ=="OP_START":
                op: Operation=payload; first=op.targets[0]
                print(f"[{self.now:7.2f} us] START  {op.kind.name:7s} arity={op.meta.get('arity')} target={_addr_str(first)}")

            elif typ=="OP_END":
                op: Operation=payload; first=op.targets[0]
                print(f"[{self.now:7.2f} us] END    {op.kind.name:7s} arity={op.meta.get('arity')} target={_addr_str(first)}")
                self.addr.commit(op); self.obl.on_commit(op, self.now)

        print(f"\n=== Stats ===")
        print(f"propose calls : {self.stat_propose_calls}")
        print(f"scheduled ops : {self.stat_scheduled}")
        if self.stat_propose_calls:
            print(f"accept ratio  : {100.0*self.stat_scheduled/self.stat_propose_calls:.1f}%")
        print(f"(note) runtime exclusions: GLOBAL={len(self.excl.global_windows)}, DIE={sum(len(v) for v in self.excl.die_windows.values())}")

# ---------------------------- Selection overrides ----------------------------
def get_phase_selection_override(cfg: Dict[str,Any], hook_label: str, kind_name: str):
    op, state, pos = parse_hook_key(hook_label)
    po=cfg.get("selection",{}).get("phase_overrides",{})
    keys=[]
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    for k in keys:
        val=po.get(k)
        if val:
            return int(val.get("fanout",1)), bool(val.get("interleave",True))
    dflt=cfg.get("selection",{}).get("defaults",{}).get(kind_name,{"fanout":1,"interleave":True})
    return int(dflt.get("fanout",1)), bool(dflt.get("interleave",True))

# ---------------------------- Main ----------------------------
def main():
    random.seed(CFG["rng_seed"])
    addr=AddressManager(CFG); excl=ExclusionManager(CFG)
    obl=ObligationManager(CFG["obligations"])
    spe=PolicyEngine(CFG, addr, obl, excl)
    sch=Scheduler(CFG, addr, spe, obl, excl)
    print("=== NAND Sequence Generator (P3: SR + CORE_BUSY constraints + DOUT freeze) ===")
    sch.run_until(CFG["policy"]["run_until_us"])
    print("=== Done ===")

if __name__=="__main__":
    main()

```

왜 이렇게 바꿨는가? (요구사항 ↔ 구현 대응)
1. SR 추가 & CORE_BUSY에서도 허용
  - op_specs.SR 추가(버스 사용), phase_conditional 전 구간에서 SR 확률 넣어두고, 특히 CORE_BUSY 제한 구간을 SR 위주로 설정.
2. PROGRAM/ERASE의 CORE_BUSY 중 READ/PROGRAM/ERASE 금지
  - CFG/phase: PROGRAM.CORE_BUSY, ERASE.CORE_BUSY 키에서 SR만 허용(분포 1.0)
  - 런타임: constraints.exclusions로 CORE_BUSY 구간을 die 스코프 배타 윈도우로 등록 → 제안 시 어떤 훅이 오더라도 동일 규칙 강제
3. MUL_READ.CORE_BUSY에서 READ/ERASE/PROGRAM 금지
  - 후크 라벨이 MUL_READ로 표기되도록 변경 → phase_conditional["MUL_READ.CORE_BUSY"] 적용
  - 런타임: alias:MUL 조건의 배타 규칙으로 동일 강제
4. SIN_READ.CORE_BUSY에서 SIN_READ만 허용(멀티 불가), ERASE/PROGRAM 불가
  - CFG: SIN_READ.CORE_BUSY: {SIN_READ, SR}
  - 런타임: alias:SIN 규칙이 MUL_READ만 차단하도록 토큰(ALIAS:MUL_READ) 사용
5. DOUT 중 전역 정지(ALL 불가)
  - 런타임: op=DOUT, states=["*"], scope=GLOBAL, blocks=["ANY"]
  - DOUT의 전체 구간(start~end)에 대해 어떤 연산도 예약 불가(SR 포함)

리스크 평가
- 훅 라벨 변경(READ → SIN_READ/MUL_READ)
  - 리스크: 기존 phase_conditional 키와의 호환성.
  - 완화: DEFAULT와 READ.* 키가 계속 존재하면 백오프 동작. 이번 버전은 새 키를 넣었고, 기존 키와 병행 가능.
- 런타임 배타(ExclusionManager) 추가
  - 리스크: false reject/accept 시 타임라인 정합성 흔들림.
  - 완화: 배타 윈도우는 스케줄 성공 시점에만 등록하므로, 이미 예약된 동작과 모순되지 않음. 사전검사(planescope/bus)와 동일 단계에서 함께 검사.
- DOUT 글로벌 프리즈
  - 리스크: Throughput 감소 가능.
  - 완화: 요구사항이 “전역 금지”이므로 충족을 우선. 필요하면 scope: DIE로 완화 가능(다이를 여러 개 쓰는 경우).
- SR 버스 충돌
  - 리스크: SR도 버스 사용이므로 ISSUE/DATA_OUT과 충돌 → bus_precheck가 막음(의도한 동작).

다음 단계 제안 (선택)
- 메트릭: 배타 규칙 발동 횟수/사유(토큰 기준), alias degrade count, DOUT freeze로 인한 제안 거절률.
- Export(GlobalTimelineBuilder): DOUT 프리즈/CORE_BUSY 배타 구간은 NOP/WAIT 삽입과 잘 맞습니다(이전 설계와 호환).

필요하면 이 버전에 **GlobalTimelineBuilder(ATE 변환기 초안)**까지 바로 묶어서 드릴게요.

## 👤 User

address_manager.py
Python
아래는 테스트 결과야
=== NAND Sequence Generator (P3: SR + CORE_BUSY constraints + DOUT freeze) ===
[ 0.00 us] SCHED SR arity=1 scope=NONE start= 0.00 end= 0.50 1st=(d0,p0,b0,pgNone) src=policy.score_backoff alias=None
[ 0.00 us] SCHED PROGRAM arity=1 scope=DIE_WIDE start= 0.50 end= 20.13 1st=(d0,p0,b0,pg0) src=policy.phase_conditional alias=SIN_PROGRAM
[ 0.00 us] START SR arity=1 target=(d0,p0,b0,pgNone)
[ 0.00 us] SCHED PROGRAM arity=2 scope=DIE_WIDE start= 20.13 end= 39.71 1st=(d0,p0,b0,pg0) src=policy.score_backoff alias=None
—-
program 이 된 (d0,p0,b0,pg0) 에 중복으로 program 되는 오류가 있어. addressmanager 가 block 마다 마지막 program page 를 기록하고 있어야 하고, 여기서 발생하는 read block 의 조건이 결정돼. read 는 program 된 page 까지만 read 가능하고, program 이 한번도 되지 않은 block 은 읽을 수가 없어.

내가 첨부한 파일은 이런 제약 사항들을 반영해서 만든 address_manager.py 파일이야. 이 파일을 읽고 구현 내용을 파악해서, 현재의 nandsim 에 반영할 수 있도록 해.
우선 리뷰한 내용을 바탕으로 구현 계획을 제시해봐

## 🤖 Assistant

좋아. 중복 PROGRAM(page=0) 스케줄링 버그의 원인은 “커밋 전 예약된 PROGRAM이 주소 상태에 반영되지 않아서” 같은 페이지가 다시 선택된 것에 있어.  

올려준 address_manager.py는 스텁이지만(인터페이스 형태), 이를 상태 모델+미래예약(Future State) 개념으로 채워 넣으면 문제를 깔끔히 해결할 수 있어. 아래에 구현 계획을 정리했어. (현 nandsim_p3_constraints 기준)

0) 요약 (핵심 변화)
- Block 단위 상태(Committed / Future) 2레일로 관리
  - committed: 지금까지 “실제 완료된” PROGRAM/ERASE 결과
  - future: 스케줄 시점에 미리 반영되는 상태(예약된 PROGRAM/ERASE 포함) → 중복 PROGRAM 방지
- 예약 시점(reserve) 훅 강화
  - PROGRAM/ERASE 예약 시, future를 즉시 업데이트(페이지/ERASE 반영)
  - READ 선택 시, committed 기준으로만 읽을 수 있는 페이지를 선택(보수적)
- precheck 강화
  - PROGRAM: 예약 시점의 future가 정확히 다음 페이지인지 검사
  - READ: 예약 시점의 committed에서 실제로 읽을 수 있는지 검사
- 멀티-플레인 plan은 future를 보며 정렬, READ는 committed만 사용
- commit 시점에 committed를 future에 맞춰 갱신 (동기화)

이렇게 하면 **(d0,p0,b0,pg0)**를 한 번 예약한 뒤 다음 예약부터는 자동으로 **pg1, pg2…**로 나아가며, 커밋 전에도 중복 선택이 절대 안 됨.

1) 데이터 모델 (AddressManager v2)

현재 AddressManager 내부 구조를 아래와 같이 교체/추가

1.1 상태 테이블
- addr_state_committed[(die, plane, block)] : int
  - 의미: -3=bad, -2=initial(not erased), -1=ERASED, 0..pages-1=“마지막으로 PROGRAM된 page”
- addr_state_future[(die, plane, block)] : int
  - 의미: committed를 복제 후 예약을 반영한 값 (예약된 PROGRAM 반영, 예약된 ERASE는 -1로 리셋)
- programmed_committed[(die, plane)] : Set[(block, page)]
  - READ 플래닝을 위해 커밋된 페이지 셋 유지(기존 programmed 유지/이관)
- (옵션) pending_ops_index[(die, plane, block)] : List[(op_kind, page, start, end)]
  - 필요 시 시간 의존 체크에 사용. 초기엔 생략 가능(“READ는 committed만” 정책이면 불필요).

1.2 커서
- next_pgm_future[(die, plane, block)] = addr_state_future + 1
  - PROGRAM 타깃 페이지는 반드시 이 값이어야 함
- (커밋 커서는 addr_state_committed + 1로 해석)

2) API/메서드별 책임 (스텁 인터페이스 충족)

올려준 스텁 시그니처를 기반으로, 현 nandsim 메서드를 매칭/확장

- available_at(die, plane) -> float
  - 기존과 동일
- select(kind, die, plane, fanout=1, interleave=True) -> List[Address]
  - READ: programmed_committed에서 선택(커밋된 페이지 범위 내)
  - PROGRAM: addr_state_future 기반으로 동일 page 정렬된 plane-set 반환
  - ERASE: 블록 선택. (die-wide 점유는 scope에서 처리)
  - SR: 단일 plane/die
  - 내부적으로 plan_multipane(kind, ...) 호출 (현재 구현 보강)
- precheck(kind, targets, start_hint, scope) -> bool (현 함수 유지)
  - 시간 겹침 + 주소 규칙 검사
    - PROGRAM: 각 (die,plane,block)에 대해 target.page == addr_state_future + 1 요구
    - READ: target.page <= addr_state_committed 요구 (커밋된 범위만 허용)
    - ERASE: 제한 없음(단, die-wide로 시간 겹침은 다른 레이어에서 차단)
- reserve(op, start, end) → 두 단계로 분리 권장
  1. reserve_planescope(op, start, end) (기존 시간 예약/available 갱신)
  2. register_future(op, start, end) (핵심: future/커서 갱신)
    - PROGRAM: addr_state_future = target.page
    - ERASE:   addr_state_future = -1
    - READ/DOUT/SR: 상태 변화 없음
  - (현 구조에는 Scheduler._schedule_operation에서 addr.reserve_planescope와 addr.register_future를 호출하도록 1줄 추가)
- commit(op)
  - PROGRAM: addr_state_committed = max(committed, target.page), programmed_committed.add((block, page))
  - ERASE:   addr_state_committed = -1, programmed_committed에서 해당 block 페이지들 제거
  - READ/DOUT/SR: 상태 변화 없음
- observe_states(die, plane, now)
  - pgmable_ratio: plane 내 블록 중 addr_state_future < pages_per_block-1 비중
  - readable_ratio: plane 내 블록 중 addr_state_committed >= 0 비중
  - (기존 버킷 문자열 "low/mid/high" 유지)

핵심 포인트: 중복 PROGRAM 방지는 register_future에서 해결. 이후 어떤 스케줄도 같은 페이지를 다시 고를 수 없음.

3) 기존 코드에 들어갈 변경 포인트
3.1 AddressManager 초기화
- 기존 programmed/cursors를 대체/보강
  - addr_state_committed/addr_state_future를 -1(ERASED) 또는 **-2(initial)**로 초기화
  - programmed_committed는 빈 set
  - available, resv, bus_resv는 그대로

3.2 plan_multipane(READ/PROGRAM/ERASE) 보강
- READ
  - programmed_committed[(die, pl)]에서 page 공통 교집합을 구하는 현재 로직 유지
  - (선택된 block/page로 Address 구성)
- PROGRAM
  - 각 plane의 (die, pl, block)에 대해 next_pgm_future == addr_state_future + 1
  - plane-set 간 동일 page를 이 값으로 부여
  - Address 구성 후 반환
- ERASE
  - plane-set별 block 선택, Address 구성

주의: PROGRAM 계획 시 **cursors가 아니라 addr_state_future**를 사용해야 함.

3.3 precheck 강화 (주소 규칙)

```python
def precheck_planescope(kind, targets, start_hint, scope):
    # ... 기존 시간 겹침 검사 ...
    for t in targets:
        s_comm = addr_state_committed[(t.die, t.plane, t.block)]
        s_fut  = addr_state_future[(t.die, t.plane, t.block)]
        if kind==OpKind.PROGRAM:
            if t.page is None: return False
            if t.page != s_fut + 1: return False     # 정확히 다음 페이지여야 함
            if t.page >= pages_per_block: return False
        elif kind==OpKind.READ:
            if t.page is None or s_comm < 0 or t.page > s_comm: return False
        elif kind==OpKind.ERASE:
            pass
        # SR/RESET: 주소 제약 없음
    return True

```

3.4 예약 시점의 future 반영

```python
def register_future(self, op: Operation, start: float, end: float):
    for t in op.targets:
        key = (t.die, t.plane, t.block)
        if op.kind == OpKind.PROGRAM and t.page is not None:
            self.addr_state_future[key] = max(self.addr_state_future[key], t.page)
        elif op.kind == OpKind.ERASE:
            self.addr_state_future[key] = -1

```

- Scheduler._schedule_operation에서 reserve_planescope와 bus_reserve 뒤에 한 줄 추가:
  - self.addr.register_future(op, start, end)

3.5 커밋 시점 동기화

```python
def commit(self, op: Operation):
    for t in op.targets:
        key = (t.die, t.plane, t.block)
        if op.kind == OpKind.PROGRAM and t.page is not None:
            # 커밋 확정
            self.addr_state_committed[key] = max(self.addr_state_committed[key], t.page)
            self.programmed_committed[(t.die, t.plane)].add((t.block, t.page))
        elif op.kind == OpKind.ERASE:
            self.addr_state_committed[key] = -1
            self.programmed_committed[(t.die, t.plane)] = {
                pp for pp in self.programmed_committed[(t.die, t.plane)] if pp[0] != t.block
            }

```

4) phase / 제약과의 상호작용
- SR / CORE_BUSY / DOUT freeze:
  - 이미 ExclusionManager로 시간 배타와 phase_conditional 제한이 적용되어 있음 → 주소 레벨 제약과 독립
- die-wide CORE_BUSY(PROGRAM/ERASE):
  - 시간 레벨에서 모든 plane 예약이 막히므로 주소 레벨 로직과 충돌 없음
- 멀티-플레인 PROGRAM:
  - addr_state_future가 동일 page를 보장하는지 검사/선택 → 정합성 유지

5) 테스트 계획 (필수 케이스)
1. 중복 PROGRAM 방지
  - p0, page0 PROGRAM 예약 후 → 다음 PROGRAM 예약이 page1을 타는지 확인
  - 멀티-플레인 예약 후에도 각 plane에서 연속 페이지가 선택되는지 확인
2. READ 가시성
  - 프로그램 전 블록은 READ 불가
  - page0 프로그램 커밋 전 READ(page0) 예약 시도 → 거절(committed만 허용)
  - 커밋 후 READ(page0) → 허용
3. ERASE 반영
  - block에 page0..2 커밋 후 ERASE 예약 → 예약 직후 future=-1
  - ERASE 커밋 전 PROGRAM 예약 시도: 시간상 겹치지 않더라도 precheck에서 다음 페이지 규칙에 따라 정상 수행(ERASE 이후는 page0로 시작)
4. 멀티-플레인 정렬
  - PROGRAM: plane-set 모두 next_pgm_future 동일성 검사
  - READ: plane-set에 대해 커밋 페이지 교집합으로 page 선택
5. 성능/수락률 회귀
  - random seed 고정에서 accept ratio 과도 하락이 없는지 확인

6) 변경 우선순위
- P0 (핫픽스)
  1. addr_state_committed/future 도입 및 초기화
  2. plan_multipane(PROGRAM)이 future 기반으로 타깃 page 산출
  3. register_future(op) 호출 추가(스케줄 직후)
  4. precheck에 PROGRAM/READ 주소 규칙 추가
- P1

5) commit()에서 committed/programmed_committed 동기화

6) READ는 programmed_committed(커밋)에서만 선택하도록 고정
- P2

7) observe_states 버킷 정확화(plane별 pgmable/readable 계산)

8) (옵션) pending_ops_index로 시간의존 READ 확대(“시작 시점 이전에 커밋될 페이지” 허용)

7) 리스크 & 완화
- 스케줄-커밋 시차에 따른 가시성
  - READ가 “예약된 PROGRAM 결과”를 앞서 읽으려는 케이스를 막기 위해, P0/P1에서는 committed만 허용.
  - 추후 P2에서 pending_ops_index를 통해 “read start 이전에 커밋될 PROGRAM”만 가시화하는 확장 고려.
- 상태 불일치 위험
  - 예약에서 future를 갱신, 커밋에서 committed를 갱신하므로 두 레일이 어긋날 수 있음.
  - 불변조건: 항상 addr_state_committed ≤ addr_state_future 유지. 이 조건 검증 assertion 추가.
- 멀티-플레인/ERASE와의 엣지 케이스
  - die-wide CORE_BUSY는 시간/자원 레벨에서 격리되므로 주소 충돌 낮음.
  - ERASE 예약 후 PROGRAM 예약이 같은 block에 들어가는 경우 → future=-1이므로 PROGRAM은 page0부터 자동 재시작(의도대로).

8) nandsim에 실제로 넣을 변경점(간단 Diff 가이드)
- AddressManager.__init__
  - addr_state_committed, addr_state_future, programmed_committed 추가
- AddressManager.plan_multipane
  - PROGRAM: 커서 출처를 cursors→addr_state_future+1로 변경
  - READ: programmed_committed 기반 page 교집합
- AddressManager.precheck_planescope
  - PROGRAM/READ 주소 규칙 추가
- AddressManager.register_future (신규)
  - PROGRAM/ERASE 예약 반영
- AddressManager.commit
  - committed/future 동기화 + programmed_committed 업데이트
- Scheduler._schedule_operation
  - reserve_planescope/bus_reserve 뒤에 addr.register_future(op, start, end) 추가

원하면 위 계획을 바로 적용한 패치 코드도 제공할 수 있어. 우선 이 계획으로 진행해도 될지 확인해줘.

## 👤 User

좋아. 진행해

## 🤖 Assistant

좋아. 중복 PROGRAM(page=0) 재선택 버그를 근본적으로 막고, READ 가시성(“프로그램된 페이지만 읽기”)을 만족하도록 AddressManager를 상태 2레일(Committed/Future) 구조로 바꾼 통합 패치를 바로 제공할게.
아래 파일 하나로 교체하면 동작해. 주요 변경점은 메시지 마지막에 요약했어.

완전 교체 파일 — nandsim_p4_addrstate.py

```python
# nandsim_p4_addrstate.py
# - AddressManager v2: per-(die,plane,block) state with committed/future rails
# - PROGRAM duplicates prevented via future reservation (register_future)
# - READ visibility: only committed pages are readable
# - Multi-plane planner updated to use future/committed rails
# - Keeps P3 features: SR, phase constraints, DOUT global freeze, alias-based MUL/SIN, DIE_WIDE CORE_BUSY, Bus gating
# Stdlib only.

from __future__ import annotations
import heapq, random
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple, Set

SIM_RES_US = 0.01
def quantize(t: float) -> float:
    return round(t / SIM_RES_US) * SIM_RES_US

# ---------------------------- Config ----------------------------
CFG = {
    "rng_seed": 12345,
    "policy": {
        "queue_refill_period_us": 3.0,
        "run_until_us": 180.0,
        "planner_max_tries": 8,
    },
    # phase-conditional: 훅(OP.STATE(.POS)) → 다음 op 분포
    "phase_conditional": {
        "READ.ISSUE":                {"MUL_PROGRAM": 0.15, "SIN_PROGRAM": 0.10, "SIN_READ": 0.35, "MUL_READ": 0.25, "SIN_ERASE": 0.15, "SR": 0.00},
        "READ.CORE_BUSY.START":      {"MUL_READ": 0.50, "SIN_READ": 0.20, "SIN_PROGRAM": 0.10, "SIN_ERASE": 0.10, "SR": 0.10},
        "READ.DATA_OUT.START":       {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.15, "SIN_ERASE": 0.10, "SR": 0.05},

        "PROGRAM.ISSUE":             {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.15, "SIN_ERASE": 0.10, "SR": 0.05},
        "PROGRAM.CORE_BUSY":         {"SR": 1.0},   # CORE_BUSY 동안 SR만 허용
        "PROGRAM.CORE_BUSY.END":     {"SIN_READ": 0.55, "MUL_READ": 0.25, "SIN_PROGRAM": 0.10, "SIN_ERASE": 0.05, "SR": 0.05},

        "ERASE.ISSUE":               {"SIN_PROGRAM": 0.40, "MUL_PROGRAM": 0.20, "SIN_READ": 0.25, "MUL_READ": 0.10, "SR": 0.05},
        "ERASE.CORE_BUSY":           {"SR": 1.0},   # CORE_BUSY 동안 SR만 허용
        "ERASE.CORE_BUSY.END":       {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.10, "MUL_PROGRAM": 0.05, "SR": 0.15},

        "MUL_READ.CORE_BUSY":        {"SR": 1.0},   # 멀티리드 CORE_BUSY 동안 SR만 허용
        "SIN_READ.CORE_BUSY":        {"SIN_READ": 0.6, "SR": 0.4},  # 단일리드 CORE_BUSY 동안 MUL/PGM/ERASE 금지

        "DEFAULT":                   {"SIN_READ": 0.55, "SIN_PROGRAM": 0.25, "SIN_ERASE": 0.10, "SR": 0.10},
    },

    "weights": {  # 백오프용
        "base": {"host": {"READ": 0.70, "PROGRAM": 0.15, "ERASE": 0.05, "SR": 0.10, "RESET": 0.00, "DOUT": 0.00}},
        "g_state": {"pgmable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.8},
                    "readable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.9}},
        "g_local": {"plane_busy_frac": {"low": 1.2, "mid": 1.0, "high": 0.9}},
        "g_phase": {
            "READ": {"START_NEAR": 1.2, "MID_NEAR": 0.9, "END_NEAR": 1.2},
            "PROGRAM": {"START_NEAR": 1.1, "MID_NEAR": 1.0, "END_NEAR": 0.9},
            "ERASE": {"START_NEAR": 0.9, "MID_NEAR": 1.1, "END_NEAR": 1.1},
            "SR": {"START_NEAR": 1.1, "MID_NEAR": 1.1, "END_NEAR": 1.1},
        },
    },

    "selection": {
        "defaults": {
            "READ":    {"fanout": 1, "interleave": True},
            "PROGRAM": {"fanout": 2, "interleave": True},
            "ERASE":   {"fanout": 2, "interleave": False},
            "SR":      {"fanout": 1, "interleave": True},
        },
        "phase_overrides": {
            "READ.CORE_BUSY.START": {"fanout": 4, "interleave": True},
        }
    },

    "op_specs": {
        "READ": {
            "scope": "PLANE_SET",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 8.0, "std": 1.5, "min": 2.0}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "normal", "mean": 2.0, "std": 0.4, "min": 0.5}},
            ],
        },
        "PROGRAM": {
            "scope": "DIE_WIDE",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 20.0, "std": 3.0, "min": 8.0}},
            ],
        },
        "ERASE": {
            "scope": "DIE_WIDE",
            "page_equal_required": False,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 40.0, "std": 5.0, "min": 15.0}},
            ],
        },
        "DOUT": {
            "scope": "NONE",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": False, "dist": {"kind": "fixed",  "value": 0.2}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "normal", "mean": 1.0, "std": 0.2, "min": 0.2}},
            ],
        },
        "SR": {
            "scope": "NONE",
            "page_equal_required": False,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.2}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "fixed",  "value": 0.3}},
            ],
        },
    },

    # 런타임 배타 규칙(스케줄 시 윈도우 등록 → 제안 시 허용 검사)
    "constraints": {
        "exclusions": [
            {"when": {"op": "PROGRAM", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},
            {"when": {"op": "ERASE", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},
            {"when": {"op": "READ", "alias": "MUL", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},
            {"when": {"op": "READ", "alias": "SIN", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["ALIAS:SIN_READ", "ALIAS:MUL_READ", "BASE:PROGRAM", "BASE:ERASE"]}, # SIN은 READ 허용(한정); runtime check에서 토큰매칭 처리
            {"when": {"op": "DOUT", "states": ["*"]}, "scope": "GLOBAL", "blocks": ["ANY"]},
        ]
    },

    "obligations": [
        {
            "issuer": "READ",
            "require": "DOUT",
            "window_us": {"kind": "normal", "mean": 6.0, "std": 1.5, "min": 1.0},
            "priority_boost": {"start_us_before_deadline": 2.5, "boost_factor": 2.0, "hard_slot": True},
        }
    ],

    "topology": {"dies": 1, "planes_per_die": 4, "blocks_per_plane": 8, "pages_per_block": 16},

    "export": {"tu_us": 0.01, "nop_symbol": "NOP", "wait_as_nop": True, "drift_correction": True},

    # AddressManager 초기 block 상태 (-1 = ERASED; -2 = initial)
    "address_init_state": -1
}

# ---------------------------- Alias mapping ----------------------------
OP_ALIAS = {
    "SIN_READ":    {"base": "READ",    "fanout": ("eq", 1)},
    "MUL_READ":    {"base": "READ",    "fanout": ("ge", 2)},
    "SIN_PROGRAM": {"base": "PROGRAM", "fanout": ("eq", 1)},
    "MUL_PROGRAM": {"base": "PROGRAM", "fanout": ("ge", 2)},
    "SIN_ERASE":   {"base": "ERASE",   "fanout": ("eq", 1)},
    "MUL_ERASE":   {"base": "ERASE",   "fanout": ("ge", 2)},
}

# ---------------------------- Models ----------------------------
class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

class Scope(Enum):
    NONE=0; PLANE_SET=1; DIE_WIDE=2

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float
    bus: bool = False

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)

# ---------------------------- Utils ----------------------------
def sample_dist(d: Dict[str, Any]) -> float:
    k = d["kind"]
    if k == "fixed": return float(d["value"])
    if k == "normal":
        m, s, mn = d["mean"], d["std"], d.get("min", 0.0)
        v = random.gauss(m, s); return max(v, mn)
    if k == "exp": return random.expovariate(d["lambda"])
    raise ValueError(f"unknown dist kind: {k}")

def parse_hook_key(label: str):
    parts = label.split(".")
    if len(parts) >= 3: return parts[0], parts[1], parts[2]
    if len(parts) == 2: return parts[0], parts[1], None
    return None, None, None

def get_phase_dist(cfg: Dict[str,Any], hook_label: str):
    op, state, pos = parse_hook_key(hook_label)
    pc = cfg.get("phase_conditional", {})
    keys=[]
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    keys.append("DEFAULT")
    for key in keys:
        dist = pc.get(key)
        if dist and sum(dist.values())>0: return dist, key
    return None, None

def roulette_pick(dist: Dict[str, float], allow: set) -> Optional[str]:
    items=[(n,p) for n,p in dist.items() if n in allow and p>0]
    if not items: return None
    tot=sum(p for _,p in items); r=random.random()*tot; acc=0.0; pick=items[-1][0]
    for n,p in items:
        acc+=p
        if r<=acc: pick=n; break
    return pick

def resolve_alias(name: str) -> Tuple[str, Optional[Tuple[str,int]]]:
    if name in OP_ALIAS: return OP_ALIAS[name]["base"], OP_ALIAS[name]["fanout"]
    return name, None

# ---------------------------- Builders ----------------------------
def build_operation(kind: OpKind, cfg_op: Dict[str, Any], targets: List[Address]) -> Operation:
    states=[]
    for s in cfg_op["states"]:
        states.append(StateSeg(name=s["name"], dur_us=sample_dist(s["dist"]), bus=bool(s.get("bus", False))))
    return Operation(kind=kind, targets=targets, states=states)

def get_op_duration(op: Operation) -> float:
    return sum(seg.dur_us for seg in op.states)

# ---------------------------- Address & Bus Managers ----------------------------
class AddressManager:
    """
    v2 상태 모델:
    - addr_state_committed[(d,p,b)] : int  # 마지막 커밋된 program page (-1=ERASED, -2=initial)
    - addr_state_future[(d,p,b)]    : int  # 예약 반영된 미래 상태 (commit 이전에 갱신)
    - programmed_committed[(d,p)] : Set[(block,page)]  # READ 가시성 소스
    - write_head[(d,p)] : int  # program에 사용할 기본 block 후보
    """
    def __init__(self, cfg: Dict[str, Any]):
        topo=cfg["topology"]; self.cfg=cfg
        self.dies=topo["dies"]; self.planes=topo["planes_per_die"]
        self.pages_per_block=topo["pages_per_block"]; self.blocks_per_plane=topo["blocks_per_plane"]
        self.available={(0,p):0.0 for p in range(self.planes)}          # per-plane time availability
        self.resv={(0,p):[] for p in range(self.planes)}                # (start,end,block)
        self.bus_resv: List[Tuple[float,float]] = []

        init_state = int(cfg.get("address_init_state", -1))             # default ERASED
        # state rails
        self.addr_state_committed: Dict[Tuple[int,int,int], int] = {}
        self.addr_state_future:    Dict[Tuple[int,int,int], int] = {}
        self.programmed_committed: Dict[Tuple[int,int], Set[Tuple[int,int]]] = {(0,p): set() for p in range(self.planes)}
        self.write_head: Dict[Tuple[int,int], int] = {}

        for p in range(self.planes):
            self.write_head[(0,p)] = 0
            for b in range(self.blocks_per_plane):
                key=(0,p,b)
                self.addr_state_committed[key] = init_state
                self.addr_state_future[key]    = init_state

    # ---------- observation ----------
    def available_at(self, die:int, plane:int)->float: return self.available[(die,plane)]

    def earliest_start_for_scope(self, die:int, scope: Scope, plane_set: Optional[List[int]]=None)->float:
        if scope==Scope.DIE_WIDE: planes=list(range(self.planes))
        elif scope==Scope.PLANE_SET and plane_set is not None: planes=plane_set
        else: planes=[plane_set[0]] if plane_set else [0]
        return max(self.available[(die,p)] for p in planes)

    def observe_states(self, die:int, plane:int, now_us: float):
        # plane-level ratios for policy: pgmable/readable
        pgmable_blocks=0; readable_blocks=0
        for b in range(self.blocks_per_plane):
            fut=self.addr_state_future[(die,plane,b)]
            com=self.addr_state_committed[(die,plane,b)]
            if fut < self.pages_per_block-1: pgmable_blocks += 1
            if com >= 0: readable_blocks += 1
        total=self.blocks_per_plane or 1
        def bucket(x): 
            r=x/total
            return "low" if r<0.34 else ("mid" if r<0.67 else "high")
        pgmable_ratio=bucket(pgmable_blocks)
        readable_ratio=bucket(readable_blocks)
        plane_busy_frac="high" if self.available_at(die,plane)>now_us else "low"
        return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls":"host"},
                {"plane_busy_frac": plane_busy_frac})

    # ---------- bus segments (relative offsets) ----------
    def bus_segments_for_op(self, op: Operation)->List[Tuple[float,float]]:
        segs=[]; t=0.0
        for s in op.states:
            if s.bus: segs.append((t, t+s.dur_us))
            t+=s.dur_us
        return segs

    def bus_precheck(self, start_hint: float, segs: List[Tuple[float,float]])->bool:
        for (off0,off1) in segs:
            a0, a1 = quantize(start_hint+off0), quantize(start_hint+off1)
            for (s,e) in self.bus_resv:
                if not (a1<=s or e<=a0): return False
        return True

    def bus_reserve(self, start_time: float, segs: List[Tuple[float,float]]):
        for (off0,off1) in segs:
            self.bus_resv.append((quantize(start_time+off0), quantize(start_time+off1)))

    # ---------- helpers for PROGRAM planning ----------
    def _next_page_in_block_future(self, die:int, plane:int, block:int)->int:
        """returns next page to program in this block (>=0), or pages_per_block if full"""
        last = self.addr_state_future[(die,plane,block)]
        return (last + 1) if last < self.pages_per_block-1 else self.pages_per_block

    def _find_block_for_page_future(self, die:int, plane:int, target_page:int)->Optional[int]:
        """find a block whose next page equals target_page (i.e., future == target_page-1)"""
        for b in range(self.blocks_per_plane):
            if self._next_page_in_block_future(die, plane, b) == target_page:
                return b
        return None

    def _first_erased_block(self, die:int, plane:int)->Optional[int]:
        for b in range(self.blocks_per_plane):
            if self.addr_state_future[(die,plane,b)] == -1:
                return b
        return None

    # ---------- planner (non-greedy; uses future/committed rails) ----------
    def _random_plane_sets(self, fanout:int, tries:int, start_plane:int)->List[List[int]]:
        P=list(range(self.planes)); out=[]
        for _ in range(tries):
            cand=set(random.sample(P, min(fanout,len(P))))
            if start_plane not in cand and random.random()<0.6:
                if len(cand)>0: cand.pop()
                cand.add(start_plane)
            if len(cand)==fanout:
                key=tuple(sorted(cand))
                if key not in out: out.append(key)
        return [list(ps) for ps in dict.fromkeys(out)]

    def _committed_pages(self, die:int, plane:int)->Set[int]:
        return {p for (b,p) in self.programmed_committed[(die,plane)]}

    def plan_multipane(self, kind: OpKind, die:int, start_plane:int, desired_fanout:int, interleave:bool)\
            -> Optional[Tuple[List[Address], List[int], Scope]]:
        if desired_fanout<1: desired_fanout=1
        tries=self.cfg["policy"]["planner_max_tries"]
        # degrade loop: try fanout f from desired->1
        for f in range(desired_fanout, 0, -1):
            for plane_set in self._random_plane_sets(f, tries, start_plane):
                if kind==OpKind.READ:
                    # Intersection of committed pages across planes
                    commons=None
                    for pl in plane_set:
                        pages=self._committed_pages(die,pl)
                        commons=pages if commons is None else (commons & pages)
                        if not commons: break
                    if not commons: 
                        continue
                    page=random.choice(sorted(list(commons)))
                    targets=[]
                    for pl in plane_set:
                        # pick any block that contains (block,page)
                        blks=[b for (b,p) in self.programmed_committed[(die,pl)] if p==page]
                        if not blks: 
                            targets=[]; break
                        targets.append(Address(die,pl,blks[0],page))
                    if not targets: 
                        continue
                    scope=Scope.PLANE_SET
                    return targets, plane_set, scope

                elif kind==OpKind.PROGRAM:
                    # try to align next page across planes.
                    # candidate pages: (a) most common next-page of write_head blocks, (b) 0 if all have erased blocks
                    nxts=[]
                    for pl in plane_set:
                        b_head=self.write_head[(die,pl)]
                        nxt = self._next_page_in_block_future(die,pl,b_head)
                        if nxt>=self.pages_per_block: nxt = None  # head block full
                        nxts.append(nxt)
                    candidates=[]
                    # (a) mode among non-None
                    vals=[x for x in nxts if x is not None]
                    if vals:
                        # simple mode by frequency
                        freq={}
                        for v in vals: freq[v]=freq.get(v,0)+1
                        mode_val=max(freq.items(), key=lambda x:x[1])[0]
                        candidates.append(mode_val)
                    # (b) zero if all planes can find erased block
                    if all(self._first_erased_block(die,pl) is not None for pl in plane_set):
                        if 0 not in candidates: candidates.append(0)
                    if not candidates: 
                        continue

                    chosen=None
                    for page in candidates:
                        tlist=[]
                        ok=True
                        for pl in plane_set:
                            # if head matches target page, use it; else find any block with that next page
                            b_head=self.write_head[(die,pl)]
                            if self._next_page_in_block_future(die,pl,b_head)==page:
                                b=b_head
                            else:
                                b=self._find_block_for_page_future(die,pl,page)
                                if b is None:
                                    ok=False; break
                            tlist.append(Address(die,pl,b,page))
                        if ok:
                            chosen=(tlist, page); break
                    if not chosen:
                        continue
                    targets, _ = chosen
                    scope=Scope.DIE_WIDE
                    return targets, plane_set, scope

                elif kind==OpKind.ERASE:
                    targets=[]
                    for pl in plane_set:
                        # erase write_head block preferentially if not erased
                        b=self.write_head[(die,pl)]
                        # pick a non-erased block if possible, else any block
                        if self.addr_state_future[(die,pl,b)] == -1:
                            # find some non-erased block
                            found=None
                            for bb in range(self.blocks_per_plane):
                                if self.addr_state_future[(die,pl,bb)] >= 0: 
                                    found=bb; break
                            if found is not None: b=found
                        targets.append(Address(die,pl,b,None))
                    scope=Scope.DIE_WIDE
                    return targets, plane_set, scope

                elif kind==OpKind.SR:
                    return [Address(die,plane_set[0],0,None)], plane_set[:1], Scope.NONE

        return None

    # ---------- precheck / reserve / future registration / commit ----------
    def precheck_planescope(self, kind: OpKind, targets: List[Address], start_hint: float, scope: Scope)->bool:
        start_hint=quantize(start_hint); end_hint=start_hint
        die=targets[0].die
        if scope==Scope.DIE_WIDE: planes={(die,p) for p in range(self.planes)}
        elif scope==Scope.PLANE_SET: planes={(t.die,t.plane) for t in targets}
        else: planes={(targets[0].die, targets[0].plane)}
        # time overlap
        for (d,p) in planes:
            for (s,e,_) in self.resv[(d,p)]:
                if not (end_hint<=s or e<=start_hint): 
                    return False
        # address rules
        for t in targets:
            com=self.addr_state_committed[(t.die,t.plane,t.block)]
            fut=self.addr_state_future[(t.die,t.plane,t.block)]
            if kind==OpKind.PROGRAM:
                if t.page is None: return False
                # must be exactly next page in FUTURE rail
                if t.page != fut + 1: return False
                if t.page >= self.pages_per_block: return False
            elif kind==OpKind.READ:
                if t.page is None or com < 0 or t.page > com: return False
            elif kind==OpKind.ERASE:
                pass
        return True

    def reserve_planescope(self, op: Operation, start: float, end: float):
        die=op.targets[0].die; start=quantize(start); end=quantize(end)
        if op.meta.get("scope")=="DIE_WIDE":
            planes=[(die,p) for p in range(self.planes)]
        elif op.meta.get("scope")=="PLANE_SET":
            planes=[(t.die,t.plane) for t in op.targets]
        else:
            planes=[(op.targets[0].die, op.targets[0].plane)]
        for (d,p) in planes:
            self.available[(d,p)]=max(self.available[(d,p)], end)
            self.resv[(d,p)].append((start,end,None))

    def register_future(self, op: Operation, start: float, end: float):
        """예약 성공 직후 호출: future rail을 즉시 갱신하여 중복 PROGRAM 방지"""
        for t in op.targets:
            key=(t.die,t.plane,t.block)
            if op.kind==OpKind.PROGRAM and t.page is not None:
                # advance future
                self.addr_state_future[key] = max(self.addr_state_future[key], t.page)
                # update write head if block is full
                nextp = self._next_page_in_block_future(t.die,t.plane,t.block)
                if nextp >= self.pages_per_block:
                    # move write head to an erased block if available
                    er = self._first_erased_block(t.die,t.plane)
                    if er is not None:
                        self.write_head[(t.die,t.plane)] = er
            elif op.kind==OpKind.ERASE:
                # reset to ERASED
                self.addr_state_future[key] = -1
                # prefer erased block as write head
                self.write_head[(t.die,t.plane)] = t.block

    def commit(self, op: Operation):
        for t in op.targets:
            key=(t.die,t.plane,t.block)
            if op.kind==OpKind.PROGRAM and t.page is not None:
                self.addr_state_committed[key] = max(self.addr_state_committed[key], t.page)
                self.programmed_committed[(t.die,t.plane)].add((t.block,t.page))
            elif op.kind==OpKind.ERASE:
                self.addr_state_committed[key] = -1
                # remove all committed pages of this block
                self.programmed_committed[(t.die,t.plane)] = {
                    pp for pp in self.programmed_committed[(t.die,t.plane)] if pp[0] != t.block
                }
        # invariant: committed <= future
        # (lightweight check; can be turned into assert in debug)
        # for k in self.addr_state_committed:
        #     if self.addr_state_committed[k] > self.addr_state_future[k]:
        #         raise RuntimeError("state rail violated")

# ---------------------------- Exclusion Manager (runtime blocking) ----------------------------
@dataclass
class ExclWindow:
    start: float; end: float
    scope: str
    die: Optional[int]
    tokens: Set[str]        # {"ANY"}, {"BASE:READ"}, {"ALIAS:MUL_READ"} ...

class ExclusionManager:
    def __init__(self, cfg: Dict[str,Any]):
        self.cfg = cfg
        self.global_windows: List[ExclWindow] = []
        self.die_windows: Dict[int, List[ExclWindow]] = {}

    def _state_windows(self, op: Operation, start: float, states: List[str]) -> List[Tuple[float,float]]:
        wins=[]; t=start
        segs=[]
        for s in op.states:
            segs.append((s.name, t, t+s.dur_us)); t+=s.dur_us
        if states==["*"]:
            return [(segs[0][1], segs[-1][2])]
        want=set(states)
        for name, s0, s1 in segs:
            if name in want: wins.append((s0,s1))
        return wins

    def _token_blocks(self, tok: str, op: Operation) -> bool:
        if tok=="ANY": return True
        if tok.startswith("BASE:"):
            base=tok.split(":")[1]
            return op.kind.name==base
        if tok.startswith("ALIAS:"):
            alias=tok.split(":")[1]
            if alias=="MUL_READ": return (op.kind==OpKind.READ and op.meta.get("arity",1)>1)
            if alias=="SIN_READ": return (op.kind==OpKind.READ and op.meta.get("arity",1)==1)
        return False

    def allowed(self, op: Operation, start: float, end: float) -> bool:
        for w in self.global_windows:
            if not (end<=w.start or w.end<=start):
                if any(self._token_blocks(tok, op) for tok in w.tokens):
                    return False
        die=op.targets[0].die
        for w in self.die_windows.get(die, []):
            if not (end<=w.start or w.end<=start):
                if any(self._token_blocks(tok, op) for tok in w.tokens):
                    return False
        return True

    def register(self, op: Operation, start: float):
        rules = self.cfg.get("constraints",{}).get("exclusions",[])
        die = op.targets[0].die
        for r in rules:
            when=r["when"]; if_op=when.get("op")
            if if_op != op.kind.name:
                if not (op.kind==OpKind.READ and if_op=="READ"): 
                    continue
            alias_need = when.get("alias")
            if alias_need=="MUL" and not (op.meta.get("arity",1)>1): 
                continue
            if alias_need=="SIN" and not (op.meta.get("arity",1)==1): 
                continue
            states = when.get("states", ["*"])
            windows = self._state_windows(op, start, states)
            scope=r.get("scope","GLOBAL"); tokens=set(r.get("blocks",[]))
            for (s0,s1) in windows:
                w=ExclWindow(start=quantize(s0), end=quantize(s1), scope=scope, die=(die if scope=="DIE" else None), tokens=tokens)
                if scope=="GLOBAL":
                    self.global_windows.append(w)
                else:
                    self.die_windows.setdefault(die,[]).append(w)

# ---------------------------- Obligation Manager ----------------------------
@dataclass(order=True)
class _ObHeapItem:
    deadline_us: float
    seq: int
    ob: "Obligation" = field(compare=False)

@dataclass
class Obligation:
    require: OpKind
    targets: List[Address]
    deadline_us: float
    boost_factor: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg_list: List[Dict[str,Any]]):
        self.specs = cfg_list
        self.heap: List[_ObHeapItem] = []; self._seq=0

    def on_commit(self, op: Operation, now_us: float):
        for spec in self.specs:
            if spec["issuer"] == op.kind.name:
                dt=sample_dist(spec["window_us"])
                ob=Obligation(require=OpKind[spec["require"]], targets=op.targets,
                              deadline_us=quantize(now_us+dt),
                              boost_factor=spec["priority_boost"]["boost_factor"],
                              hard_slot=spec["priority_boost"].get("hard_slot", False))
                heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=self._seq, ob=ob))
                self._seq+=1
                first=op.targets[0]
                print(f"[{now_us:7.2f} us] OBLIG  created: {op.kind.name} -> {ob.require.name} by {ob.deadline_us:7.2f} us, target(d{first.die},p{first.plane})")

    def pop_urgent(self, now_us: float, die:int, plane:int, horizon_us: float, earliest_start: float) -> Optional[Obligation]:
        if not self.heap: return None
        kept=[]; chosen=None
        now_us=quantize(now_us); earliest_start=quantize(earliest_start)
        while self.heap and not chosen:
            item=heapq.heappop(self.heap); ob=item.ob
            plane_list={a.plane for a in ob.targets}
            same_die=(ob.targets[0].die==die); same_plane=(plane in plane_list)
            in_horizon=((ob.deadline_us-now_us)<=max(horizon_us,0.0)) or ob.hard_slot
            feasible=(earliest_start<=ob.deadline_us)
            if same_die and same_plane and in_horizon and feasible: chosen=ob; break
            kept.append(item)
        for it in kept: heapq.heappush(self.heap, it)
        return chosen

# ---------------------------- Policy Engine ----------------------------
class PolicyEngine:
    def __init__(self, cfg, addr: AddressManager, obl: ObligationManager, excl: ExclusionManager):
        self.cfg=cfg; self.addr=addr; self.obl=obl; self.excl=excl
        self.stats={"alias_degrade":0}

    def _score(self, op_name: str, phase_label: str, g: Dict[str,str], l: Dict[str,str]) -> float:
        w=self.cfg["weights"]["base"]["host"].get(op_name,0.0)
        w*=self.cfg["weights"]["g_state"]["pgmable_ratio"].get(g["pgmable_ratio"],1.0)
        w*=self.cfg["weights"]["g_state"]["readable_ratio"].get(g["readable_ratio"],1.0)
        w*=self.cfg["weights"]["g_local"]["plane_busy_frac"].get(l["plane_busy_frac"],1.0)
        near="MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w*=self.cfg["weights"]["g_phase"].get(op_name,{}).get(near,1.0)
        return w

    def _fanout_from_alias(self, base_name: str, alias_constraint: Optional[Tuple[str,int]], hook_label: str)->Tuple[int,bool]:
        fanout, interleave = get_phase_selection_override(self.cfg, hook_label, base_name)
        if alias_constraint:
            mode,val=alias_constraint
            if mode=="eq": fanout=val
            elif mode=="ge": fanout=max(fanout,val)
        return max(1,fanout), interleave

    def _exclusion_ok(self, op: Operation, die:int, plane_set: List[int], start_hint: float) -> bool:
        scope = Scope[op.meta["scope"]]
        start = self.addr.earliest_start_for_scope(die, scope, plane_set)
        dur = get_op_duration(op); end=quantize(start+dur)
        return self.excl.allowed(op, start, end)

    def propose(self, now_us: float, hook: PhaseHook, g: Dict[str,str], l: Dict[str,str], earliest_start: float) -> Optional[Operation]:
        die, hook_plane = hook.die, hook.plane

        # 0) obligation 우선
        ob=self.obl.pop_urgent(now_us, die, hook_plane, horizon_us=10.0, earliest_start=earliest_start)
        if ob:
            cfg_op=self.cfg["op_specs"][ob.require.name]; op=build_operation(ob.require, cfg_op, ob.targets)
            op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=sorted({a.plane for a in ob.targets}); op.meta["arity"]=len(op.meta["plane_list"])
            scope=Scope[op.meta["scope"]]; plane_set=op.meta["plane_list"]
            start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
            if self.addr.precheck_planescope(op.kind, op.targets, start_hint, scope)\
               and self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op))\
               and self._exclusion_ok(op, die, plane_set, start_hint):
                op.meta["source"]="obligation"; op.meta["phase_key_used"]="(obligation)"; return op

        # 1) phase-conditional (alias + SR)
        allow=set(list(OP_ALIAS.keys())+["READ","PROGRAM","ERASE","SR"])
        dist, used_key = get_phase_dist(self.cfg, hook.label)
        if dist:
            pick=roulette_pick(dist, allow)
            if pick:
                base, alias_const = resolve_alias(pick)
                kind=OpKind[base]
                if kind==OpKind.SR:
                    plan=self.addr.plan_multipane(kind, die, hook_plane, 1, True)
                else:
                    fanout, interleave=self._fanout_from_alias(base, alias_const, hook.label)
                    plan=self.addr.plan_multipane(kind, die, hook_plane, fanout, interleave)
                    if not plan and fanout>1:
                        self.stats["alias_degrade"]+=1
                        plan=self.addr.plan_multipane(kind, die, hook_plane, 1, interleave)
                if plan:
                    targets, plane_set, scope=plan
                    cfg_op=self.cfg["op_specs"][base]; op=build_operation(kind, cfg_op, targets)
                    op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=plane_set; op.meta["arity"]=len(plane_set); op.meta["alias_used"]=pick
                    start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
                    if self.addr.precheck_planescope(kind, targets, start_hint, scope)\
                       and self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op))\
                       and self._exclusion_ok(op, die, plane_set, start_hint):
                        op.meta["source"]="policy.phase_conditional"; op.meta["phase_key_used"]=used_key; return op
            # 실패 시 백오프

        # 2) backoff
        cand=[]
        for name in ["READ","PROGRAM","ERASE","SR"]:
            s=self._score(name, hook.label, g, l)
            if s>0: cand.append((name,s))
        if not cand: return None
        tot=sum(s for _,s in cand); r=random.random()*tot; acc=0.0; pick=cand[-1][0]
        for name,s in cand:
            acc+=s
            if r<=acc: pick=name; break
        kind=OpKind[pick]
        if kind==OpKind.SR:
            plan=self.addr.plan_multipane(kind, die, hook_plane, 1, True)
        else:
            fanout, interleave=get_phase_selection_override(self.cfg, hook.label, pick)
            plan=self.addr.plan_multipane(kind, die, hook_plane, fanout, interleave)
        if not plan: return None
        targets, plane_set, scope=plan
        cfg_op=self.cfg["op_specs"][pick]; op=build_operation(kind, cfg_op, targets)
        op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=plane_set; op.meta["arity"]=len(plane_set)
        start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
        if not (self.addr.precheck_planescope(kind, targets, start_hint, scope)\
                and self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op))\
                and self._exclusion_ok(op, die, plane_set, start_hint)):
            return None
        op.meta["source"]="policy.score_backoff"; op.meta["phase_key_used"]="(score_backoff)"; return op

# ---------------------------- Scheduler ----------------------------
def _addr_str(a: Address)->str: return f"(d{a.die},p{a.plane},b{a.block},pg{a.page})"

class Scheduler:
    def __init__(self, cfg, addr: AddressManager, spe: PolicyEngine, obl: ObligationManager, excl: ExclusionManager):
        self.cfg=cfg; self.addr=addr; self.SPE=spe; self.obl=obl; self.excl=excl
        self.now=0.0; self.ev=[]; self._seq=0
        self.stat_propose_calls=0; self.stat_scheduled=0
        self._push(0.0, "QUEUE_REFILL", None)
        for plane in range(self.addr.planes):
            self._push(0.0, "PHASE_HOOK", PhaseHook(0.0, "BOOT.START", 0, plane))

    def _push(self, t: float, typ: str, payload: Any):
        heapq.heappush(self.ev, (quantize(t), self._seq, typ, payload)); self._seq+=1

    def _start_time_for_op(self, op: Operation) -> float:
        die=op.targets[0].die
        scope=Scope[op.meta.get("scope","PLANE_SET")]
        plane_set=[a.plane for a in op.targets]
        t_planes=self.addr.earliest_start_for_scope(die, scope, plane_set)
        return quantize(max(self.now, t_planes))

    def _label_for_read(self, op: Operation)->str:
        if op.kind!=OpKind.READ: return op.kind.name
        return "MUL_READ" if op.meta.get("arity",1)>1 else "SIN_READ"

    def _schedule_operation(self, op: Operation):
        start=self._start_time_for_op(op); dur=get_op_duration(op); end=quantize(start+dur)
        # plane scope reserve + bus reserve + exclusion windows register + future update
        self.addr.reserve_planescope(op, start, end)
        self.addr.bus_reserve(start, self.addr.bus_segments_for_op(op))
        self.excl.register(op, start)
        self.addr.register_future(op, start, end)

        # events
        self._push(start, "OP_START", op); self._push(end, "OP_END", op)

        # phase hooks (READ는 SIN_READ/MUL_READ 라벨로)
        label_op=self._label_for_read(op)
        for t in op.targets:
            cur=start
            for s in op.states:
                self._push(cur,               "PHASE_HOOK", PhaseHook(cur,               f"{label_op}.{s.name}.START", t.die, t.plane))
                if s.name=="CORE_BUSY": 
                    self._push(cur + s.dur_us*0.5, "PHASE_HOOK", PhaseHook(cur + s.dur_us*0.5, f"{label_op}.{s.name}.MID",   t.die, t.plane))
                self._push(cur + s.dur_us,    "PHASE_HOOK", PhaseHook(cur + s.dur_us,    f"{label_op}.{s.name}.END",   t.die, t.plane))
                cur += s.dur_us

        first=op.targets[0]
        print(f"[{self.now:7.2f} us] SCHED  {op.kind.name:7s} arity={op.meta.get('arity')} scope={op.meta.get('scope')} start={start:7.2f} end={end:7.2f} 1st={_addr_str(first)} src={op.meta.get('source')} alias={op.meta.get('alias_used')}")

        self.stat_scheduled+=1

    def run_until(self, t_end: float):
        t_end=quantize(t_end)
        while self.ev and self.ev[0][0] <= t_end:
            self.now, _, typ, payload = heapq.heappop(self.ev)

            if typ=="QUEUE_REFILL":
                for plane in range(self.addr.planes):
                    self._push(self.now, "PHASE_HOOK", PhaseHook(self.now, "REFILL.NUDGE", 0, plane))
                self._push(self.now + self.cfg["policy"]["queue_refill_period_us"], "QUEUE_REFILL", None)

            elif typ=="PHASE_HOOK":
                hook: PhaseHook = payload
                earliest_start=self.addr.available_at(hook.die, hook.plane)
                g,l=self.addr.observe_states(hook.die, hook.plane, self.now)
                self.stat_propose_calls+=1
                op=self.SPE.propose(self.now, hook, g, l, earliest_start)
                if op: self._schedule_operation(op)

            elif typ=="OP_START":
                op: Operation=payload; first=op.targets[0]
                print(f"[{self.now:7.2f} us] START  {op.kind.name:7s} arity={op.meta.get('arity')} target={_addr_str(first)}")

            elif typ=="OP_END":
                op: Operation=payload; first=op.targets[0]
                print(f"[{self.now:7.2f} us] END    {op.kind.name:7s} arity={op.meta.get('arity')} target={_addr_str(first)}")
                self.addr.commit(op); self.obl.on_commit(op, self.now)

        print(f"\n=== Stats ===")
        print(f"propose calls : {self.stat_propose_calls}")
        print(f"scheduled ops : {self.stat_scheduled}")
        if self.stat_propose_calls:
            print(f"accept ratio  : {100.0*self.stat_scheduled/self.stat_propose_calls:.1f}%")

# ---------------------------- Selection overrides ----------------------------
def get_phase_selection_override(cfg: Dict[str,Any], hook_label: str, kind_name: str):
    op, state, pos = parse_hook_key(hook_label)
    po=cfg.get("selection",{}).get("phase_overrides",{})
    keys=[]
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    for k in keys:
        val=po.get(k)
        if val:
            return int(val.get("fanout",1)), bool(val.get("interleave",True))
    dflt=cfg.get("selection",{}).get("defaults",{}).get(kind_name,{"fanout":1,"interleave":True})
    return int(dflt.get("fanout",1)), bool(dflt.get("interleave",True))

# ---------------------------- Main ----------------------------
def main():
    random.seed(CFG["rng_seed"])
    addr=AddressManager(CFG); excl=ExclusionManager(CFG)
    obl=ObligationManager(CFG["obligations"])
    spe=PolicyEngine(CFG, addr, obl, excl)
    sch=Scheduler(CFG, addr, spe, obl, excl)
    print("=== NAND Sequence Generator (P4: addr-state rails + no-dup PROGRAM + committed-only READ) ===")
    sch.run_until(CFG["policy"]["run_until_us"])
    print("=== Done ===")

if __name__=="__main__":
    main()

```

핵심 변경 요약
1. 상태 2레일 도입 (Committed/Future)
  - addr_state_committed[(d,p,b)]: 커밋 완료된 마지막 page (−1=ERASED, −2=initial).
  - addr_state_future[(d,p,b)]: 예약을 즉시 반영한 미래 상태.
  - programmed_committed[(d,p)]: READ 가시성 소스 — 커밋된 page만 포함.
2. 예약 직후 Future 반영 (register_future)
  - PROGRAM 예약 → 해당 block의 future를 target.page로 즉시 갱신 ⇒ 중복 PROGRAM 불가.
  - ERASE 예약 → 해당 block future=-1.
3. precheck 주소 규칙 강화
  - PROGRAM: target.page == future + 1 (정확히 다음 페이지).
  - READ: target.page <= committed (커밋된 페이지만 읽기).
4. 멀티‑플레인 플래너 갱신
  - READ: plane‑set의 committed pages 교집합에서 page 선택.
  - PROGRAM: 후보 page를 **(a) mode of next pages, (b) 0(모두 지운 블록 존재 시)**로 시도 → 각 plane에 해당 next page가 가능한 block을 찾는다 → 실패 시 fanout 강등.
5. WRITE 헤드 관리
  - write_head[(d,p)]로 기본 PROGRAM 블록 포인터 유지; block이 찼으면 erased block으로 자동 전진.
6. 관측값(observe_states) 정합화
  - pgmable_ratio: future 기준 여유 page 있는 block 비율,
  - readable_ratio: committed 기준 읽기 가능한 block 비율.
7. 스케줄러에 한 줄 추가
  - 예약 직후 addr.register_future(op, start, end) 호출.

기대 효과
- (재현된) 중복 PROGRAM(pg0 → 또 pg0) 즉시 방지.
- READ는 프로그램된 페이지만 스케줄 가능(“blank block은 read 불가”).
- 멀티‑플레인 PROGRAM 정렬은 미래 상태를 기준으로 안정화, 불가 시 자동 강등(통계로 추적 가능).

원하면 이 버전에 **GlobalTimelineBuilder(ATE 패턴 변환; NOP 채움/단위 스케일)**도 바로 얹어줄게.

## 👤 User

우선 지금 구조에서, stats 을 추가하자.
- obligation 성공률
그리고, block 과 page 의 개념을 재정의 하자. plane 은 block%4 이고, topology 에서 blocks_per_plane 이란 개념은 없애자.
그리고, 현재 구조에서 policy 에 의한 operation 추가가 폭발하는 경향이 있어. 그 때문에, obligation 인 DOUT 이 수행이 전혀 되지 않아. 이 문제는 내 생각에 policy 제안 시에, earliest_start 를 사용하기 때문에, 하나의 operation 이 만들어지면서 3개씩 훅이 만들어 지면서, 모두 예약되버리는거야. 이걸 해결할 방법은 phase-conditional 을 사용해서 operation 제안을 할 때, 현재 시각에서의 phase~ phase + delta 정도로 아주 가까운 미래안에 operation 을 추가 가능할 때 선택이 되도록 하는거야. 그러면 CORE_BUSY 중간에 policy operation 이 폭발적으로 추가되지 않고, SR 과 같은 operation 만 추가가 되는거야. 그게 자연스러운 상황이야. 이 관점을 고려해서 구현 계획을 제시 후, risk 평가 및 진행하도록 하자.

## 🤖 Assistant

좋아. 요청한 **3가지 변경(통계·블록/페이지 재정의·폭발 억제)**을 현재 구조에 “최소 침습”으로 녹이는 구현 계획 + 핵심 패치 스케치 + 리스크 평가를 한 번에 정리했어.  

(코드는 지금 너의 P3/P4 계열 통합본 기준으로 설명한다.)

1) 통계 추가: Obligation 성공률
정의
- created: READ 커밋으로 DOUT 의무가 생성된 횟수
- assigned: 의무가 실제 오퍼레이션으로 스케줄 되었다(예약 성공)
- fulfilled: 해당 오퍼레이션이 커밋됨
- fulfilled_in_time: 커밋 시각 ≤ 의무 deadline
- expired: deadline 경과 시점까지 스케줄/커밋이 안 됨

성공률 = fulfilled_in_time / created

변경 포인트
- ObligationManager
  - 필드: self.stats = {"created":0, "assigned":0, "fulfilled":0, "fulfilled_in_time":0, "expired":0}
  - on_commit(READ)에서 created += 1 (기존 생성 로직 유지)
  - pop_urgent(...)가 반환한 obligation을 op.meta["obligation"] = ob로 부착
  - mark_assigned(ob) / mark_fulfilled(ob, now) / expire_due(now) 메서드 추가
    - expire_due(now): 이벤트 루프에서 주기적으로 호출해 deadline <= now 항목을 만료 처리
- Scheduler._schedule_operation(op):
  - if "obligation" in op.meta: obl.mark_assigned(op.meta["obligation"])
- Scheduler의 OP_END 처리:
  - if "obligation" in op.meta: obl.mark_fulfilled(op.meta["obligation"], now)
- Scheduler.run_until 루프에서 이벤트 처리 전후에 obl.expire_due(self.now) 호출
- 종료 시 통계 출력:
  - obligation success: {fulfilled_in_time}/{created} ({ratio:.1f}%)

2) 블록/페이지 재정의
요구사항 반영
- plane = (block % planes)
- topology에서 blocks_per_plane 제거 → **blocks (die 전체 블록 수)**로 일원화

데이터 모델 변경 (AddressManager)
- 토폴로지:
- 상태 레일(그대로 유지하되 key 변경):
  - addr_state_committed[(die, block)] : int  (-3/-2/-1/0..)
  - addr_state_future[(die, block)]    : int
  - programmed_committed[(die)] : Set[(block, page)] (plane별로는 필터로 구분)
  - write_head[(die, plane)] : int  (해당 plane에 속하는 block 인덱스. 초기값 = plane, 또는 plane 모듈 조건을 만족하는 첫 블록)

주요 루프 변경: “plane 단위 블록 열람”이 필요할 때  

for b in range(blocks): if b % planes == plane: ...

API/로직 영향
- Address: 여전히 (die, plane, block, page) 보존. 단, 일관성 assert
  - 예약/프리체크/커밋 시 assert plane == (block % planes)
- observe_states(die, plane):
  - plane의 블록 집합 B_p = { b | 0<=b<blocks, b%planes==plane }에 대해
    - pgmable_blocks: addr_state_future[(die,b)] < pages_per_block-1
    - readable_blocks: addr_state_committed[(die,b)] >= 0
- READ 플래닝:
  - programmed_committed[die]에서 b%planes==plane인 항목만 필터 후 페이지 교집합
- PROGRAM 플래닝:
  - 각 plane의 write_head[(die,plane)]를 시작점으로, 목표 페이지 page에 대해
    - addr_state_future[(die, b)] == page-1을 만족하는 b (b%planes==plane)을 탐색
- ERASE:
  - write_head 우선, 없으면 plane에 속하는 임의의 non-erased block
- 커밋/예약(future) 갱신:
  - 키 (die, block) 기반으로 업데이트
  - programmed_committed[(die)]에 (block,page) 저장/제거
  - write_head는 블록 full/erase 시 적절히 다음 후보로 이동(조건: b%planes==plane)

3) Policy 폭발 억제 (Near‑Future Admission Gating)
문제 원인
- propose 시 earliest_start가 현재 훅 시각보다 멀리 있어도 스케줄 승인이 나면서,

하나의 OP 예약이 **여러 훅(START/MID/END)**를 만들어 후속 제안이 더 멀리 예약되는 연쇄 폭발 발생.

→ 결과적으로 DOUT 의무가 끼어들 여지가 사라짐.

해결 개념
- “아주 가까운 미래(Δ)” 안에서 시작 가능한 것만 policy가 승인
- Δ는 phase별/연산별로 튜닝 가능 (CORE_BUSY 중엔 매우 작게 → SR 위주만 통과)
- Obligation은 예외(deadline 기반): Δ 무시하거나 별도 Δ_obligation

CFG 추가 (예시)

```yaml
admission:
  default_delta_us: 0.30
  phase_overrides:
    CORE_BUSY: 0.05
    ISSUE:     0.10
    DATA_OUT:  0.05
    BOOT:      0.30
    REFILL:    0.10
  op_overrides:
    SR: 0.30
  obligation_bypass: true

```

구현(PolicyEngine)
- get_admission_delta(cfg, hook.label, op_kind) 유틸 추가:
  - 훅 라벨에서 state 추출 → phase_overrides 우선, 없으면 op_overrides[op_kind], 없으면 default
- propose에서 plan + precheck + bus_precheck 통과 후:
  - start_hint = addr.earliest_start_for_scope(...)
  - Admission check: start_hint <= now_us + delta인지 검사
    - 아니라면 reject (다른 후보 혹은 None)
- Obligation 경로:
  - obligation_bypass == true이면 Δ 검사를 건너뜀
  - (선택) bypass=false면 Δ를 min(delta, ob.deadline - now_us)로 제한

이렇게 하면 CORE_BUSY 중에는 SR처럼 즉시 발행 가능한 경량 연산만 들어오고, DOUT이 빈틈을 얻는다.

4) 핵심 패치 스케치
4.1 ObligationManager 통계/라이프사이클

```python
@dataclass
class Obligation:
    id: int
    require: OpKind
    targets: List[Address]
    deadline_us: float
    hard_slot: bool

class ObligationManager:
    def __init__(...):
        self.stats = {"created":0,"assigned":0,"fulfilled":0,"fulfilled_in_time":0,"expired":0}
        self._seq = 0
        self.heap = []
        self.assigned: Dict[int, Obligation] = {}

    def on_commit(self, op, now):
        if op.kind.name == "READ":
            self._seq += 1
            ob = Obligation(id=self._seq, require=OpKind.DOUT, targets=op.targets,
                            deadline_us=quantize(now + sample_dist(spec["window_us"])),
                            hard_slot=spec["priority_boost"].get("hard_slot", False))
            heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=ob.id, ob=ob))
            self.stats["created"] += 1
            return

    def pop_urgent(...)->Optional[Obligation]:
        # 기존 로직 유지(반환 시 heap에서 제거)
        ...

    def mark_assigned(self, ob: Obligation):
        self.assigned[ob.id] = ob
        self.stats["assigned"] += 1

    def mark_fulfilled(self, ob: Obligation, now: float):
        if ob.id in self.assigned: self.assigned.pop(ob.id, None)
        self.stats["fulfilled"] += 1
        if now <= ob.deadline_us: self.stats["fulfilled_in_time"] += 1

    def expire_due(self, now: float):
        # heap의 프론트를 보며 만료
        kept=[]
        while self.heap and self.heap[0].deadline_us <= now:
            item = heapq.heappop(self.heap)
            self.stats["expired"] += 1
        # (assigned 중에서도 deadline 경과 확인하려면 추가 스캔)

```

- Scheduler._schedule_operation:

if "obligation" in op.meta: obl.mark_assigned(op.meta["obligation"])
- Scheduler 루프: 각 이벤트 처리 직전 obl.expire_due(self.now) 호출
- OP_END 시:

if "obligation" in op.meta: obl.mark_fulfilled(op.meta["obligation"], self.now)
- 종료 출력:

```python
s=obl.stats
rate = (100.0*s["fulfilled_in_time"]/s["created"]) if s["created"] else 0.0
print(f"obligations  : created={s['created']} assigned={s['assigned']} fulfilled={s['fulfilled']} in_time={s['fulfilled_in_time']} expired={s['expired']} success={rate:.1f}%")

```

4.2 Admission Gating

```python
def get_admission_delta(cfg, hook_label, op_kind_name):
    _, state, _ = parse_hook_key(hook_label)
    adm = cfg.get("admission", {})
    if state and state in adm.get("phase_overrides", {}):
        return float(adm["phase_overrides"][state])
    if op_kind_name in adm.get("op_overrides", {}):
        return float(adm["op_overrides"][op_kind_name])
    return float(adm.get("default_delta_us", 0.3))

# PolicyEngine.propose(...)
# (1) obligation branch
if ob:
    ...
    if cfg["admission"].get("obligation_bypass", True) is False:
        delta = min(get_admission_delta(cfg, hook.label, ob.require.name), ob.deadline_us - now_us)
        if start_hint > now_us + max(0.0, delta): 
            # 보수적으로 실패 처리(또는 heap에 재주입)
            pass
    return op

# (2) policy branch candidate op 준비 후, 최종 승인 직전
delta = get_admission_delta(self.cfg, hook.label, base)
if start_hint > now_us + delta:
    return None

```

4.3 블록/플레인 재정의 반영 (핵심만)

```python
# AddressManager.__init__
self.planes = topo["planes"]
self.blocks = topo["blocks"]

# 상태 레일 초기화
for b in range(self.blocks):
    self.addr_state_committed[(0,b)] = init_state
    self.addr_state_future[(0,b)]    = init_state
# programmed_committed[(0)] = set()
for p in range(self.planes):
    self.write_head[(0,p)] = p  # 또는 plane 모듈 최소 블록

def plane_of(self, block:int)->int: return block % self.planes

# observe_states(die, plane): B_p 루프
for b in range(self.blocks):
    if b % self.planes != plane: continue
    fut = self.addr_state_future[(die,b)]
    com = self.addr_state_committed[(die,b)]
    ...

# READ planner 교집합
def _committed_pages_plane(self, die, plane)->Set[int]:
    return {p for (b,p) in self.programmed_committed[(die)] if (b % self.planes)==plane}

# PROGRAM next page(from future) on plane-set
def _next_page_future(self, die, block)->int:
    last = self.addr_state_future[(die,block)]
    return (last + 1) if last < self.pages_per_block-1 else self.pages_per_block

def _find_block_for_page_future(self, die, plane, target_page)->Optional[int]:
    for b in range(self.blocks):
        if b % self.planes != plane: continue
        if self._next_page_future(die,b) == target_page: return b
    return None

# 커밋/예약(future)
if op.kind==PROGRAM:
    self.addr_state_future[(die, block)] = max( ..., page)
    # write_head 업데이트: if _next_page_future >= pages_per_block: write_head 이동(plane 모듈 유지)
elif op.kind==ERASE:
    self.addr_state_future[(die, block)] = -1

# programmed_committed 의 key는 (die) 하나
# 추가: self.programmed_committed[(die)].add((block,page))
# 삭제: set 컴프리헨션으로 block가 같은 것 제거

```

5) 리스크 평가 & 대응

| 영역 | 리스크 | 영향 | 대응/완화 |
| --- | --- | --- | --- |
| 블록/플레인 재정의 | 기존 blocks_per_plane 참조 코드 잔존 | 런타임 KeyError/논리오류 | grep/일괄 치환, self.blocks로 통일. plane별 루프는 b%planes 필터로 교체. 단위 테스트: 블록→플레인 매핑 assert |
| plane–block 불일치 | Address 생성 시 plane≠(block%planes) | 스케줄/커밋 상태 오염 | precheck_planescope에 assert/검사 추가(불일치 시 reject) |
| Admission gating 과도 | Δ가 너무 작아 policy 기아 | throughput/다양성 저하 | default_delta_us/phase별 Δ를 CFG로 조정. 의무는 bypass. Δ 메트릭 로깅(거절 사유) |
| 의무 만료 관리 | expire_due 타이밍 누락 | success율 왜곡 | 모든 이벤트 처리 시점마다 호출(경량). assigned map도 데드라인 검토 옵션 |
| 상태 2레일과 새 키 구조 | 커밋<future 불변조건 위반 | 중복 PROGRAM, READ 가시성 오류 | 예약 직후 future 갱신, 커밋에서 committed 갱신. 디버그 모드에서 assert committed<=future |
| write_head 이동 | plane 모듈 깨짐 | PROGRAM 정렬 실패 증가 | 이동 시 다음 plane‑모듈 block만 고려하도록 구현 |

6) To‑Do (실행 순서)
P0 (핵심)
1. ObligationManager 통계/라이프사이클(+Scheduler 연동)
2. admission 게이트 추가(phase/op별 Δ, obligation bypass)
3. Scheduler에서 expire_due() 주기 호출 및 통계 출력

P1 (블록/플레인 재정의)  

4. topology 스키마 교체(planes,blocks)  

5. AddressManager의 상태 레일 키를 (die, block)로 변경  

6. READ/PROGRAM/ERASE 플래너/프리체크/커밋 로직을 b%planes 기준으로 수정  

7. plane≠(block%planes) 검증 추가
P2 (품질/메트릭)  

8. Admission 거절 사유 카운터(phase/op별)  

9. 의무 성공률(시간 추세) 출력 옵션  

10. 회귀: seed 고정에서 accept ratio/obligation success 확인

필요하면, 위 계획을 바로 반영한 패치 버전 코드도 이어서 제공할게.  

(통계·admission·블록/플레인 재정의까지 한 파일에 묶어 드릴 수 있어.)

## 👤 User

통계·admission·블록/플레인 재정의까지 한 파일에 묶어줘

## 🤖 Assistant

아래는 요청하신 **통계(Obligation 성공률) + Admission(가까운 미래 게이팅) + 블록/플레인 재정의(plane = block % planes)**까지 모두 반영한 단일 파일입니다.  

이전 버전(P4)의 기능(에일리어스 기반 멀티플레인, SR, CORE_BUSY 제약, DOUT 글로벌 프리즈, DIE_WIDE 점유, Bus 게이팅)도 유지/호환됩니다.

파일명 예시: nandsim_p5_allinone.py

```python
# nandsim_p5_allinone.py
# - P5: Stats + Admission gating + Block/Plane redefinition
# - AddressManager v2: committed/future rails (no-dup PROGRAM; READ uses committed visibility)
# - Block/Plane: plane = block % planes; topology: {dies, planes, blocks, pages_per_block}
# - Policy admission gating (near-future only; phase/op tunable; obligations bypass)
# - Obligation stats: created/assigned/fulfilled/fulfilled_in_time/expired
# - Multi-plane alias (SIN_*/MUL_*), DIE_WIDE CORE_BUSY, Bus gating, SR, constraints incl. DOUT freeze

from __future__ import annotations
import heapq, random
from dataclasses import dataclass, field
from enum import Enum, auto
from typing import List, Dict, Any, Optional, Tuple, Set

# --------------------------------------------------------------------------
# Simulation resolution
SIM_RES_US = 0.01
def quantize(t: float) -> float:
    return round(t / SIM_RES_US) * SIM_RES_US

# --------------------------------------------------------------------------
# Config
CFG = {
    "rng_seed": 12345,
    "policy": {
        "queue_refill_period_us": 3.0,
        "run_until_us": 180.0,
        "planner_max_tries": 8,
    },

    # Admission gating (near-future only to prevent policy explosion)
    "admission": {
        "default_delta_us": 0.30,
        "phase_overrides": {
            "CORE_BUSY": 0.05,
            "ISSUE":     0.10,
            "DATA_OUT":  0.05,
            "BOOT":      0.30,
            "NUDGE":     0.10,  # from REFILL.NUDGE hooks
        },
        "op_overrides": {
            "SR": 0.30
        },
        "obligation_bypass": True  # obligations ignore admission delta by default
    },

    # Phase-conditional proposal (alias keys allowed)
    "phase_conditional": {
        "READ.ISSUE":                {"MUL_PROGRAM": 0.15, "SIN_PROGRAM": 0.10, "SIN_READ": 0.35, "MUL_READ": 0.25, "SIN_ERASE": 0.15, "SR": 0.00},
        "READ.CORE_BUSY.START":      {"MUL_READ": 0.50, "SIN_READ": 0.20, "SIN_PROGRAM": 0.10, "SIN_ERASE": 0.10, "SR": 0.10},
        "READ.DATA_OUT.START":       {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.15, "SIN_ERASE": 0.10, "SR": 0.05},

        "PROGRAM.ISSUE":             {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.15, "SIN_ERASE": 0.10, "SR": 0.05},
        "PROGRAM.CORE_BUSY":         {"SR": 1.0},   # during PROGRAM core-busy: only SR
        "PROGRAM.CORE_BUSY.END":     {"SIN_READ": 0.55, "MUL_READ": 0.25, "SIN_PROGRAM": 0.10, "SIN_ERASE": 0.05, "SR": 0.05},

        "ERASE.ISSUE":               {"SIN_PROGRAM": 0.40, "MUL_PROGRAM": 0.20, "SIN_READ": 0.25, "MUL_READ": 0.10, "SR": 0.05},
        "ERASE.CORE_BUSY":           {"SR": 1.0},   # during ERASE core-busy: only SR
        "ERASE.CORE_BUSY.END":       {"SIN_READ": 0.50, "MUL_READ": 0.20, "SIN_PROGRAM": 0.10, "MUL_PROGRAM": 0.05, "SR": 0.15},

        "MUL_READ.CORE_BUSY":        {"SR": 1.0},   # during MUL_READ core-busy: only SR
        "SIN_READ.CORE_BUSY":        {"SIN_READ": 0.6, "SR": 0.4},  # during SIN_READ core-busy: allow SIN_READ or SR; forbid MUL/PGM/ERASE

        "DEFAULT":                   {"SIN_READ": 0.55, "SIN_PROGRAM": 0.25, "SIN_ERASE": 0.10, "SR": 0.10},
    },

    # Backoff scoring weights (used if phase_conditional fails)
    "weights": {
        "base": {"host": {"READ": 0.70, "PROGRAM": 0.15, "ERASE": 0.05, "SR": 0.10, "RESET": 0.00, "DOUT": 0.00}},
        "g_state": {"pgmable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.8},
                    "readable_ratio": {"low": 1.3, "mid": 1.0, "high": 0.9}},
        "g_local": {"plane_busy_frac": {"low": 1.2, "mid": 1.0, "high": 0.9}},
        "g_phase": {
            "READ": {"START_NEAR": 1.2, "MID_NEAR": 0.9, "END_NEAR": 1.2},
            "PROGRAM": {"START_NEAR": 1.1, "MID_NEAR": 1.0, "END_NEAR": 0.9},
            "ERASE": {"START_NEAR": 0.9, "MID_NEAR": 1.1, "END_NEAR": 1.1},
            "SR": {"START_NEAR": 1.1, "MID_NEAR": 1.1, "END_NEAR": 1.1},
        },
    },

    # Selection defaults/overrides (for fanout/interleave)
    "selection": {
        "defaults": {
            "READ":    {"fanout": 1, "interleave": True},
            "PROGRAM": {"fanout": 2, "interleave": True},
            "ERASE":   {"fanout": 2, "interleave": False},
            "SR":      {"fanout": 1, "interleave": True},
        },
        "phase_overrides": {
            "READ.CORE_BUSY.START": {"fanout": 4, "interleave": True},
        }
    },

    # Op specs (state sequence + bus usage; scope for CORE_BUSY occupancy)
    "op_specs": {
        "READ": {
            "scope": "PLANE_SET",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 8.0, "std": 1.5, "min": 2.0}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "normal", "mean": 2.0, "std": 0.4, "min": 0.5}},
            ],
        },
        "PROGRAM": {
            "scope": "DIE_WIDE",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 20.0, "std": 3.0, "min": 8.0}},
            ],
        },
        "ERASE": {
            "scope": "DIE_WIDE",
            "page_equal_required": False,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.4}},
                {"name": "CORE_BUSY", "bus": False, "dist": {"kind": "normal", "mean": 40.0, "std": 5.0, "min": 15.0}},
            ],
        },
        "DOUT": {
            "scope": "NONE",
            "page_equal_required": True,
            "states": [
                {"name": "ISSUE",     "bus": False, "dist": {"kind": "fixed",  "value": 0.2}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "normal", "mean": 1.0, "std": 0.2, "min": 0.2}},
            ],
        },
        "SR": {
            "scope": "NONE",
            "page_equal_required": False,
            "states": [
                {"name": "ISSUE",     "bus": True,  "dist": {"kind": "fixed",  "value": 0.2}},
                {"name": "DATA_OUT",  "bus": True,  "dist": {"kind": "fixed",  "value": 0.3}},
            ],
        },
    },

    # Runtime exclusion rules (register on schedule; checked on propose)
    "constraints": {
        "exclusions": [
            # PROGRAM/ERASE: during CORE_BUSY block READ/PROGRAM/ERASE on the die; allow SR
            {"when": {"op": "PROGRAM", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},
            {"when": {"op": "ERASE",   "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},

            # MUL_READ: during CORE_BUSY block READ/PROGRAM/ERASE (on the die); allow SR
            {"when": {"op": "READ", "alias": "MUL", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["BASE:READ", "BASE:PROGRAM", "BASE:ERASE"]},

            # SIN_READ: during CORE_BUSY block MUL_READ + PROGRAM + ERASE; allow SIN_READ & SR
            {"when": {"op": "READ", "alias": "SIN", "states": ["CORE_BUSY"]}, "scope": "DIE",
             "blocks": ["ALIAS:MUL_READ", "BASE:PROGRAM", "BASE:ERASE"]},

            # DOUT: freeze all ops globally across its full duration
            {"when": {"op": "DOUT", "states": ["*"]}, "scope": "GLOBAL", "blocks": ["ANY"]},
        ]
    },

    # Obligation: READ → DOUT
    "obligations": [
        {
            "issuer": "READ",
            "require": "DOUT",
            "window_us": {"kind": "normal", "mean": 6.0, "std": 1.5, "min": 1.0},
            "priority_boost": {"start_us_before_deadline": 2.5, "boost_factor": 2.0, "hard_slot": True},
        }
    ],

    # Topology (redefined): plane = block % planes
    "topology": {
        "dies": 1,
        "planes": 4,
        "blocks": 32,           # total blocks per die (not per plane)
        "pages_per_block": 16,
    },

    "export": {"tu_us": 0.01, "nop_symbol": "NOP", "wait_as_nop": True, "drift_correction": True},

    # Address initial state: -1=ERASED, -2=initial(not erased)
    "address_init_state": -1,
}

# --------------------------------------------------------------------------
# Alias mapping for policy/external naming
OP_ALIAS = {
    "SIN_READ":    {"base": "READ",    "fanout": ("eq", 1)},
    "MUL_READ":    {"base": "READ",    "fanout": ("ge", 2)},
    "SIN_PROGRAM": {"base": "PROGRAM", "fanout": ("eq", 1)},
    "MUL_PROGRAM": {"base": "PROGRAM", "fanout": ("ge", 2)},
    "SIN_ERASE":   {"base": "ERASE",   "fanout": ("eq", 1)},
    "MUL_ERASE":   {"base": "ERASE",   "fanout": ("ge", 2)},
}

# --------------------------------------------------------------------------
# Models
class OpKind(Enum):
    READ=auto(); DOUT=auto(); PROGRAM=auto(); ERASE=auto(); SR=auto(); RESET=auto()

class Scope(Enum):
    NONE=0; PLANE_SET=1; DIE_WIDE=2

@dataclass(frozen=True)
class Address:
    die:int; plane:int; block:int; page:Optional[int]=None

@dataclass
class PhaseHook:
    time_us: float
    label: str
    die:int; plane:int

@dataclass
class StateSeg:
    name:str
    dur_us: float
    bus: bool = False

@dataclass
class Operation:
    kind: OpKind
    targets: List[Address]
    states: List[StateSeg]
    movable: bool = True
    meta: Dict[str,Any] = field(default_factory=dict)

# --------------------------------------------------------------------------
# Utils
def sample_dist(d: Dict[str, Any]) -> float:
    k = d["kind"]
    if k == "fixed": return float(d["value"])
    if k == "normal":
        m, s, mn = d["mean"], d["std"], d.get("min", 0.0)
        v = random.gauss(m, s); return max(v, mn)
    if k == "exp": return random.expovariate(d["lambda"])
    raise ValueError(f"unknown dist kind: {k}")

def parse_hook_key(label: str):
    parts = label.split(".")
    if len(parts) >= 3: return parts[0], parts[1], parts[2]
    if len(parts) == 2: return parts[0], parts[1], None
    return None, None, None

def get_phase_dist(cfg: Dict[str,Any], hook_label: str):
    op, state, pos = parse_hook_key(hook_label)
    pc = cfg.get("phase_conditional", {})
    keys=[]
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    keys.append("DEFAULT")
    for key in keys:
        dist = pc.get(key)
        if dist and sum(dist.values())>0: return dist, key
    return None, None

def roulette_pick(dist: Dict[str, float], allow: set) -> Optional[str]:
    items=[(n,p) for n,p in dist.items() if n in allow and p>0]
    if not items: return None
    tot=sum(p for _,p in items); r=random.random()*tot; acc=0.0; pick=items[-1][0]
    for n,p in items:
        acc+=p
        if r<=acc: pick=n; break
    return pick

def resolve_alias(name: str) -> Tuple[str, Optional[Tuple[str,int]]]:
    if name in OP_ALIAS: return OP_ALIAS[name]["base"], OP_ALIAS[name]["fanout"]
    return name, None

def get_admission_delta(cfg: Dict[str,Any], hook_label: str, op_kind_name: str) -> float:
    _, state, _ = parse_hook_key(hook_label)
    adm = cfg.get("admission", {})
    if state and state in adm.get("phase_overrides", {}):
        return float(adm["phase_overrides"][state])
    if op_kind_name in adm.get("op_overrides", {}):
        return float(adm["op_overrides"][op_kind_name])
    return float(adm.get("default_delta_us", 0.3))

# --------------------------------------------------------------------------
# Builders
def build_operation(kind: OpKind, cfg_op: Dict[str, Any], targets: List[Address]) -> Operation:
    states=[]
    for s in cfg_op["states"]:
        states.append(StateSeg(name=s["name"], dur_us=sample_dist(s["dist"]), bus=bool(s.get("bus", False))))
    return Operation(kind=kind, targets=targets, states=states)

def get_op_duration(op: Operation) -> float:
    return sum(seg.dur_us for seg in op.states)

# --------------------------------------------------------------------------
# Address & Bus Managers (with block/plane redefinition + state rails)
class AddressManager:
    """
    v2 상태 모델 (block-scoped):
    - addr_state_committed[(die, block)] : int  # last committed program page (-1=ERASED, -2=initial)
    - addr_state_future[(die, block)]    : int  # future after reservations
    - programmed_committed[(die)] : Set[(block, page)]
    - write_head[(die, plane)] : int  # block index assigned to plane (block % planes == plane)
    """
    def __init__(self, cfg: Dict[str, Any]):
        topo=cfg["topology"]; self.cfg=cfg
        self.dies=topo["dies"]; self.planes=topo["planes"]
        self.blocks=topo["blocks"]; self.pages_per_block=topo["pages_per_block"]

        self.available={(0,p):0.0 for p in range(self.planes)}  # per-plane availability time
        self.resv={(0,p):[] for p in range(self.planes)}        # per-plane reservations: (start,end,block)
        self.bus_resv: List[Tuple[float,float]] = []            # global bus reservations

        init_state = int(cfg.get("address_init_state", -1))
        self.addr_state_committed: Dict[Tuple[int,int], int] = {}
        self.addr_state_future:    Dict[Tuple[int,int], int] = {}
        self.programmed_committed: Dict[Tuple[int], Set[Tuple[int,int]]] = {(0,): set()}
        self.write_head: Dict[Tuple[int,int], int] = {}  # (die,plane)->block

        for b in range(self.blocks):
            self.addr_state_committed[(0,b)] = init_state
            self.addr_state_future[(0,b)]    = init_state
        for p in range(self.planes):
            self.write_head[(0,p)] = p  # first block of that plane stripe

    # ---- helpers for plane/block mapping ----
    def plane_of(self, block:int) -> int:
        return block % self.planes

    def iter_blocks_of_plane(self, plane:int):
        for b in range(plane, self.blocks, self.planes):
            yield b

    # ---- observations ----
    def available_at(self, die:int, plane:int)->float: return self.available[(die,plane)]

    def earliest_start_for_scope(self, die:int, scope: Scope, plane_set: Optional[List[int]]=None)->float:
        if scope==Scope.DIE_WIDE:
            planes=list(range(self.planes))
        elif scope==Scope.PLANE_SET and plane_set is not None:
            planes=plane_set
        else:
            planes=[plane_set[0]] if plane_set else [0]
        return max(self.available[(die,p)] for p in planes)

    def observe_states(self, die:int, plane:int, now_us: float):
        pgmable_blocks=0; readable_blocks=0
        for b in self.iter_blocks_of_plane(plane):
            fut=self.addr_state_future[(die,b)]
            com=self.addr_state_committed[(die,b)]
            if fut < self.pages_per_block-1: pgmable_blocks += 1
            if com >= 0: readable_blocks += 1
        total=max(1, len(list(self.iter_blocks_of_plane(plane))))
        def bucket(x):
            r=x/total
            return "low" if r<0.34 else ("mid" if r<0.67 else "high")
        pgmable_ratio=bucket(pgmable_blocks)
        readable_ratio=bucket(readable_blocks)
        plane_busy_frac="high" if self.available_at(die,plane)>now_us else "low"
        return ({"pgmable_ratio": pgmable_ratio, "readable_ratio": readable_ratio, "cls":"host"},
                {"plane_busy_frac": plane_busy_frac})

    # ---- bus segments & gating ----
    def bus_segments_for_op(self, op: Operation)->List[Tuple[float,float]]:
        segs=[]; t=0.0
        for s in op.states:
            if s.bus: segs.append((t, t+s.dur_us))
            t+=s.dur_us
        return segs

    def bus_precheck(self, start_hint: float, segs: List[Tuple[float,float]])->bool:
        for (off0,off1) in segs:
            a0, a1 = quantize(start_hint+off0), quantize(start_hint+off1)
            for (s,e) in self.bus_resv:
                if not (a1<=s or e<=a0): return False
        return True

    def bus_reserve(self, start_time: float, segs: List[Tuple[float,float]]):
        for (off0,off1) in segs:
            self.bus_resv.append((quantize(start_time+off0), quantize(start_time+off1)))

    # ---- future/committed helpers ----
    def _next_page_future(self, die:int, block:int)->int:
        last = self.addr_state_future[(die,block)]
        return (last + 1) if last < self.pages_per_block-1 else self.pages_per_block

    def _find_block_for_page_future_on_plane(self, die:int, plane:int, target_page:int)->Optional[int]:
        for b in self.iter_blocks_of_plane(plane):
            if self._next_page_future(die,b) == target_page:
                return b
        return None

    def _first_erased_block_on_plane(self, die:int, plane:int)->Optional[int]:
        for b in self.iter_blocks_of_plane(plane):
            if self.addr_state_future[(die,b)] == -1:
                return b
        return None

    def _committed_pages_on_plane(self, die:int, plane:int)->Set[int]:
        return {p for (b,p) in self.programmed_committed[(die,)] if (b % self.planes)==plane}

    # ---- planner (non-greedy; degrade fanout; READ=committed, PROGRAM=future) ----
    def _random_plane_sets(self, fanout:int, tries:int, start_plane:int)->List[List[int]]:
        P=list(range(self.planes)); out=[]
        for _ in range(tries):
            cand=set(random.sample(P, min(fanout,len(P))))
            if start_plane not in cand and random.random()<0.6:
                if len(cand)>0: cand.pop()
                cand.add(start_plane)
            if len(cand)==fanout:
                key=tuple(sorted(cand))
                if key not in out: out.append(key)
        return [list(ps) for ps in dict.fromkeys(out)]

    def plan_multipane(self, kind: OpKind, die:int, start_plane:int, desired_fanout:int, interleave:bool)\
            -> Optional[Tuple[List[Address], List[int], Scope]]:
        if desired_fanout<1: desired_fanout=1
        tries=self.cfg["policy"]["planner_max_tries"]
        for f in range(desired_fanout, 0, -1):
            for plane_set in self._random_plane_sets(f, tries, start_plane):
                if kind==OpKind.READ:
                    commons=None
                    for pl in plane_set:
                        pages=self._committed_pages_on_plane(die, pl)
                        commons=pages if commons is None else (commons & pages)
                        if not commons: break
                    if not commons: continue
                    page=random.choice(sorted(list(commons)))
                    targets=[]
                    for pl in plane_set:
                        blks=[b for (b,p) in self.programmed_committed[(die,)] if p==page and (b%self.planes)==pl]
                        if not blks: targets=[]; break
                        targets.append(Address(die,pl,blks[0],page))
                    if not targets: continue
                    return targets, plane_set, Scope.PLANE_SET

                elif kind==OpKind.PROGRAM:
                    # Choose candidate pages: mode of next pages across write heads; or 0 if erased exists
                    nxts=[]
                    for pl in plane_set:
                        b_head=self.write_head[(die,pl)]
                        nx=self._next_page_future(die,b_head)
                        nxts.append(None if nx>=self.pages_per_block else nx)
                    candidates=[]
                    vals=[x for x in nxts if x is not None]
                    if vals:
                        freq={}
                        for v in vals: freq[v]=freq.get(v,0)+1
                        candidates.append(max(freq.items(), key=lambda x:x[1])[0])
                    if all(self._first_erased_block_on_plane(die,pl) is not None for pl in plane_set):
                        if 0 not in candidates: candidates.append(0)
                    if not candidates: continue

                    chosen=None
                    for page in candidates:
                        tlist=[]
                        ok=True
                        for pl in plane_set:
                            b_head=self.write_head[(die,pl)]
                            if self._next_page_future(die,b_head)==page:
                                b=b_head
                            else:
                                b=self._find_block_for_page_future_on_plane(die,pl,page)
                                if b is None: ok=False; break
                            tlist.append(Address(die,pl,b,page))
                        if ok: chosen=tlist; break
                    if not chosen: continue
                    return chosen, plane_set, Scope.DIE_WIDE

                elif kind==OpKind.ERASE:
                    targets=[]
                    for pl in plane_set:
                        b=self.write_head[(die,pl)]
                        if self.addr_state_future[(die,b)] == -1:
                            # pick a non-erased block on this plane if possible
                            found=None
                            for bb in self.iter_blocks_of_plane(pl):
                                if self.addr_state_future[(die,bb)] >= 0:
                                    found=bb; break
                            if found is not None: b=found
                        targets.append(Address(die,pl,b,None))
                    return targets, plane_set, Scope.DIE_WIDE

                elif kind==OpKind.SR:
                    return [Address(die, plane_set[0], plane_set[0], None)], plane_set[:1], Scope.NONE

        return None

    # ---- precheck/reserve/future/commit ----
    def precheck_planescope(self, kind: OpKind, targets: List[Address], start_hint: float, scope: Scope)->bool:
        start_hint=quantize(start_hint); end_hint=start_hint
        die=targets[0].die
        # time overlap check
        if scope==Scope.DIE_WIDE: planes={(die,p) for p in range(self.planes)}
        elif scope==Scope.PLANE_SET: planes={(t.die,t.plane) for t in targets}
        else: planes={(targets[0].die, targets[0].plane)}
        for (d,p) in planes:
            for (s,e,_) in self.resv[(d,p)]:
                if not (end_hint<=s or e<=start_hint): return False
        # address/plane consistency + rules
        for t in targets:
            if t.plane != (t.block % self.planes): return False  # consistency
            com=self.addr_state_committed[(t.die,t.block)]
            fut=self.addr_state_future[(t.die,t.block)]
            if kind==OpKind.PROGRAM:
                if t.page is None: return False
                if t.page != fut + 1: return False
                if t.page >= self.pages_per_block: return False
            elif kind==OpKind.READ:
                if t.page is None: return False
                if (t.block, t.page) not in self.programmed_committed[(t.die,)]: return False
            elif kind==OpKind.ERASE:
                pass
        return True

    def reserve_planescope(self, op: Operation, start: float, end: float):
        die=op.targets[0].die; start=quantize(start); end=quantize(end)
        if op.meta.get("scope")=="DIE_WIDE":
            planes=[(die,p) for p in range(self.planes)]
        elif op.meta.get("scope")=="PLANE_SET":
            planes=[(t.die,t.plane) for t in op.targets]
        else:
            planes=[(op.targets[0].die, op.targets[0].plane)]
        for (d,p) in planes:
            self.available[(d,p)]=max(self.available[(d,p)], end)
            self.resv[(d,p)].append((start,end,None))

    def register_future(self, op: Operation, start: float, end: float):
        for t in op.targets:
            key=(t.die,t.block)
            if op.kind==OpKind.PROGRAM and t.page is not None:
                self.addr_state_future[key] = max(self.addr_state_future[key], t.page)
                # advance write head if full
                nxt = self._next_page_future(t.die, t.block)
                if nxt >= self.pages_per_block:
                    er = self._first_erased_block_on_plane(t.die, t.plane)
                    if er is not None:
                        self.write_head[(t.die, t.plane)] = er
            elif op.kind==OpKind.ERASE:
                self.addr_state_future[key] = -1
                self.write_head[(t.die, t.plane)] = t.block

    def commit(self, op: Operation):
        for t in op.targets:
            key=(t.die,t.block)
            if op.kind==OpKind.PROGRAM and t.page is not None:
                self.addr_state_committed[key] = max(self.addr_state_committed[key], t.page)
                self.programmed_committed[(t.die,)].add((t.block, t.page))
            elif op.kind==OpKind.ERASE:
                self.addr_state_committed[key] = -1
                self.programmed_committed[(t.die,)] = {
                    pp for pp in self.programmed_committed[(t.die,)] if pp[0] != t.block
                }

# --------------------------------------------------------------------------
# Exclusion Manager (runtime blocking windows)
@dataclass
class ExclWindow:
    start: float; end: float
    scope: str
    die: Optional[int]
    tokens: Set[str]  # {"ANY"}, {"BASE:READ"}, {"ALIAS:MUL_READ"} ...

class ExclusionManager:
    def __init__(self, cfg: Dict[str,Any]):
        self.cfg = cfg
        self.global_windows: List[ExclWindow] = []
        self.die_windows: Dict[int, List[ExclWindow]] = {}

    def _state_windows(self, op: Operation, start: float, states: List[str]) -> List[Tuple[float,float]]:
        wins=[]; t=start
        segs=[]
        for s in op.states:
            segs.append((s.name, t, t+s.dur_us)); t+=s.dur_us
        if states==["*"]:
            return [(segs[0][1], segs[-1][2])]
        want=set(states)
        for name, s0, s1 in segs:
            if name in want: wins.append((s0,s1))
        return wins

    def _token_blocks(self, tok: str, op: Operation) -> bool:
        if tok=="ANY": return True
        if tok.startswith("BASE:"):
            base=tok.split(":")[1]
            return op.kind.name==base
        if tok.startswith("ALIAS:"):
            alias=tok.split(":")[1]
            if alias=="MUL_READ": return (op.kind==OpKind.READ and op.meta.get("arity",1)>1)
            if alias=="SIN_READ": return (op.kind==OpKind.READ and op.meta.get("arity",1)==1)
        return False

    def allowed(self, op: Operation, start: float, end: float) -> bool:
        for w in self.global_windows:
            if not (end<=w.start or w.end<=start):
                if any(self._token_blocks(tok, op) for tok in w.tokens): return False
        die=op.targets[0].die
        for w in self.die_windows.get(die, []):
            if not (end<=w.start or w.end<=start):
                if any(self._token_blocks(tok, op) for tok in w.tokens): return False
        return True

    def register(self, op: Operation, start: float):
        rules = self.cfg.get("constraints",{}).get("exclusions",[])
        die = op.targets[0].die
        for r in rules:
            when=r["when"]; if_op=when.get("op")
            if if_op != op.kind.name:
                if not (op.kind==OpKind.READ and if_op=="READ"):
                    continue
            alias_need = when.get("alias")
            if alias_need=="MUL" and not (op.meta.get("arity",1)>1): continue
            if alias_need=="SIN" and not (op.meta.get("arity",1)==1): continue
            states = when.get("states", ["*"])
            windows = self._state_windows(op, start, states)
            scope=r.get("scope","GLOBAL"); tokens=set(r.get("blocks",[]))
            for (s0,s1) in windows:
                w=ExclWindow(start=quantize(s0), end=quantize(s1), scope=scope,
                             die=(die if scope=="DIE" else None), tokens=tokens)
                if scope=="GLOBAL":
                    self.global_windows.append(w)
                else:
                    self.die_windows.setdefault(die,[]).append(w)

# --------------------------------------------------------------------------
# Obligation Manager (with stats)
@dataclass(order=True)
class _ObHeapItem:
    deadline_us: float
    seq: int
    ob: "Obligation" = field(compare=False)

@dataclass
class Obligation:
    id: int
    require: OpKind
    targets: List[Address]
    deadline_us: float
    hard_slot: bool

class ObligationManager:
    def __init__(self, cfg_list: List[Dict[str,Any]]):
        self.specs = cfg_list
        self.heap: List[_ObHeapItem] = []
        self._seq = 0
        self.assigned: Dict[int, Obligation] = {}
        self.stats = {"created":0, "assigned":0, "fulfilled":0, "fulfilled_in_time":0, "expired":0}

    def on_commit(self, op: Operation, now_us: float):
        # READ completion -> create DOUT obligation(s)
        for spec in self.specs:
            if spec["issuer"] == op.kind.name:
                self._seq += 1
                dt = sample_dist(spec["window_us"])
                ob = Obligation(
                    id=self._seq,
                    require = OpKind[spec["require"]],
                    targets = op.targets,  # plane-set op as one obligation
                    deadline_us = quantize(now_us + dt),
                    hard_slot = spec["priority_boost"].get("hard_slot", False),
                )
                heapq.heappush(self.heap, _ObHeapItem(deadline_us=ob.deadline_us, seq=ob.id, ob=ob))
                self.stats["created"] += 1
                first=op.targets[0]
                print(f"[{now_us:7.2f} us] OBLIG  created: {op.kind.name} -> {ob.require.name} by {ob.deadline_us:7.2f} us, target(d{first.die},p{first.plane})")

    def pop_urgent(self, now_us: float, die:int, plane:int, horizon_us: float, earliest_start: float) -> Optional[Obligation]:
        if not self.heap: return None
        kept: List[_ObHeapItem] = []
        chosen: Optional[Obligation] = None
        now_us=quantize(now_us); earliest_start=quantize(earliest_start)
        while self.heap and not chosen:
            item = heapq.heappop(self.heap)
            ob=item.ob
            plane_list={a.plane for a in ob.targets}
            same_die=(ob.targets[0].die==die); same_plane=(plane in plane_list)
            in_horizon=((ob.deadline_us - now_us) <= max(horizon_us, 0.0)) or ob.hard_slot
            feasible=(earliest_start <= ob.deadline_us)
            if same_die and same_plane and in_horizon and feasible:
                chosen=ob; break
            kept.append(item)
        for it in kept: heapq.heappush(self.heap, it)
        return chosen

    def mark_assigned(self, ob: Obligation):
        self.assigned[ob.id] = ob
        self.stats["assigned"] += 1

    def mark_fulfilled(self, ob: Obligation, now: float):
        self.assigned.pop(ob.id, None)
        self.stats["fulfilled"] += 1
        if now <= ob.deadline_us:
            self.stats["fulfilled_in_time"] += 1

    def expire_due(self, now: float):
        kept=[]
        expired=0
        while self.heap and self.heap[0].deadline_us <= now:
            heapq.heappop(self.heap); expired+=1
        self.stats["expired"] += expired

# --------------------------------------------------------------------------
# Policy Engine (phase-conditional + admission gating + backoff)
class PolicyEngine:
    def __init__(self, cfg, addr: AddressManager, obl: ObligationManager, excl: ExclusionManager):
        self.cfg=cfg; self.addr=addr; self.obl=obl; self.excl=excl
        self.stats={"alias_degrade":0}

    def _score(self, op_name: str, phase_label: str, g: Dict[str,str], l: Dict[str,str]) -> float:
        w=self.cfg["weights"]["base"]["host"].get(op_name,0.0)
        w*=self.cfg["weights"]["g_state"]["pgmable_ratio"].get(g["pgmable_ratio"],1.0)
        w*=self.cfg["weights"]["g_state"]["readable_ratio"].get(g["readable_ratio"],1.0)
        w*=self.cfg["weights"]["g_local"]["plane_busy_frac"].get(l["plane_busy_frac"],1.0)
        near="MID_NEAR"
        if phase_label.endswith("START"): near="START_NEAR"
        elif phase_label.endswith("END"): near="END_NEAR"
        w*=self.cfg["weights"]["g_phase"].get(op_name,{}).get(near,1.0)
        return w

    def _fanout_from_alias(self, base_name: str, alias_constraint: Optional[Tuple[str,int]], hook_label: str)->Tuple[int,bool]:
        fanout, interleave = get_phase_selection_override(self.cfg, hook_label, base_name)
        if alias_constraint:
            mode,val=alias_constraint
            if mode=="eq": fanout=val
            elif mode=="ge": fanout=max(fanout,val)
        return max(1,fanout), interleave

    def _exclusion_ok(self, op: Operation, die:int, plane_set: List[int], start_hint: float) -> bool:
        scope = Scope[op.meta["scope"]]
        start = self.addr.earliest_start_for_scope(die, scope, plane_set)
        dur = get_op_duration(op); end=quantize(start+dur)
        return self.excl.allowed(op, start, end)

    def _admission_ok(self, now_us: float, hook_label: str, kind_name: str, start_hint: float, deadline: Optional[float]=None) -> bool:
        adm = self.cfg.get("admission", {})
        delta = get_admission_delta(self.cfg, hook_label, kind_name)
        if deadline is not None:  # for obligations if bypass disabled
            delta = min(delta, max(0.0, deadline - now_us))
        return start_hint <= now_us + delta

    def propose(self, now_us: float, hook: PhaseHook, g: Dict[str,str], l: Dict[str,str], earliest_start: float) -> Optional[Operation]:
        die, hook_plane = hook.die, hook.plane

        # 0) obligations first (with optional admission bypass)
        ob=self.obl.pop_urgent(now_us, die, hook_plane, horizon_us=10.0, earliest_start=earliest_start)
        if ob:
            cfg_op=self.cfg["op_specs"][ob.require.name]
            op=build_operation(ob.require, cfg_op, ob.targets)
            op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=sorted({a.plane for a in ob.targets}); op.meta["arity"]=len(op.meta["plane_list"])
            op.meta["obligation"]=ob
            scope=Scope[op.meta["scope"]]; plane_set=op.meta["plane_list"]
            start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
            # admission bypass?
            bypass = self.cfg.get("admission",{}).get("obligation_bypass",True)
            admission_ok = True if bypass else self._admission_ok(now_us, hook.label, ob.require.name, start_hint, ob.deadline_us)
            if admission_ok and \
               self.addr.precheck_planescope(op.kind, op.targets, start_hint, scope) and \
               self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op)) and \
               self._exclusion_ok(op, die, plane_set, start_hint):
                op.meta["source"]="obligation"; op.meta["phase_key_used"]="(obligation)"
                return op
            # else: fallthrough to policy

        # 1) phase-conditional (alias keys allowed + SR)
        allow=set(list(OP_ALIAS.keys())+["READ","PROGRAM","ERASE","SR"])
        dist, used_key = get_phase_dist(self.cfg, hook.label)
        if dist:
            pick=roulette_pick(dist, allow)
            if pick:
                base, alias_const = resolve_alias(pick)
                kind=OpKind[base]
                # plan
                if kind==OpKind.SR:
                    plan=self.addr.plan_multipane(kind, die, hook_plane, 1, True)
                else:
                    fanout, interleave=self._fanout_from_alias(base, alias_const, hook.label)
                    plan=self.addr.plan_multipane(kind, die, hook_plane, fanout, interleave)
                    if not plan and fanout>1:
                        self.stats["alias_degrade"]+=1
                        plan=self.addr.plan_multipane(kind, die, hook_plane, 1, interleave)
                if plan:
                    targets, plane_set, scope=plan
                    cfg_op=self.cfg["op_specs"][base]; op=build_operation(kind, cfg_op, targets)
                    op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=plane_set; op.meta["arity"]=len(plane_set); op.meta["alias_used"]=pick
                    start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
                    # admission gating: near-future only
                    if not self._admission_ok(now_us, hook.label, base, start_hint):
                        return None
                    if self.addr.precheck_planescope(kind, targets, start_hint, scope) and \
                       self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op)) and \
                       self._exclusion_ok(op, die, plane_set, start_hint):
                        op.meta["source"]="policy.phase_conditional"; op.meta["phase_key_used"]=used_key; return op
            # else fallthrough to backoff

        # 2) backoff (READ/PROGRAM/ERASE/SR)
        cand=[]
        for name in ["READ","PROGRAM","ERASE","SR"]:
            s=self._score(name, hook.label, g, l)
            if s>0: cand.append((name,s))
        if not cand: return None
        tot=sum(s for _,s in cand); r=random.random()*tot; acc=0.0; pick=cand[-1][0]
        for name,s in cand:
            acc+=s
            if r<=acc: pick=name; break
        kind=OpKind[pick]
        if kind==OpKind.SR:
            plan=self.addr.plan_multipane(kind, die, hook_plane, 1, True)
        else:
            fanout, interleave=get_phase_selection_override(self.cfg, hook.label, pick)
            plan=self.addr.plan_multipane(kind, die, hook_plane, fanout, interleave)
        if not plan: return None
        targets, plane_set, scope=plan
        cfg_op=self.cfg["op_specs"][pick]; op=build_operation(kind, cfg_op, targets)
        op.meta["scope"]=cfg_op["scope"]; op.meta["plane_list"]=plane_set; op.meta["arity"]=len(plane_set)
        start_hint=self.addr.earliest_start_for_scope(die, scope, plane_set)
        # admission gating
        if not self._admission_ok(now_us, hook.label, pick, start_hint):
            return None
        if not (self.addr.precheck_planescope(kind, targets, start_hint, scope) and \
                self.addr.bus_precheck(start_hint, self.addr.bus_segments_for_op(op)) and \
                self._exclusion_ok(op, die, plane_set, start_hint)):
            return None
        op.meta["source"]="policy.score_backoff"; op.meta["phase_key_used"]="(score_backoff)"; return op

# --------------------------------------------------------------------------
# Selection overrides
def get_phase_selection_override(cfg: Dict[str,Any], hook_label: str, kind_name: str):
    op, state, pos = parse_hook_key(hook_label)
    po=cfg.get("selection",{}).get("phase_overrides",{})
    keys=[]
    if op and state and pos: keys.append(f"{op}.{state}.{pos}")
    if op and state:         keys.append(f"{op}.{state}")
    for k in keys:
        val=po.get(k)
        if val:
            return int(val.get("fanout",1)), bool(val.get("interleave",True))
    dflt=cfg.get("selection",{}).get("defaults",{}).get(kind_name,{"fanout":1,"interleave":True})
    return int(dflt.get("fanout",1)), bool(dflt.get("interleave",True))

# --------------------------------------------------------------------------
# Scheduler
def _addr_str(a: Address)->str: return f"(d{a.die},p{a.plane},b{a.block},pg{a.page})"

class Scheduler:
    def __init__(self, cfg, addr: AddressManager, spe: PolicyEngine, obl: ObligationManager, excl: ExclusionManager):
        self.cfg=cfg; self.addr=addr; self.SPE=spe; self.obl=obl; self.excl=excl
        self.now=0.0; self.ev=[]; self._seq=0
        self.stat_propose_calls=0; self.stat_scheduled=0
        self._push(0.0, "QUEUE_REFILL", None)
        for plane in range(self.addr.planes):
            self._push(0.0, "PHASE_HOOK", PhaseHook(0.0, "BOOT.START", 0, plane))

    def _push(self, t: float, typ: str, payload: Any):
        heapq.heappush(self.ev, (quantize(t), self._seq, typ, payload)); self._seq+=1

    def _start_time_for_op(self, op: Operation) -> float:
        die=op.targets[0].die
        scope=Scope[op.meta.get("scope","PLANE_SET")]
        plane_set=[a.plane for a in op.targets]
        t_planes=self.addr.earliest_start_for_scope(die, scope, plane_set)
        return quantize(max(self.now, t_planes))

    def _label_for_read(self, op: Operation)->str:
        if op.kind!=OpKind.READ: return op.kind.name
        return "MUL_READ" if op.meta.get("arity",1)>1 else "SIN_READ"

    def _schedule_operation(self, op: Operation):
        start=self._start_time_for_op(op); dur=get_op_duration(op); end=quantize(start+dur)
        # reserve plane scope + bus + register exclusions + future update
        self.addr.reserve_planescope(op, start, end)
        self.addr.bus_reserve(start, self.addr.bus_segments_for_op(op))
        self.excl.register(op, start)
        self.addr.register_future(op, start, end)

        # obligation assignment stats
        if "obligation" in op.meta:
            self.obl.mark_assigned(op.meta["obligation"])

        # push events
        self._push(start, "OP_START", op); self._push(end, "OP_END", op)

        # hooks (READ → SIN_READ/MUL_READ label)
        label_op=self._label_for_read(op)
        for t in op.targets:
            cur=start
            for s in op.states:
                self._push(cur,               "PHASE_HOOK", PhaseHook(cur,               f"{label_op}.{s.name}.START", t.die, t.plane))
                if s.name=="CORE_BUSY":
                    self._push(cur + s.dur_us*0.5, "PHASE_HOOK", PhaseHook(cur + s.dur_us*0.5, f"{label_op}.{s.name}.MID",   t.die, t.plane))
                self._push(cur + s.dur_us,    "PHASE_HOOK", PhaseHook(cur + s.dur_us,    f"{label_op}.{s.name}.END",   t.die, t.plane))
                cur += s.dur_us

        first=op.targets[0]
        print(f"[{self.now:7.2f} us] SCHED  {op.kind.name:7s} arity={op.meta.get('arity')} scope={op.meta.get('scope')} start={start:7.2f} end={end:7.2f} 1st={_addr_str(first)} src={op.meta.get('source')} alias={op.meta.get('alias_used')}")

        self.stat_scheduled+=1

    def run_until(self, t_end: float):
        t_end=quantize(t_end)
        while self.ev and self.ev[0][0] <= t_end:
            self.now, _, typ, payload = heapq.heappop(self.ev)

            # expire obligations due
            self.obl.expire_due(self.now)

            if typ=="QUEUE_REFILL":
                for plane in range(self.addr.planes):
                    self._push(self.now, "PHASE_HOOK", PhaseHook(self.now, "REFILL.NUDGE", 0, plane))
                self._push(self.now + self.cfg["policy"]["queue_refill_period_us"], "QUEUE_REFILL", None)

            elif typ=="PHASE_HOOK":
                hook: PhaseHook = payload
                earliest_start=self.addr.available_at(hook.die, hook.plane)
                g,l=self.addr.observe_states(hook.die, hook.plane, self.now)
                self.stat_propose_calls+=1
                op=self.SPE.propose(self.now, hook, g, l, earliest_start)
                if op: self._schedule_operation(op)

            elif typ=="OP_START":
                op: Operation=payload; first=op.targets[0]
                print(f"[{self.now:7.2f} us] START  {op.kind.name:7s} arity={op.meta.get('arity')} target={_addr_str(first)}")

            elif typ=="OP_END":
                op: Operation=payload; first=op.targets[0]
                print(f"[{self.now:7.2f} us] END    {op.kind.name:7s} arity={op.meta.get('arity')} target={_addr_str(first)}")
                self.addr.commit(op)
                # obligation fulfillment stats
                if "obligation" in op.meta:
                    self.obl.mark_fulfilled(op.meta["obligation"], self.now)
                self.obl.on_commit(op, self.now)

        # final stats
        print(f"\n=== Stats ===")
        print(f"propose calls : {self.stat_propose_calls}")
        print(f"scheduled ops : {self.stat_scheduled}")
        if self.stat_propose_calls:
            print(f"accept ratio  : {100.0*self.stat_scheduled/self.stat_propose_calls:.1f}%")
        s=self.obl.stats
        rate=(100.0*s["fulfilled_in_time"]/s["created"]) if s["created"] else 0.0
        print(f"obligations   : created={s['created']} assigned={s['assigned']} fulfilled={s['fulfilled']} in_time={s['fulfilled_in_time']} expired={s['expired']} success={rate:.1f}%")

# --------------------------------------------------------------------------
# Main
def main():
    random.seed(CFG["rng_seed"])
    addr=AddressManager(CFG); excl=ExclusionManager(CFG)
    obl=ObligationManager(CFG["obligations"])
    spe=PolicyEngine(CFG, addr, obl, excl)
    sch=Scheduler(CFG, addr, spe, obl, excl)
    print("=== NAND Sequence Generator (P5: stats + admission + block/plane redefined) ===")
    sch.run_until(CFG["policy"]["run_until_us"])
    print("=== Done ===")

if __name__=="__main__":
    main()

```

포함된 핵심 변경점 요약
- 통계: ObligationManager.stats로 created/assigned/fulfilled/fulfilled_in_time/expired 집계.
  - 스케줄 시 mark_assigned, 커밋 시 mark_fulfilled, 이벤트 루프마다 expire_due.
  - 종료 시 성공률(fulfilled_in_time / created) 출력.
- Admission 게이팅: admission 설정에 따라 현재 시각+Δ 이내 시작 가능한 오퍼만 승인.
  - phase_overrides(예: CORE_BUSY: 0.05us) → CORE_BUSY 동안 SR 같은 즉시성 높은 연산 위주로 흘러가도록 제어.
  - Obligation은 기본 bypass(필요 시 obligation_bypass: false로 바꿔 제한 가능).
- 블록/플레인 재정의: plane = block % planes
  - 토폴로지: planes, blocks, pages_per_block로 단순화.
  - 상태 레일 키를 (die, block)로 재설계.
  - READ 플래닝은 커밋된 페이지만 가시, PROGRAM은 future rail로 다음 페이지 정합 보장.
  - write_head[(die, plane)]로 plane 스트라이프 내 블록 포인터 관리.
- 멀티플레인/제약/버스: 기존 의미론을 유지(READ plane‑set 점유, PROGRAM/ERASE die‑wide CORE_BUSY, DOUT freeze, SR anywhere, Bus gating).

필요하시면, admission/phase_conditional/selection의 수치를 더 공격적으로(또는 보수적으로) 튜닝한 프로파일도 만들어 줄게요.
